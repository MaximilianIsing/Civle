<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Civle Custom Game</title>
    <link rel="icon" type="image/png" href="assets/logo/Logo320x320.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
        // Custom game - no date in title
    </script>
    <style>
        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-Medium.ttf') format('truetype');
            font-weight: 500;
            font-style: normal;
        }

        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-Bold.ttf') format('truetype');
            font-weight: 700;
            font-style: normal;
        }

        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-ExtraBold.ttf') format('truetype');
            font-weight: 800;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #121213;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            margin: 0;
        }

        .header {
            background: #121213;
            padding: 16px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 1px solid #3a3a3c;
            position: relative;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .header-logo {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }
        
        .header h1 {
            font-size: 48px;
            font-weight: 700;
            margin: 0;
            letter-spacing: 0.01em;
            color: #ffffff;
        }

        .header-right {
            position: absolute;
            right: 16px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .yesterday-best-btn {
            padding: 8px 16px;
            background: #3a3a3c;
            color: #ffffff;
            border: 1px solid #565758;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.1s;
        }

        .yesterday-best-btn:hover {
            background: #565758;
        }

        .yesterday-best-btn:active {
            background: #4a4a4c;
        }

        .controls {
            position: absolute;
            right: 16px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        button {
            padding: 6px 12px;
            background: #3a3a3c;
            color: #ffffff;
            border: 1px solid #565758;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: background 0.1s;
        }

        button:hover {
            background: #565758;
        }

        button:active {
            background: #6b6b6d;
        }

        .file-label {
            display: inline-block;
            padding: 8px;
            background: transparent;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 20px;
            font-weight: 400;
            transition: background 0.1s;
            line-height: 1;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .file-label:hover {
            background: #3a3a3c;
        }

        input[type="file"] {
            display: none;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            background: #121213;
        }

        .sidebar {
            width: 280px;
            background: #121213;
            padding: 24px;
            overflow-y: auto;
            border-right: 1px solid #3a3a3c;
        }

        .sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #3a3a3c;
            border-radius: 4px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #565758;
        }

        .sidebar h2 {
            font-size: 16px;
            margin-bottom: 16px;
            color: #ffffff;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .available-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            margin: 4px 0;
            background: #3a3a3c;
            border: 1.5px solid #565758;
            border-radius: 4px;
            cursor: grab;
            user-select: none;
            transition: all 0.1s;
        }

        .available-item:hover {
            border-color: #818384;
            background: #565758;
        }

        .available-item:active {
            cursor: grabbing;
        }

        .available-item.dragging {
            opacity: 0.5;
        }

        .available-item img {
            width: 28px;
            height: 28px;
            object-fit: contain;
        }

        .available-item .count {
            margin-left: auto;
            font-weight: 600;
            color: #ffffff;
            font-size: 14px;
        }

        .available-item .count.zero {
            color: #818384;
        }
        
        .placement-tooltip {
            position: fixed;
            background: #3a3a3c;
            border: 1px solid #565758;
            border-radius: 6px;
            padding: 12px;
            color: #ffffff;
            font-size: 13px;
            max-width: 300px;
            z-index: 10002;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            line-height: 1.5;
        }
        
        .placement-tooltip h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: 700;
            color: #ffffff;
        }
        
        .placement-tooltip .requirement-section {
            margin-bottom: 8px;
        }
        
        .placement-tooltip .requirement-section:last-child {
            margin-bottom: 0;
        }
        
        .placement-tooltip .requirement-label {
            font-weight: 600;
            color: #818384;
        }
        
        .placement-tooltip .requirement-value {
            color: #ffffff;
        }
        
        .placement-tooltip .resource-images {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }
        
        .placement-tooltip .resource-tooltip-icon {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .map-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 24px;
            overflow: hidden;
            position: relative;
            background: #121213;
        }

        .map-transform-wrapper {
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            will-change: transform;
        }

        .map-container.dragging .map-transform-wrapper {
            transition: none;
        }

        .hex-grid {
            display: grid;
            gap: 0;
            line-height: 0;
        }

        .hex-row {
            display: flex;
            gap: 0;
            margin-bottom: -26px;
        }

        .hex-row.offset {
            margin-left: 36px;
        }

        .hex {
            width: 80px;
            height: 92.376px;
            position: relative;
            cursor: pointer;
            margin: 0;
            margin-right: -8px;
        }

        .hex.not-rightmost-column {
            clip-path: polygon(0% 0%, calc(100% - 5px) 0%, calc(100% - 5px) 100%, 0% 100%);
        }

        .hex.drag-over {
            outline: 2px solid #4a90e2;
            outline-offset: -2px;
        }

        .hex.valid-placement::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            background-image: url('assets/game_ui/Green_Hex.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.4;
            z-index: 100;
            pointer-events: none;
        }

        .hex.invalid-placement::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            background-image: url('assets/game_ui/Red_Hex.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.4;
            z-index: 100;
            pointer-events: none;
        }

        .hex-shape {
            width: 100%;
            height: 100%;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background: transparent;
            border: none;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 15;
        }

        .hex-base {
            width: 100%;
            height: 100%;
            object-fit: cover;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .hex-feature {
            width: 70%;
            height: 70%;
            object-fit: contain;
            position: absolute;
            top: 15%;
            left: 15%;
            z-index: 2;
        }

        .hex-resource {
            height: 40px;
            object-fit: contain;
            position: absolute;
            bottom: 8px;
            right: 20px;
            z-index: 3;
            filter: drop-shadow(0 1px 3px rgba(0,0,0,0.3));
        }

        .hex-district {
            width: 90%;
            height: 90%;
            object-fit: cover;
            position: absolute;
            top: 5%;
            left: calc(5% - 1px);
            z-index: 25000000;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
            cursor: grab;
        }
        
        .hex-district:hover {
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
        }
        
        .hex-district:active {
            cursor: grabbing;
        }
        
        .hex-district.dragging {
            opacity: 0.6;
        }

        .hex-improvement {
            width: 50%;
            height: 50%;
            object-fit: contain;
            position: absolute;
            bottom: calc(15% + 12px);
            left: calc(15% + 7px);
            z-index: 5;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
            cursor: grab;
        }
        
        .hex-improvement:hover {
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
        }
        
        .hex-improvement:active {
            cursor: grabbing;
        }

        .hex-improvement.has-resource {
            bottom: calc(15% + 25px);
        }

        .hex-wonder {
            width: 80%;
            height: 80%;
            object-fit: contain;
            position: absolute;
            top: 10%;
            left: 10%;
            z-index: 6;
            filter: drop-shadow(0 2px 6px rgba(255,215,0,0.6));
        }

        .hex-rivers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            overflow: visible;
        }

        .river-edge-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
            z-index: 21;
        }

        .adjacency-indicator {
            position: absolute;
            top: 70%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(58, 58, 60, 0.95);
            border: 1px solid #565758;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: 600;
            z-index: 25000001;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 1px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .yield-badge {
            display: flex;
            align-items: center;
            gap: 1px;
        }

        .yield-icon {
            width: 12px;
            height: 12px;
            object-fit: contain;
        }

        .yield-amount {
            color: #ffffff;
            font-size: 8px;
            line-height: 1;
        }

        .adjacency-preview {
            position: absolute;
            top: 70%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(58, 58, 60, 0.95);
            border: 1px solid #565758;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: 600;
            z-index: 25000001;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 1px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .score-panel {
            position: absolute;
            top: 24px;
            right: 24px;
            background: #3a3a3c;
            border: 1px solid #565758;
            border-radius: 8px;
            padding: 16px;
            min-width: 180px;
            z-index: 1001;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .score-panel h3 {
            margin-bottom: 12px;
            color: #ffffff;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            text-align: center;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            font-size: 13px;
            color: #ffffff;
            gap: 8px;
        }
        
        .score-item .yield-icon {
            width: 16px;
            height: 16px;
            object-fit: contain;
        }
        
        .score-item .yield-label {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .score-formula {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #565758;
            font-size: 13px;
            color: #ffffff;
        }
        
        .score-total {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #565758;
            font-weight: 700;
            font-size: 16px;
            color: #ffffff;
        }
        
        .submit-score-btn {
            width: 100%;
            margin-top: 16px;
            padding: 10px;
            background: #6aaa64;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.1s;
        }
        
        .submit-score-btn:hover {
            background: #5c9a56;
        }
        
        .submit-score-btn:active {
            background: #4d8a46;
        }
        
        .submit-score-btn:disabled {
            background: #3a3a3c;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .leaderboard-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .leaderboard-modal.active {
            display: flex;
        }
        
        .leaderboard-content {
            background: #121213;
            border: 1px solid #565758;
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            color: #ffffff;
        }
        
        .leaderboard-content h2 {
            margin: 0 0 16px 0;
            font-size: 24px;
            font-weight: 700;
            text-align: center;
        }
        
        .leaderboard-content .rank-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 16px;
            color: #ffffff;
        }

        .yesterday-best-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .yesterday-best-modal.active {
            display: flex;
        }

        .yesterday-best-content {
            background: #121213;
            border: 1px solid #565758;
            border-radius: 8px;
            padding: 24px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            color: #ffffff;
            text-align: center;
        }

        .yesterday-best-content h3 {
            color: #ffffff;
            margin-bottom: 12px;
            font-size: 18px;
            font-weight: 600;
        }

        .yesterday-best-content h2 {
            margin: 0 0 16px 0;
            font-size: 24px;
            font-weight: 700;
        }

        .yesterday-best-content img {
            max-width: 100%;
            height: auto;
            border: 1px solid #565758;
            border-radius: 4px;
        }
        

        .yesterday-best-content .close-btn {
            margin-top: 16px;
            padding: 8px 16px;
            background: #6aaa64;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .yesterday-best-content .close-btn:hover {
            background: #5c9a56;
        }
        
        .name-input-section {
            margin-bottom: 20px;
        }
        
        .name-input-section label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .name-input-section input {
            width: 100%;
            padding: 10px;
            background: #3a3a3c;
            color: #ffffff;
            border: 1px solid #565758;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        .name-input-section input:focus {
            outline: none;
            border-color: #818384;
        }
        
        .name-input-section .char-count {
            font-size: 12px;
            color: #818384;
            margin-top: 4px;
            text-align: right;
        }
        
        .leaderboard-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: #3a3a3c;
            border: 1px solid #565758;
            border-radius: 4px;
        }
        
        .leaderboard-item.rank-1 {
            background: #c9b458;
            border-color: #b8a347;
        }
        
        .leaderboard-item .rank {
            font-weight: 700;
            font-size: 16px;
            min-width: 30px;
        }
        
        .leaderboard-item .name {
            flex: 1;
            margin: 0 12px;
            font-size: 14px;
        }
        
        .leaderboard-item .score {
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .leaderboard-item .score-icon {
            width: 16px;
            height: 16px;
            object-fit: contain;
        }
        
        .leaderboard-close-btn {
            width: 100%;
            margin-top: 16px;
            padding: 10px;
            background: #3a3a3c;
            color: #ffffff;
            border: 1px solid #565758;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.1s;
        }
        
        .leaderboard-close-btn:hover {
            background: #565758;
        }

        .zoom-controls {
            position: absolute;
            top: 24px;
            left: 24px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 1001;
        }

        .zoom-controls button {
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #3a3a3c;
            border: 1px solid #565758;
            color: #ffffff;
        }

        .zoom-controls button:hover {
            background: #565758;
            border-color: #818384;
        }

        .hex-row:last-child {
            margin-bottom: 0;
        }

        .empty-state {
            text-align: center;
            color: #818384;
            padding: 40px;
        }

        .empty-state h2 {
            margin-bottom: 12px;
            color: #ffffff;
            font-weight: 600;
            font-size: 18px;
        }

        .empty-state p {
            color: #818384;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <img src="assets/logo/Logo320x320.png" alt="Civle Logo" class="header-logo">
            <h1>CIVLE</h1>
        </div>
        <div class="header-right">
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div class="empty-state">
                <h2>Upload Challenge</h2>
                <p>Please upload a challenge file to begin playing.</p>
                <input type="file" id="challengeFileInput" accept=".civle" style="display: none;" onchange="loadChallenge(event)">
                <button class="submit-score-btn" onclick="document.getElementById('challengeFileInput').click()" style="margin-top: 20px; width: 100%;">Upload Challenge File</button>
            </div>
        </div>

        <div class="map-container" id="mapContainer">
            <div class="empty-state">
                <h2>Loading...</h2>
                <p>Please wait</p>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let challengeData = null;
        let GRID_WIDTH = 0;
        let GRID_HEIGHT = 0;
        let placedItems = {}; // { "row,col": { type: "district"|"improvement"|"wonder", name: "..." } }
        let availableItems = {}; // { "District_Name": count, "Improvement_Name": count }
        let adjacencyData = null;
        let placementData = null;
        let resourcesData = null;

        // Zoom and pan state
        let mapZoom = 2.0;
        let mapPanX = 0;
        let mapPanY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartPanX = 0;
        let dragStartPanY = 0;
        let draggedItem = null;
        let draggedDistrict = null; // { row, col, name }
        let draggedImprovement = null; // { row, col, name }

        // Load game data from JSON files
        async function loadGameData() {
            try {
                const [adjacencyResponse, placementResponse, resourcesResponse] = await Promise.all([
                    fetch('../data/adjacency_database.json'),
                    fetch('../data/placement_database.json'),
                    fetch('../data/resources_database.json')
                ]);
                
                if (!adjacencyResponse.ok || !placementResponse.ok || !resourcesResponse.ok) {
                    throw new Error('One or more files could not be loaded');
                }
                
                adjacencyData = await adjacencyResponse.json();
                placementData = await placementResponse.json();
                resourcesData = await resourcesResponse.json();
            } catch (error) {
                console.error('Error loading game data:', error);
                const isCorsError = error.message.includes('Failed to fetch') || 
                                   error.message.includes('CORS') ||
                                   error.name === 'TypeError' ||
                                   window.location.protocol === 'file:';
                
                if (isCorsError || window.location.protocol === 'file:') {
                    alert('CORS Error: Cannot load files when opening HTML directly.\n\n' +
                          'Please run a local web server:\n\n' +
                          'Python 3: python -m http.server 8000\n' +
                          'Python 2: python -m SimpleHTTPServer 8000\n' +
                          'Node.js: npx http-server\n\n' +
                          'Then open http://localhost:8000/public/game.html in your browser.');
                } else {
                    alert('Failed to load game data files. Make sure the data folder contains adjacency_database.json, placement_database.json, and resources_database.json.\n\nError: ' + error.message);
                }
            }
        }

        // Base36 encoding/decoding (same as map maker)
        function toBase36(num) {
            if (num === 0) return '0';
            let result = '';
            while (num > 0) {
                result = (num % 36).toString(36) + result;
                num = Math.floor(num / 36);
            }
            return result;
        }

        function fromBase36(str) {
            return parseInt(str, 36);
        }

        // Terrain, features, and resources data (same as map maker)
        const terrainBases = [
            { name: 'Desert', path: 'assets/terrain/base/flat/Desert.webp' },
            { name: 'Grassland', path: 'assets/terrain/base/flat/Grassland.webp' },
            { name: 'Plains', path: 'assets/terrain/base/flat/Plains.webp' },
            { name: 'Snow', path: 'assets/terrain/base/flat/Snow.webp' },
            { name: 'Tundra', path: 'assets/terrain/base/flat/Tundra.webp' },
            { name: 'Desert_Hill', path: 'assets/terrain/base/hills/Desert_Hill.webp' },
            { name: 'Grassland_Hill', path: 'assets/terrain/base/hills/Grassland_Hill.webp' },
            { name: 'Plains_Hill', path: 'assets/terrain/base/hills/Plains_Hill.webp' },
            { name: 'Snow_Hill', path: 'assets/terrain/base/hills/Snow_Hill.webp' },
            { name: 'Tundra_Hills', path: 'assets/terrain/base/hills/Tundra_Hills.webp' },
            { name: 'Desert_Floodplains', path: 'assets/terrain/base/floodplains/Desert_Floodplains.webp' },
            { name: 'Grassland_Floodplains', path: 'assets/terrain/base/floodplains/Grassland_Floodplains.webp' },
            { name: 'Plains_Floodplains', path: 'assets/terrain/base/floodplains/Plains_Floodplains.webp' },
            { name: 'Mountain_Desert', path: 'assets/terrain/base/mountain/Mountain_Desert.webp' },
            { name: 'Mountain_Plains', path: 'assets/terrain/base/mountain/Mountain_Plains.webp' },
            { name: 'Mountain_Snow', path: 'assets/terrain/base/mountain/Mountain_Snow.webp' },
            { name: 'Mountain_Tundra', path: 'assets/terrain/base/mountain/Mountain_Tundra.webp' },
            { name: 'Mountains_Grassland', path: 'assets/terrain/base/mountain/Mountains_Grassland.webp' },
            { name: 'Coast', path: 'assets/terrain/base/water/Coast.webp' },
            { name: 'Ocean', path: 'assets/terrain/base/water/Ocean.webp' },
            { name: 'Reef', path: 'assets/terrain/base/water/Reef.webp' }
        ];

        const features = [
            { name: 'Woods', path: 'assets/terrain/features/Woods.webp' },
            { name: 'Rainforest', path: 'assets/terrain/features/Rainforest.webp' },
            { name: 'Marsh', path: 'assets/terrain/features/Marsh.webp' },
            { name: 'Geothermal_Fissure', path: 'assets/terrain/features/Geothermal_Fissure.webp' }
        ];

        const resources = [
            'Aluminum', 'Amber', 'Bananas', 'Cattle', 'Citrus', 'Coal', 'Cocoa', 'Coffee',
            'Copper', 'Cotton', 'Crabs', 'Deer', 'Diamonds', 'Dyes', 'Fish', 'Furs',
            'Gypsum', 'Honey', 'Horses', 'Incense', 'Ivory', 'Jade', 'Maize', 'Marble',
            'Mercury', 'Niter', 'Oil', 'Olives', 'Pearls', 'Rice', 'Salt', 'Sheep',
            'Silk', 'Silver', 'Spices', 'Stone', 'Sugar', 'Tea', 'Tobacco', 'Truffles',
            'Turtles', 'Uranium', 'Whales', 'Wheat', 'Wine'
        ];

        // Create lookup maps
        const terrainIndexMap = new Map();
        terrainBases.forEach((t, i) => terrainIndexMap.set(t.name, i));
        const terrainNameMap = new Map();
        terrainBases.forEach((t, i) => terrainNameMap.set(i, t));

        const featureIndexMap = new Map();
        features.forEach((f, i) => featureIndexMap.set(f.name, i));
        const featureNameMap = new Map();
        features.forEach((f, i) => featureNameMap.set(i, f));

        const resourceIndexMap = new Map();
        resources.forEach((r, i) => resourceIndexMap.set(r, i));
        const resourceNameMap = new Map();
        resources.forEach((r, i) => resourceNameMap.set(i, r));

        // River edge images
        const riverEdgeImages = {
            0: 'Top_Right',
            1: 'Right',
            2: 'Bottom_Right',
            3: 'Bottom_Left',
            4: 'Left',
            5: 'Top_Left'
        };

        function loadChallenge(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = e.target.result;
                    
                    if (data.startsWith('CIV1')) {
                        // New optimized format
                        const width = data.charCodeAt(4) - 48;
                        const height = data.charCodeAt(5) - 48;
                        
                        GRID_WIDTH = width;
                        GRID_HEIGHT = height;
                        
                        challengeData = {
                            width: width,
                            height: height,
                            tiles: {},
                            allocations: {
                                districts: {},
                                improvements: {},
                                wonders: {}
                            }
                        };
                        
                        const tilesData = data.substring(7);
                        const parts = tilesData.split('||');
                        const tilesStr = parts[0];
                        
                        if (tilesStr) {
                            const tiles = tilesStr.split('|');
                            tiles.forEach(tileStr => {
                                if (!tileStr) return;
                                const [pos, data] = tileStr.split(':');
                                if (!pos || !data) return;
                                
                                const [rowStr, colStr] = pos.split(',');
                                const row = parseInt(rowStr);
                                const col = parseInt(colStr);
                                
                                const dataParts = data.split(';');
                                let mainData = dataParts[0];
                                
                                let tStr = '';
                                let fStr = '';
                                let rStr = '';
                                
                                if (mainData.includes(',') && mainData.split(',').length >= 3) {
                                    const fields = mainData.split(',');
                                    tStr = fields[0] || '.';
                                    fStr = fields[1] || '.';
                                    rStr = fields[2] || '.';
                                } else {
                                    tStr = mainData[0] || '.';
                                    fStr = mainData[1] || '.';
                                    rStr = mainData[2] || '.';
                                }
                                
                                const key = `${row},${col}`;
                                challengeData.tiles[key] = {};
                                
                                if (tStr && tStr !== '.') {
                                    const tIdx = fromBase36(tStr) - 1;
                                    const terrain = terrainNameMap.get(tIdx);
                                    if (terrain) {
                                        challengeData.tiles[key].terrain = terrain.name;
                                        challengeData.tiles[key].terrainPath = terrain.path;
                                    }
                                }
                                
                                if (fStr && fStr !== '.') {
                                    const fIdx = fromBase36(fStr) - 1;
                                    const feature = featureNameMap.get(fIdx);
                                    if (feature) {
                                        challengeData.tiles[key].feature = feature.name;
                                        challengeData.tiles[key].featurePath = feature.path;
                                    }
                                }
                                
                                if (rStr && rStr !== '.') {
                                    const rIdx = fromBase36(rStr) - 1;
                                    const resource = resourceNameMap.get(rIdx);
                                    if (resource) {
                                        challengeData.tiles[key].resource = resource;
                                        challengeData.tiles[key].resourcePath = `assets/recources/${resource}.webp`;
                                    }
                                }
                                
                                if (dataParts.length > 1 && dataParts[1]) {
                                    const riversBin = parseInt(dataParts[1], 36).toString(2).padStart(6, '0');
                                    challengeData.tiles[key].rivers = [];
                                    for (let i = 0; i < 6; i++) {
                                        challengeData.tiles[key].rivers[i] = riversBin[i] === '1';
                                    }
                                }
                            });
                        }
                        
                        // Load allocations
                        const allocationsStr = parts.length > 1 ? parts[1] : null;
                        if (allocationsStr) {
                            const allocations = allocationsStr.split(',');
                            allocations.forEach(allocStr => {
                                if (!allocStr) return;
                                const parts = allocStr.split(':');
                                const type = parts[0];
                                const name = parts[1];
                                
                                if (type === 'd') {
                                    if (parts[2] === 'c') {
                                        challengeData.allocations.districts[name] = true;
                                    } else {
                                        challengeData.allocations.districts[name] = parseInt(parts[2]) || 0;
                                    }
                                } else if (type === 'i') {
                                    challengeData.allocations.improvements[name] = parseInt(parts[2]) || 0;
                                } else if (type === 'w') {
                                    challengeData.allocations.wonders[name] = true;
                                }
                            });
                        }
                    } else {
                        // Old JSON format
                        const loadedData = JSON.parse(data);
                        challengeData = loadedData;
                        GRID_WIDTH = loadedData.width;
                        GRID_HEIGHT = loadedData.height;
                    }
                    
                    // Initialize game
                    placedItems = {};
                    availableItems = {};
                    
                    // Copy allocations to available items
                    Object.keys(challengeData.allocations.districts).forEach(name => {
                        const count = challengeData.allocations.districts[name];
                        if (count === true) {
                            availableItems[name] = 1;
                        } else if (count > 0) {
                            availableItems[name] = count;
                        }
                    });
                    
                    Object.keys(challengeData.allocations.improvements).forEach(name => {
                        const count = challengeData.allocations.improvements[name];
                        if (count > 0) {
                            availableItems[name] = count;
                        }
                    });
                    
                    Object.keys(challengeData.allocations.wonders).forEach(name => {
                        if (challengeData.allocations.wonders[name]) {
                            availableItems[name] = 1;
                        }
                    });
                    
                    initializeGame();
                } catch (error) {
                    console.error('Error loading challenge:', error);
                    alert('Failed to load challenge file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Load daily challenge from server
        async function loadDailyChallenge() {
            try {
                const response = await fetch('/daily-challenge');
                if (!response.ok) {
                    if (response.status === 404) {
                        console.log('No challenge available for today');
                        // Show message that challenge will be available later
                        const sidebar = document.getElementById('sidebar');
                        if (sidebar) {
                            sidebar.innerHTML = `
                                <div class="empty-state">
                                    <h2>No Challenge Today</h2>
                                    <p>Check back tomorrow for a new challenge!</p>
                                </div>
                            `;
                        }
                        return;
                    }
                    throw new Error('Failed to load daily challenge');
                }
                
                const data = await response.text();
                
                // Parse the challenge data (same logic as loadChallenge)
                if (data.startsWith('CIV1')) {
                    // New optimized format
                    const width = data.charCodeAt(4) - 48;
                    const height = data.charCodeAt(5) - 48;
                    
                    GRID_WIDTH = width;
                    GRID_HEIGHT = height;
                    
                    challengeData = {
                        width: width,
                        height: height,
                        tiles: {},
                        allocations: {
                            districts: {},
                            improvements: {},
                            wonders: {}
                        }
                    };
                    
                    const tilesData = data.substring(7);
                    const parts = tilesData.split('||');
                    const tilesStr = parts[0];
                    
                    if (tilesStr) {
                        const tiles = tilesStr.split('|');
                        tiles.forEach(tileStr => {
                            if (!tileStr) return;
                            const [pos, data] = tileStr.split(':');
                            if (!pos || !data) return;
                            
                            const [rowStr, colStr] = pos.split(',');
                            const row = parseInt(rowStr);
                            const col = parseInt(colStr);
                            
                            const dataParts = data.split(';');
                            let mainData = dataParts[0];
                            
                            let tStr = '';
                            let fStr = '';
                            let rStr = '';
                            
                            if (mainData.includes(',') && mainData.split(',').length >= 3) {
                                const fields = mainData.split(',');
                                tStr = fields[0] || '.';
                                fStr = fields[1] || '.';
                                rStr = fields[2] || '.';
                            } else {
                                tStr = mainData[0] || '.';
                                fStr = mainData[1] || '.';
                                rStr = mainData[2] || '.';
                            }
                            
                            const key = `${row},${col}`;
                            challengeData.tiles[key] = {};
                            
                            if (tStr && tStr !== '.') {
                                const tIdx = fromBase36(tStr) - 1;
                                const terrain = terrainNameMap.get(tIdx);
                                if (terrain) {
                                    challengeData.tiles[key].terrain = terrain.name;
                                    challengeData.tiles[key].terrainPath = terrain.path;
                                }
                            }
                            
                            if (fStr && fStr !== '.') {
                                const fIdx = fromBase36(fStr) - 1;
                                const feature = featureNameMap.get(fIdx);
                                if (feature) {
                                    challengeData.tiles[key].feature = feature.name;
                                    challengeData.tiles[key].featurePath = feature.path;
                                }
                            }
                            
                            if (rStr && rStr !== '.') {
                                const rIdx = fromBase36(rStr) - 1;
                                const resource = resourceNameMap.get(rIdx);
                                if (resource) {
                                    challengeData.tiles[key].resource = resource;
                                    challengeData.tiles[key].resourcePath = `assets/recources/${resource}.webp`;
                                }
                            }
                            
                            if (dataParts.length > 1 && dataParts[1]) {
                                const riversBin = parseInt(dataParts[1], 36).toString(2).padStart(6, '0');
                                challengeData.tiles[key].rivers = [];
                                for (let i = 0; i < 6; i++) {
                                    challengeData.tiles[key].rivers[i] = riversBin[i] === '1';
                                }
                            }
                        });
                    }
                    
                    // Load allocations
                    const allocationsStr = parts.length > 1 ? parts[1] : null;
                    if (allocationsStr) {
                        const allocations = allocationsStr.split(',');
                        allocations.forEach(allocStr => {
                            if (!allocStr) return;
                            const parts = allocStr.split(':');
                            const type = parts[0];
                            const name = parts[1];
                            
                            if (type === 'd') {
                                if (parts[2] === 'c') {
                                    challengeData.allocations.districts[name] = true;
                                } else {
                                    challengeData.allocations.districts[name] = parseInt(parts[2]) || 0;
                                }
                            } else if (type === 'i') {
                                challengeData.allocations.improvements[name] = parseInt(parts[2]) || 0;
                            } else if (type === 'w') {
                                challengeData.allocations.wonders[name] = true;
                            }
                        });
                    }
                } else {
                    // Old JSON format
                    const loadedData = JSON.parse(data);
                    challengeData = loadedData;
                    GRID_WIDTH = loadedData.width;
                    GRID_HEIGHT = loadedData.height;
                }
                
                // Initialize game
                placedItems = {};
                availableItems = {};
                
                // Copy allocations to available items
                Object.keys(challengeData.allocations.districts).forEach(name => {
                    const count = challengeData.allocations.districts[name];
                    if (count === true) {
                        availableItems[name] = 1;
                    } else if (count > 0) {
                        availableItems[name] = count;
                    }
                });
                
                Object.keys(challengeData.allocations.improvements).forEach(name => {
                    const count = challengeData.allocations.improvements[name];
                    if (count > 0) {
                        availableItems[name] = count;
                    }
                });
                
                Object.keys(challengeData.allocations.wonders).forEach(name => {
                    if (challengeData.allocations.wonders[name]) {
                        availableItems[name] = 1;
                    }
                });
                
                initializeGame();
            } catch (error) {
                console.error('Error loading daily challenge:', error);
                // Show error message but don't block the UI
                const sidebar = document.getElementById('sidebar');
                if (sidebar) {
                    sidebar.innerHTML = `
                        <div class="empty-state">
                            <h2>Error Loading Challenge</h2>
                            <p>${error.message}</p>
                            <p>You can still load a challenge file manually.</p>
                        </div>
                    `;
                }
            }
        }

        function initializeGame() {
            createHexGrid();
            populateSidebar();
            initMapZoomPan();
            updateAllScores();
        }

        function createHexGrid() {
            const mapContainer = document.getElementById('mapContainer');
            mapContainer.innerHTML = '';
            
            const mapTransformWrapper = document.createElement('div');
            mapTransformWrapper.className = 'map-transform-wrapper';
            mapTransformWrapper.id = 'mapTransformWrapper';
            
            const grid = document.createElement('div');
            grid.className = 'hex-grid';
            grid.id = 'hexGrid';
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                const hexRow = document.createElement('div');
                hexRow.className = 'hex-row';
                if (row % 2 === 1) {
                    hexRow.classList.add('offset');
                }

                for (let col = 0; col < GRID_WIDTH; col++) {
                    const hex = createHex(row, col);
                    hexRow.appendChild(hex);
                }

                grid.appendChild(hexRow);
            }
            
            mapTransformWrapper.appendChild(grid);
            
            // Create a separate districts layer on top of everything
            const districtsLayer = document.createElement('div');
            districtsLayer.className = 'hex-grid';
            districtsLayer.id = 'districtsLayer';
            districtsLayer.style.position = 'absolute';
            districtsLayer.style.top = '0';
            districtsLayer.style.left = '0';
            districtsLayer.style.pointerEvents = 'none';
            districtsLayer.style.zIndex = '1000';
            
            // Create districts grid structure
            for (let row = 0; row < GRID_HEIGHT; row++) {
                const hexRow = document.createElement('div');
                hexRow.className = 'hex-row';
                if (row % 2 === 1) {
                    hexRow.classList.add('offset');
                }

                for (let col = 0; col < GRID_WIDTH; col++) {
                    const districtHex = document.createElement('div');
                    districtHex.className = 'hex';
                    districtHex.dataset.row = row;
                    districtHex.dataset.col = col;
                    districtHex.style.pointerEvents = 'none';
                    
                    const districtShape = document.createElement('div');
                    districtShape.className = 'hex-shape';
                    districtShape.id = `district-shape-${row}-${col}`;
                    
                    districtHex.appendChild(districtShape);
                    hexRow.appendChild(districtHex);
                }
                
                districtsLayer.appendChild(hexRow);
            }
            
            mapTransformWrapper.appendChild(districtsLayer);
            mapTransformWrapper.style.position = 'relative';
            mapContainer.appendChild(mapTransformWrapper);
            
            // Update visuals for all hexes after they're in the DOM
            // First pass: render everything EXCEPT districts
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    updateHexVisualBase(row, col);
                }
            }
            // Second pass: render districts in separate layer
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    updateHexVisualDistricts(row, col);
                }
            }
            
            // Add score panel
            const scorePanel = document.createElement('div');
            scorePanel.className = 'score-panel';
            scorePanel.id = 'scorePanel';
            mapContainer.appendChild(scorePanel);
            
            // Add zoom controls
            const zoomControls = document.createElement('div');
            zoomControls.className = 'zoom-controls';
            zoomControls.innerHTML = `
                <button id="zoomInBtn" title="Zoom In">+</button>
                <button id="zoomOutBtn" title="Zoom Out"></button>
                <button id="resetZoomBtn" title="Reset Zoom"></button>
            `;
            mapContainer.appendChild(zoomControls);
        }

        function createHex(row, col) {
            const hex = document.createElement('div');
            hex.className = 'hex';
            // Add class if not in rightmost column
            if (col < GRID_WIDTH - 1) {
                hex.classList.add('not-rightmost-column');
            } else {
                hex.classList.add('rightmost-column');
            }
            hex.dataset.row = row;
            hex.dataset.col = col;

            const hexShape = document.createElement('div');
            hexShape.className = 'hex-shape';

            const riversContainer = document.createElement('div');
            riversContainer.className = 'hex-rivers';

            hex.appendChild(hexShape);
            hex.appendChild(riversContainer);


            // Drag and drop handlers
            hex.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                // Don't show blue box when dragging districts - we have red/green highlights instead
            });

            hex.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (draggedItem) {
                    // Dragging from sidebar
                    placeItem(row, col, draggedItem.type, draggedItem.name);
                    draggedItem = null;
                } else if (draggedDistrict) {
                    // Dragging a district to move it
                    const sourceKey = `${draggedDistrict.row},${draggedDistrict.col}`;
                    const targetKey = `${row},${col}`;
                    
                    // If dropping on the same hex, do nothing and clear the dragged state IMMEDIATELY
                    if (sourceKey === targetKey) {
                        // Dropped back on original location - restore opacity first, then clear
                        const draggedImg = document.querySelector(`.hex-district[data-row="${draggedDistrict.row}"][data-col="${draggedDistrict.col}"]`);
                        if (draggedImg) {
                            draggedImg.style.opacity = '1';
                            draggedImg.style.cursor = 'grab';
                        }
                        // Clear IMMEDIATELY before anything else to prevent map container handler from seeing it
                        draggedDistrict = null;
                        // Make sure event doesn't bubble
                        e.stopPropagation();
                        e.preventDefault();
                        return; // Exit early, don't process further
                    } else {
                        const tile = challengeData.tiles[targetKey];
                        const districtName = draggedDistrict.name;
                        const targetDistrict = placedItems[targetKey];
                        
                        // Check if we're swapping with another district of the same type
                        let isSwap = false;
                        if (targetDistrict && 
                            targetDistrict.type === 'district' && 
                            targetDistrict.name === districtName &&
                            districtName !== 'City_Center') {
                            isSwap = canDistrictsSwap(sourceKey, targetKey);
                        }
                        
                        if (isSwap) {
                            // Perform swap: exchange positions and owners
                            const sourceDistrict = placedItems[sourceKey];
                            const targetDistrictOwner = targetDistrict.owner;
                            
                            // Remove both from their current locations
                            delete placedItems[sourceKey];
                            delete placedItems[targetKey];
                            
                            // Place them in swapped positions
                            // First, place source district at target location
                            placedItems[targetKey] = { 
                                type: 'district', 
                                name: districtName
                            };
                            
                            // Then, place target district at source location
                            placedItems[sourceKey] = { 
                                type: 'district', 
                                name: districtName
                            };
                            
                            // Assign ownership for both districts (will use ambiguous owners if applicable)
                            assignDistrictOwnership(targetKey, row, col, districtName, { row: draggedDistrict.row, col: draggedDistrict.col });
                            assignDistrictOwnership(sourceKey, draggedDistrict.row, draggedDistrict.col, districtName, { row, col });
                            
                            // Update visuals for both locations and their neighbors
                            updateHexVisual(draggedDistrict.row, draggedDistrict.col);
                            const oldNeighbors = getNeighbors(draggedDistrict.row, draggedDistrict.col);
                            oldNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            updateHexVisual(row, col);
                            const newNeighbors = getNeighbors(row, col);
                            newNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            updateAllScores();
                            populateSidebar();
                            draggedDistrict = null;
                        } else if (isValidPlacement(row, col, 'district', districtName, tile, { row: draggedDistrict.row, col: draggedDistrict.col })) {
                            // Normal move (not a swap)
                            // Remove from old location (this adds it back to availableItems)
                            const oldKey = `${draggedDistrict.row},${draggedDistrict.col}`;
                            // Get the old owner before removing
                            const oldDistrict = placedItems[oldKey];
                            const oldOwner = oldDistrict ? oldDistrict.owner : null;
                            delete placedItems[oldKey];
                            availableItems[districtName] = (availableItems[districtName] || 0) + 1;
                            
                            // Place at new location (subtract from availableItems to keep count correct)
                            const key = `${row},${col}`;
                            // Remove any existing item at this location
                            if (placedItems[key]) {
                                const oldItem = placedItems[key];
                                availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
                            }
                            placedItems[key] = { type: 'district', name: districtName };
                            
                            // Assign district to a City_Center if it's not a City_Center itself
                            // This allows districts to swap city center owners when moved to a new location
                            // Uses ambiguous ownership if multiple city centers are valid
                            if (districtName !== 'City_Center') {
                                assignDistrictOwnership(key, row, col, districtName, { row: draggedDistrict.row, col: draggedDistrict.col });
                            }
                            
                            availableItems[districtName] = (availableItems[districtName] || 0) - 1;
                            
                            // If a City_Center was moved, reassign ownership of districts it owned
                            // This allows districts to swap to other city centers if they're better positioned
                            if (districtName === 'City_Center') {
                                const districtsToReassign = [];
                                const districtsToDelete = [];
                                
                                // Find all districts that were owned by this City_Center at its old location
                                // Handle both direct owners and ambiguous owners
                                for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                                    if (districtPlaced.type === 'district' && 
                                        districtPlaced.name !== 'City_Center') {
                                        // Check if this district is owned by (or could be owned by) the old city center
                                        if (Array.isArray(districtPlaced.owner)) {
                                            if (districtPlaced.owner.includes(oldKey)) {
                                                districtsToReassign.push(districtKey);
                                            }
                                        } else if (districtPlaced.owner === oldKey) {
                                            districtsToReassign.push(districtKey);
                                        }
                                    }
                                }
                                
                                // Reassign ownership for all districts that were owned by the old city center
                                // This will find the best available city center (could be the moved one or a different one)
                                for (const districtKey of districtsToReassign) {
                                    reassignDistrictOwnership(districtKey);
                                    
                                    const district = placedItems[districtKey];
                                    if (district) {
                                        // If no valid owner was found (district is out of range of all city centers), delete it
                                        if (!district.owner) {
                                            districtsToDelete.push(districtKey);
                                        } else {
                                            // Update visuals for the reassigned district and its neighbors
                                            const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                            updateHexVisual(districtRow, districtCol);
                                            const districtNeighbors = getNeighbors(districtRow, districtCol);
                                            districtNeighbors.forEach(neighbor => {
                                                updateHexVisual(neighbor.row, neighbor.col);
                                            });
                                        }
                                    }
                                }
                                
                                // Delete districts that are out of range of all city centers
                                for (const districtKey of districtsToDelete) {
                                    const district = placedItems[districtKey];
                                    if (district) {
                                        // Add back to available items
                                        availableItems[district.name] = (availableItems[district.name] || 0) + 1;
                                        // Delete the district
                                        delete placedItems[districtKey];
                                        // Update visuals for the deleted district location
                                        const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                        updateHexVisual(districtRow, districtCol);
                                        const districtNeighbors = getNeighbors(districtRow, districtCol);
                                        districtNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                    }
                                }
                                
                                // Also check all districts that might now be better owned by the moved city center
                                // This handles the case where a district was within range of 2 city centers
                                // and the moved city center is now closer
                                for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                                    if (districtPlaced.type === 'district' && 
                                        districtPlaced.name !== 'City_Center' &&
                                        districtPlaced.owner) {
                                        // Check if this district is not already owned by the new city center location
                                        let isOwnedByNewCity = false;
                                        if (Array.isArray(districtPlaced.owner)) {
                                            isOwnedByNewCity = districtPlaced.owner.includes(key);
                                        } else {
                                            isOwnedByNewCity = districtPlaced.owner === key;
                                        }
                                        
                                        if (!isOwnedByNewCity) {
                                            // Reassign to see if the moved city center is now a better owner
                                            reassignDistrictOwnership(districtKey);
                                            
                                            // Update visuals if ownership changed
                                            const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                            updateHexVisual(districtRow, districtCol);
                                            const districtNeighbors = getNeighbors(districtRow, districtCol);
                                            districtNeighbors.forEach(neighbor => {
                                                updateHexVisual(neighbor.row, neighbor.col);
                                            });
                                        }
                                    }
                                }
                                
                                // Check all Aqueducts adjacent to both old and new City_Center locations
                                // Delete any that no longer meet placement requirements
                                const aqueductsToCheck = new Set();
                                
                                // Check neighbors of new location
                                const newCityNeighbors = getNeighbors(row, col);
                                for (const neighbor of newCityNeighbors) {
                                    const neighborKey = `${neighbor.row},${neighbor.col}`;
                                    const neighborPlaced = placedItems[neighborKey];
                                    if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'Aqueduct') {
                                        aqueductsToCheck.add(neighborKey);
                                    }
                                }
                                
                                // Check neighbors of old location
                                const oldCityNeighbors = getNeighbors(draggedDistrict.row, draggedDistrict.col);
                                for (const neighbor of oldCityNeighbors) {
                                    const neighborKey = `${neighbor.row},${neighbor.col}`;
                                    const neighborPlaced = placedItems[neighborKey];
                                    if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'Aqueduct') {
                                        aqueductsToCheck.add(neighborKey);
                                    }
                                }
                                
                                const aqueductsToDelete = [];
                                for (const aqueductKey of aqueductsToCheck) {
                                    const [aqueductRow, aqueductCol] = aqueductKey.split(',').map(Number);
                                    const aqueductTile = challengeData.tiles[aqueductKey];
                                    // Validate this Aqueduct against placement rules
                                    if (!isValidPlacement(aqueductRow, aqueductCol, 'district', 'Aqueduct', aqueductTile)) {
                                        aqueductsToDelete.push(aqueductKey);
                                    }
                                }
                                
                                // Delete Aqueducts that no longer meet requirements
                                for (const aqueductKey of aqueductsToDelete) {
                                    const aqueduct = placedItems[aqueductKey];
                                    if (aqueduct) {
                                        // Add back to available items
                                        availableItems[aqueduct.name] = (availableItems[aqueduct.name] || 0) + 1;
                                        // Delete the Aqueduct
                                        delete placedItems[aqueductKey];
                                        // Update visuals for the deleted Aqueduct location
                                        const [aqueductRow, aqueductCol] = aqueductKey.split(',').map(Number);
                                        updateHexVisual(aqueductRow, aqueductCol);
                                        const aqueductNeighbors = getNeighbors(aqueductRow, aqueductCol);
                                        aqueductNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                    }
                                }
                                
                                // Check all Canals that might be affected by the city center move
                                // A Canal can be valid if it has a city center on one of its opposite tiles
                                // Check all Canals within 4 tiles of both old and new city center locations
                                const canalsToCheck = new Set();
                                
                                // Check all placed items for Canals within range
                                for (const [canalKey, canalPlaced] of Object.entries(placedItems)) {
                                    if (canalPlaced.type === 'district' && canalPlaced.name === 'Canal') {
                                        const [canalRow, canalCol] = canalKey.split(',').map(Number);
                                        
                                        // Check distance to old city center location
                                        const distanceToOld = getHexDistance(canalRow, canalCol, draggedDistrict.row, draggedDistrict.col);
                                        // Check distance to new city center location
                                        const distanceToNew = getHexDistance(canalRow, canalCol, row, col);
                                        
                                        // A city center could be on one of the opposite tiles if it's within 4 tiles
                                        // (water tile is 1 tile away, opposite tiles are 3 tiles from water = 4 tiles from canal)
                                        if (distanceToOld <= 4 || distanceToNew <= 4) {
                                            canalsToCheck.add(canalKey);
                                        }
                                    }
                                }
                                
                                const canalsToDelete = [];
                                for (const canalKey of canalsToCheck) {
                                    const [canalRow, canalCol] = canalKey.split(',').map(Number);
                                    const canalTile = challengeData.tiles[canalKey];
                                    // Validate this Canal against placement rules
                                    if (!isValidPlacement(canalRow, canalCol, 'district', 'Canal', canalTile)) {
                                        canalsToDelete.push(canalKey);
                                    }
                                }
                                
                                // Delete Canals that no longer meet requirements
                                for (const canalKey of canalsToDelete) {
                                    const canal = placedItems[canalKey];
                                    if (canal) {
                                        // Add back to available items
                                        availableItems[canal.name] = (availableItems[canal.name] || 0) + 1;
                                        // Delete the Canal
                                        delete placedItems[canalKey];
                                        // Update visuals for the deleted Canal location
                                        const [canalRow, canalCol] = canalKey.split(',').map(Number);
                                        updateHexVisual(canalRow, canalCol);
                                        const canalNeighbors = getNeighbors(canalRow, canalCol);
                                        canalNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                    }
                                }
                            }
                            
                            // Update visuals for old location and its neighbors
                            updateHexVisual(draggedDistrict.row, draggedDistrict.col);
                            const oldNeighbors = getNeighbors(draggedDistrict.row, draggedDistrict.col);
                            oldNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            // Update visuals for new location and its neighbors
                            updateHexVisual(row, col);
                            const newNeighbors = getNeighbors(row, col);
                            newNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            updateAllScores();
                            populateSidebar();
                            // Clear draggedDistrict on successful move
                            draggedDistrict = null;
                        } else {
                            // Invalid placement - district stays in original location
                            // draggedDistrict will be cleared in dragend
                        }
                    }
                } else if (draggedImprovement) {
                    // Dragging an improvement to move it
                    const sourceKey = `${draggedImprovement.row},${draggedImprovement.col}`;
                    const targetKey = `${row},${col}`;
                    
                    // If dropping on the same hex, do nothing and clear the dragged state
                    if (sourceKey === targetKey) {
                        // Dropped back on original location - restore opacity first, then clear
                        const draggedImg = document.querySelector(`.hex-improvement[data-row="${draggedImprovement.row}"][data-col="${draggedImprovement.col}"]`);
                        if (draggedImg) {
                            draggedImg.style.opacity = '1';
                            draggedImg.style.cursor = 'grab';
                        }
                        // Clear immediately to prevent map container drop handler from deleting it
                        draggedImprovement = null;
                        e.stopPropagation(); // Prevent event from bubbling to map container
                        return; // Exit early, don't process further
                    } else {
                        const tile = challengeData.tiles[targetKey];
                        const improvementName = draggedImprovement.name;
                        
                        // Check if valid placement
                        if (isValidPlacement(row, col, 'improvement', improvementName, tile)) {
                            // Remove from old location (this adds it back to availableItems)
                            const oldKey = `${draggedImprovement.row},${draggedImprovement.col}`;
                            delete placedItems[oldKey];
                            availableItems[improvementName] = (availableItems[improvementName] || 0) + 1;
                            
                            // Place at new location (subtract from availableItems to keep count correct)
                            const key = `${row},${col}`;
                            // Remove any existing item at this location
                            if (placedItems[key]) {
                                const oldItem = placedItems[key];
                                availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
                            }
                            placedItems[key] = { type: 'improvement', name: improvementName };
                            availableItems[improvementName] = (availableItems[improvementName] || 0) - 1;
                            
                            // Update visuals for old location and its neighbors (to update adjacent district adjacencies)
                            updateHexVisual(draggedImprovement.row, draggedImprovement.col);
                            const oldNeighbors = getNeighbors(draggedImprovement.row, draggedImprovement.col);
                            oldNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            // Update visuals for new location and its neighbors (to update adjacent district adjacencies)
                            updateHexVisual(row, col);
                            const newNeighbors = getNeighbors(row, col);
                            newNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            updateAllScores();
                            populateSidebar();
                            // Clear draggedImprovement on successful move
                            draggedImprovement = null;
                        } else {
                            // Invalid placement - improvement stays in original location
                            // draggedImprovement will be cleared in dragend
                        }
                    }
                }
            });

            // Right-click to remove item
            hex.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                removeItem(row, col);
            });

            return hex;
        }

        function updateHexVisualBase(row, col) {
            const hexGrid = document.getElementById('hexGrid');
            if (!hexGrid) return;
            const hex = hexGrid.querySelector(`.hex[data-row="${row}"][data-col="${col}"]`);
            if (!hex) return;

            const hexShape = hex.querySelector('.hex-shape');
            if (!hexShape) return;

            // Remove existing images
            hexShape.querySelectorAll('img').forEach(el => el.remove());
            hexShape.querySelectorAll('.adjacency-indicator').forEach(el => el.remove());

            const key = `${row},${col}`;
            const tile = challengeData.tiles[key];
            const placed = placedItems[key];

            // Always add Blank.webp as base
            const blankImg = document.createElement('img');
            blankImg.className = 'hex-base';
            blankImg.src = 'assets/terrain/base/other/Blank.webp';
            blankImg.alt = 'Blank';
            blankImg.draggable = false;
            hexShape.appendChild(blankImg);

            if (tile) {
                if (tile.terrainPath) {
                    blankImg.src = tile.terrainPath;
                    blankImg.alt = tile.terrain;
                }
                if (tile.featurePath) {
                    const img = document.createElement('img');
                    img.className = 'hex-feature';
                    img.src = tile.featurePath;
                    img.alt = tile.feature;
                    img.draggable = false;
                    hexShape.appendChild(img);
                }
                if (tile.resourcePath) {
                    const img = document.createElement('img');
                    img.className = 'hex-resource';
                    img.src = tile.resourcePath;
                    img.alt = tile.resource;
                    img.draggable = false;
                    hexShape.appendChild(img);
                }
                
                // Draw river edges
                if (tile.rivers) {
                    const riversContainer = hex.querySelector('.hex-rivers');
                    if (riversContainer) {
                        riversContainer.innerHTML = '';
                        for (let edge = 0; edge < 6; edge++) {
                            if (tile.rivers[edge] === true) {
                                const imageName = riverEdgeImages[edge];
                                if (imageName) {
                                    const img = document.createElement('img');
                                    img.className = 'river-edge-image';
                                    img.src = `assets/terrain/river_edges/${imageName}.png`;
                                    img.alt = `River edge ${edge}`;
                                    img.style.zIndex = (21 + edge);
                                    img.draggable = false;
                                    riversContainer.appendChild(img);
                                }
                            }
                        }
                    }
                }
            }

            // Add placed items (but NOT districts yet - they go last)
            if (placed) {
                if (placed.type === 'improvement') {
                    const img = document.createElement('img');
                    img.className = 'hex-improvement';
                    // If tile has a resource, add class to position improvement higher
                    if (tile && tile.resource) {
                        img.classList.add('has-resource');
                    }
                    img.src = `assets/improvements/${placed.name}.webp`;
                    img.alt = placed.name;
                    img.draggable = true;
                    img.dataset.row = row;
                    img.dataset.col = col;
                    img.style.pointerEvents = 'auto';
                    img.style.cursor = 'grab';
                    
                    img.addEventListener('dragstart', (e) => {
                        e.stopPropagation();
                        draggedImprovement = { row, col, name: placed.name };
                        
                        // Make the image semi-transparent while dragging
                        img.style.opacity = '0.5';
                        img.style.cursor = 'grabbing';
                        
                        // Create a custom drag image (opaque version)
                        const dragImg = document.createElement('img');
                        dragImg.src = img.src;
                        dragImg.style.width = '64px';
                        dragImg.style.height = '64px';
                        dragImg.style.position = 'absolute';
                        dragImg.style.top = '-1000px';
                        dragImg.style.opacity = '1';
                        document.body.appendChild(dragImg);
                        
                        // Set drag image - use the center of the 64x64 image
                        if (dragImg.complete && dragImg.naturalWidth > 0) {
                            e.dataTransfer.setDragImage(dragImg, 32, 32);
                            setTimeout(() => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            }, 0);
                        } else {
                            dragImg.onload = () => {
                                e.dataTransfer.setDragImage(dragImg, 32, 32);
                                setTimeout(() => {
                                    if (dragImg.parentNode) {
                                        document.body.removeChild(dragImg);
                                    }
                                }, 0);
                            };
                            dragImg.onerror = () => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            };
                        }
                        
                        e.dataTransfer.effectAllowed = 'move';
                        // Show red/green highlights just like dragging from sidebar
                        // Skip availability check since we're moving an already-placed improvement
                        highlightAllTiles('improvement', placed.name, true);
                    });
                    
                    img.addEventListener('dragend', (e) => {
                        e.stopPropagation();
                        
                        // Clear all highlights
                        clearAllHighlights();
                        
                        // Restore opacity if improvement wasn't moved (drop failed or cancelled)
                        if (draggedImprovement) {
                            const draggedImg = document.querySelector(`.hex-improvement[data-row="${draggedImprovement.row}"][data-col="${draggedImprovement.col}"]`);
                            if (draggedImg) {
                                draggedImg.style.opacity = '1';
                                draggedImg.style.cursor = 'grab';
                            }
                            // Clear if not already cleared by successful drop
                            setTimeout(() => {
                                if (draggedImprovement) {
                                    draggedImprovement = null;
                                }
                            }, 100);
                        }
                    });
                    
                    hexShape.appendChild(img);
                } else if (placed.type === 'wonder') {
                    const img = document.createElement('img');
                    img.className = 'hex-wonder';
                    img.src = `assets/wonders/${placed.name}.webp`;
                    img.alt = placed.name;
                    img.draggable = false;
                    hexShape.appendChild(img);
                }
            }
        }

        function updateHexVisualDistricts(row, col) {
            // Render districts in the separate districts layer
            const districtShape = document.getElementById(`district-shape-${row}-${col}`);
            if (!districtShape) return;

            // Clear existing content
            districtShape.innerHTML = '';

            const key = `${row},${col}`;
            const placed = placedItems[key];

            // Add districts LAST so they appear on top of everything
            if (placed && placed.type === 'district') {
                const img = document.createElement('img');
                img.className = 'hex-district';
                img.src = `assets/districts/${placed.name}.webp`;
                img.alt = placed.name;
                img.draggable = true;
                img.dataset.row = row;
                img.dataset.col = col;
                img.style.pointerEvents = 'auto'; // Allow drag events
                
                // Add drag handlers for districts
                img.addEventListener('dragstart', (e) => {
                    draggedDistrict = { row, col, name: placed.name };
                    img.style.opacity = '0.5';
                    img.style.cursor = 'grabbing';
                    e.stopPropagation(); // Prevent event from bubbling
                    
                    // Create a custom drag image with an opaque version of the district
                    const dragImg = new Image();
                    dragImg.src = `assets/districts/${placed.name}.webp`;
                    dragImg.style.width = '64px';
                    dragImg.style.height = '64px';
                    dragImg.style.opacity = '1';
                    dragImg.style.position = 'fixed';
                    dragImg.style.left = '-1000px';
                    dragImg.style.top = '-1000px';
                    dragImg.style.pointerEvents = 'none';
                    document.body.appendChild(dragImg);
                    
                    // Set drag image - use the center of the 64x64 image
                    if (dragImg.complete && dragImg.naturalWidth > 0) {
                        e.dataTransfer.setDragImage(dragImg, 32, 32);
                        setTimeout(() => {
                            if (dragImg.parentNode) {
                                document.body.removeChild(dragImg);
                            }
                        }, 0);
                    } else {
                        dragImg.onload = () => {
                            e.dataTransfer.setDragImage(dragImg, 32, 32);
                            setTimeout(() => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            }, 0);
                        };
                        dragImg.onerror = () => {
                            if (dragImg.parentNode) {
                                document.body.removeChild(dragImg);
                            }
                        };
                    }
                    
                    e.dataTransfer.effectAllowed = 'move';
                    // Show red/green highlights just like dragging from sidebar
                    // Skip availability check since we're moving an already-placed district
                    // Exclude the old location from adjacency calculations
                    highlightAllTiles('district', placed.name, true, { row, col });
                });
                
                img.addEventListener('dragend', (e) => {
                    e.stopPropagation();
                    
                    // Clear all highlights
                    clearAllHighlights();
                    
                    // Restore opacity if district wasn't moved (drop failed or cancelled)
                    if (draggedDistrict) {
                        const draggedImg = document.querySelector(`.hex-district[data-row="${draggedDistrict.row}"][data-col="${draggedDistrict.col}"]`);
                        if (draggedImg) {
                            draggedImg.style.opacity = '1';
                            draggedImg.style.cursor = 'grab';
                        }
                        // Clear if not already cleared by successful drop
                        setTimeout(() => {
                            if (draggedDistrict) {
                                draggedDistrict = null;
                            }
                        }, 100);
                    }
                });
                
                districtShape.appendChild(img);
                
                // Add adjacency indicator for districts with yield icons
                const adjacency = calculateAdjacency(row, col);
                if (adjacency && adjacency.total > 0) {
                    const indicator = document.createElement('div');
                    indicator.className = 'adjacency-indicator';
                    
                    // Add yield badges for each yield type that has a bonus
                    const yieldTypes = [
                        { name: 'Science', value: adjacency.science, icon: 'assets/yields/Science.webp' },
                        { name: 'Faith', value: adjacency.faith, icon: 'assets/yields/Faith.webp' },
                        { name: 'Gold', value: adjacency.gold, icon: 'assets/yields/Gold.webp' },
                        { name: 'Production', value: adjacency.production, icon: 'assets/yields/Production.webp' },
                        { name: 'Culture', value: adjacency.culture, icon: 'assets/yields/Culture.webp' }
                    ];
                    
                    yieldTypes.forEach(yieldType => {
                        if (yieldType.value > 0) {
                            const badge = document.createElement('div');
                            badge.className = 'yield-badge';
                            
                            const amount = document.createElement('span');
                            amount.className = 'yield-amount';
                            amount.textContent = `+${yieldType.value}`;
                            
                            const icon = document.createElement('img');
                            icon.className = 'yield-icon';
                            icon.src = yieldType.icon;
                            icon.alt = yieldType.name;
                            icon.draggable = false;
                            
                            badge.appendChild(amount);
                            badge.appendChild(icon);
                            indicator.appendChild(badge);
                        }
                    });
                    
                    districtShape.appendChild(indicator);
                }
            }
        }

        function updateHexVisual(row, col) {
            updateHexVisualBase(row, col);
            updateHexVisualDistricts(row, col);
        }

        function populateSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.innerHTML = '';
            
            // If no challenge is loaded, show upload prompt
            if (!challengeData || Object.keys(availableItems).length === 0) {
                sidebar.innerHTML = `
                    <div class="empty-state">
                        <h2>Upload Challenge</h2>
                        <p>Please upload a challenge file to begin playing.</p>
                        <input type="file" id="challengeFileInput" accept=".civle" style="display: none;" onchange="loadChallenge(event)">
                        <button class="submit-score-btn" onclick="document.getElementById('challengeFileInput').click()" style="margin-top: 20px; width: 100%;">Upload Challenge File</button>
                    </div>
                `;
                return;
            }
            
            sidebar.innerHTML = '<h2>Available Items</h2>';
            
            // Districts
            const districtsSection = document.createElement('div');
            districtsSection.innerHTML = '<h3 style="margin-top: 15px; margin-bottom: 10px; color: #4a90e2; font-size: 16px;">Districts</h3>';
            
            Object.keys(availableItems).forEach(name => {
                const itemData = placementData.districts.find(d => d.name === name);
                if (itemData) {
                    const item = createAvailableItem(name, 'district', availableItems[name]);
                    districtsSection.appendChild(item);
                }
            });
            
            sidebar.appendChild(districtsSection);
            
            // Improvements
            const improvementsSection = document.createElement('div');
            let hasImprovements = false;
            
            Object.keys(availableItems).forEach(name => {
                const itemData = placementData.improvements.find(i => i.name === name);
                if (itemData) {
                    if (!hasImprovements) {
                        improvementsSection.innerHTML = '<h3 style="margin-top: 15px; margin-bottom: 10px; color: #4a90e2; font-size: 16px;">Improvements</h3>';
                        hasImprovements = true;
                    }
                    const item = createAvailableItem(name, 'improvement', availableItems[name]);
                    improvementsSection.appendChild(item);
                }
            });
            
            if (hasImprovements) {
            sidebar.appendChild(improvementsSection);
            }
            
            // Wonders
            const wondersSection = document.createElement('div');
            let hasWonders = false;
            
            Object.keys(availableItems).forEach(name => {
                const itemData = placementData.wonders.find(w => w.name === name);
                if (itemData) {
                    if (!hasWonders) {
                        wondersSection.innerHTML = '<h3 style="margin-top: 15px; margin-bottom: 10px; color: #4a90e2; font-size: 16px;">Wonders</h3>';
                        hasWonders = true;
                    }
                    const item = createAvailableItem(name, 'wonder', availableItems[name]);
                    wondersSection.appendChild(item);
                }
            });
            
            if (hasWonders) {
            sidebar.appendChild(wondersSection);
            }
        }

        function formatPlacementRequirements(itemData, type) {
            if (!itemData) return '';
            
            let html = `<h4>${itemData.name.replace(/_/g, ' ')}</h4>`;
            
            // Only show description if available
            if (itemData.description) {
                // Convert markdown-style bold (**text**) to HTML
                let description = itemData.description
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>');
                html += `<div class="requirement-section"><span class="requirement-value">${description}</span></div>`;
            }
            
            // For districts, show adjacency bonuses
            if (type === 'district' && adjacencyData) {
                const districtBonus = adjacencyData.district_adjacency_bonuses.find(d => d.name === itemData.name);
                if (districtBonus && districtBonus.adjacency_bonuses) {
                    html += `<div class="requirement-section" style="margin-top: 12px;"><strong>Adjacency Bonuses:</strong><ul style="margin: 8px 0 0 0; padding-left: 20px; list-style-type: disc;">`;
                    Object.entries(districtBonus.adjacency_bonuses).forEach(([source, bonus]) => {
                        const yieldType = bonus.type;
                        const yieldIcon = `assets/yields/${yieldType}.webp`;
                        const perText = bonus.per > 1 ? ` (per ${bonus.per})` : '';
                        html += `<li style="margin-bottom: 4px;"><img src="${yieldIcon}" alt="${yieldType}" class="yield-icon" style="width: 16px; height: 16px; vertical-align: middle; margin-right: 4px;">+${bonus.bonus} ${yieldType} from ${source.replace(/_/g, ' ')}${perText}</li>`;
                    });
                    html += `</ul></div>`;
                }
            }
            
            // For improvements with only_buildable_on_resources: true, show resource images
            if (type === 'improvement' && itemData.only_buildable_on_resources && itemData.resources_its_built_on && itemData.resources_its_built_on.length > 0) {
                html += `<div class="requirement-section resource-images">`;
                itemData.resources_its_built_on.forEach(resource => {
                    html += `<img src="assets/recources/${resource}.webp" alt="${resource}" class="resource-tooltip-icon" title="${resource}">`;
                });
                html += `</div>`;
            }
            
            return html;
        }

        function createAvailableItem(name, type, count) {
            const item = document.createElement('div');
            item.className = 'available-item';
            item.draggable = count > 0;
            item.dataset.name = name;
            item.dataset.type = type;
            
            if (count === 0) {
                item.style.opacity = '0.5';
                item.style.cursor = 'not-allowed';
            }
            
            let imgPath = '';
            if (type === 'district') {
                imgPath = `assets/districts/${name}.webp`;
            } else if (type === 'improvement') {
                imgPath = `assets/improvements/${name}.webp`;
            } else if (type === 'wonder') {
                imgPath = `assets/wonders/${name}.webp`;
            }
            
            const img = document.createElement('img');
            img.src = imgPath;
            img.alt = name;
            img.draggable = false;
            img.onerror = () => { img.style.display = 'none'; };
            
            const span = document.createElement('span');
            span.textContent = name.replace(/_/g, ' ');
            
            const countSpan = document.createElement('span');
            countSpan.className = 'count' + (count === 0 ? ' zero' : '');
            countSpan.textContent = `x${count}`;
            
            item.appendChild(img);
            item.appendChild(span);
            item.appendChild(countSpan);
            
            // Add tooltip for placement requirements
            let tooltip = null;
            item.addEventListener('mouseenter', (e) => {
                if (!placementData) return;
                
                let itemData = null;
                if (type === 'district') {
                    itemData = placementData.districts.find(d => d.name === name);
                } else if (type === 'improvement') {
                    itemData = placementData.improvements.find(i => i.name === name);
                } else if (type === 'wonder') {
                    itemData = placementData.wonders.find(w => w.name === name);
                }
                
                if (!itemData) return;
                
                tooltip = document.createElement('div');
                tooltip.className = 'placement-tooltip';
                tooltip.innerHTML = formatPlacementRequirements(itemData, type);
                document.body.appendChild(tooltip);
                
                // Position tooltip
                const rect = item.getBoundingClientRect();
                tooltip.style.left = (rect.right + 10) + 'px';
                tooltip.style.top = (rect.top + window.scrollY) + 'px';
                
                // Adjust if tooltip goes off screen
                setTimeout(() => {
                    if (tooltip) {
                        const tooltipRect = tooltip.getBoundingClientRect();
                        if (tooltipRect.right > window.innerWidth) {
                            tooltip.style.left = (rect.left - tooltipRect.width - 10) + 'px';
                        }
                        if (tooltipRect.bottom > window.innerHeight) {
                            tooltip.style.top = (window.innerHeight - tooltipRect.height - 10) + 'px';
                        }
                    }
                }, 0);
            });
            
            item.addEventListener('mouseleave', () => {
                if (tooltip) {
                    tooltip.remove();
                    tooltip = null;
                }
            });
            
            item.addEventListener('dragstart', (e) => {
                // Hide tooltip when dragging starts
                if (tooltip) {
                    tooltip.remove();
                    tooltip = null;
                }
                
                if (count > 0) {
                    draggedItem = { type, name };
                    item.classList.add('dragging');
                    
                    // Create a custom drag image with the district/improvement icon
                    // Use the existing image from the sidebar item, but create a larger version
                    const dragImg = new Image();
                    dragImg.src = imgPath;
                    dragImg.style.width = '64px';
                    dragImg.style.height = '64px';
                    dragImg.style.opacity = '1';
                    dragImg.style.position = 'fixed';
                    dragImg.style.left = '-1000px';
                    dragImg.style.top = '-1000px';
                    dragImg.style.pointerEvents = 'none';
                    document.body.appendChild(dragImg);
                    
                    // Set drag image - use the center of the 64x64 image
                    if (dragImg.complete && dragImg.naturalWidth > 0) {
                        e.dataTransfer.setDragImage(dragImg, 32, 32);
                        setTimeout(() => {
                            if (dragImg.parentNode) {
                                document.body.removeChild(dragImg);
                            }
                        }, 0);
                    } else {
                        dragImg.onload = () => {
                            e.dataTransfer.setDragImage(dragImg, 32, 32);
                            setTimeout(() => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            }, 0);
                        };
                        dragImg.onerror = () => {
                            if (dragImg.parentNode) {
                                document.body.removeChild(dragImg);
                            }
                        };
                    }
                    
                    // Highlight all tiles based on placement validity
                    highlightAllTiles(type, name);
                } else {
                    e.preventDefault();
                }
            });
            
            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                draggedItem = null;
                
                // Remove all highlights
                clearAllHighlights();
            });
            
            return item;
        }

        function placeItem(row, col, type, name) {
            const key = `${row},${col}`;
            const tile = challengeData.tiles[key];
            
            // Check if placement is valid
            if (!isValidPlacement(row, col, type, name, tile)) {
                return;
            }
            
            // Check if item is available
            if (availableItems[name] <= 0) {
                return;
            }
            
            // Remove any existing item at this location
            if (placedItems[key]) {
                const oldItem = placedItems[key];
                availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
            }
            
            // Place new item
            placedItems[key] = { type, name };
            
            // Assign district to a City_Center if it's a district (except City_Center itself)
            // Uses ambiguous ownership if multiple city centers are valid
            if (type === 'district' && name !== 'City_Center') {
                assignDistrictOwnership(key, row, col, name);
            }
            
            availableItems[name] = (availableItems[name] || 0) - 1;
            
            // Update visuals for this hex and all neighbors (for adjacency indicators)
            updateHexVisual(row, col);
            const neighbors = getNeighbors(row, col);
            neighbors.forEach(neighbor => {
                updateHexVisual(neighbor.row, neighbor.col);
            });
            updateAllScores();
            populateSidebar();
        }

        function removeItem(row, col) {
            const key = `${row},${col}`;
            if (!placedItems[key]) return;
            
            const oldItem = placedItems[key];
            delete placedItems[key];
            availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
            
            // Update visuals for this hex and all neighbors
            updateHexVisual(row, col);
            const neighbors = getNeighbors(row, col);
            neighbors.forEach(neighbor => {
                updateHexVisual(neighbor.row, neighbor.col);
            });
            updateAllScores();
            populateSidebar();
        }

        function isValidPlacement(row, col, type, name, tile, excludeLocation = null) {
            if (!tile || !tile.terrain) return false;
            
            let itemData = null;
            if (type === 'district') {
                itemData = placementData.districts.find(d => d.name === name);
            } else if (type === 'improvement') {
                itemData = placementData.improvements.find(i => i.name === name);
            } else if (type === 'wonder') {
                itemData = placementData.wonders.find(w => w.name === name);
            }
            
            if (!itemData) return false;
            
            // Check terrain
            if (itemData.allowed_terrain && !itemData.allowed_terrain.includes(tile.terrain)) {
                return false;
            }
            
            // Check city center adjacency rules for districts
            if (type === 'district') {
                // City centers must be at least 3 tiles apart
                if (name === 'City_Center') {
                    for (const [key, placed] of Object.entries(placedItems)) {
                        if (placed.type === 'district' && placed.name === 'City_Center') {
                            const [existingRow, existingCol] = key.split(',').map(Number);
                            // Skip if this is the same location or the excluded location (when moving)
                            if ((existingRow === row && existingCol === col) || 
                                (excludeLocation && existingRow === excludeLocation.row && existingCol === excludeLocation.col)) {
                                continue;
                            }
                            const distance = getHexDistance(row, col, existingRow, existingCol);
                            if (distance <= 3) {
                                return false;
                            }
                        }
                    }
                }
                
                // Special placement rules for Aqueduct
                if (name === 'Aqueduct') {
                    const neighbors = getNeighbors(row, col);
                    let hasAdjacentCityCenter = false;
                    let adjacentCityCenterKey = null;
                    let hasAdjacentMountainOrCoast = false;
                    
                    // Check neighbors for city center and mountain/coast
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborPlaced = placedItems[neighborKey];
                        const neighborTile = challengeData.tiles[neighborKey];
                        
                        // Skip if this is the excluded location (when moving)
                        if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                            continue;
                        }
                        
                        // Check for adjacent city center
                        if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'City_Center') {
                            hasAdjacentCityCenter = true;
                            adjacentCityCenterKey = neighborKey;
                        }
                        
                        // Check for adjacent mountain or coast
                        if (neighborTile) {
                            if (neighborTile.terrain && (neighborTile.terrain.includes('Mountain') || 
                                neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                                hasAdjacentMountainOrCoast = true;
                            }
                        }
                    }
                    
                    // Rule 1: Must have adjacent city center AND adjacent mountain/coast
                    if (hasAdjacentCityCenter && hasAdjacentMountainOrCoast) {
                        // Valid placement
                    } else if (hasAdjacentCityCenter) {
                        // Rule 2: Check if the aqueduct tile has any river edges
                        // (other than the river edge that would lead to the city center)
                        if (adjacentCityCenterKey && tile && tile.rivers) {
                            const [cityRow, cityCol] = adjacentCityCenterKey.split(',').map(Number);
                            
                            // Determine which edge of the aqueduct hex connects to the city center
                            // Based on map_maker.html getNeighborForEdge logic
                            // Edge mapping: 0=Top-right, 1=Right, 2=Bottom-right, 3=Bottom-left, 4=Left, 5=Top-left
                            const isOddRow = row % 2 === 1;
                            let cityCenterEdgeIndex = -1;
                            
                            // Determine edge based on relative position (reverse of getNeighborForEdge)
                            const dr = cityRow - row;
                            const dc = cityCol - col;
                            
                            if (isOddRow) {
                                // Odd row
                                if (dr === -1 && dc === 1) cityCenterEdgeIndex = 0; // Top-right -> connects to (row-1, col+1)
                                else if (dr === 0 && dc === 1) cityCenterEdgeIndex = 1; // Right -> connects to (row, col+1)
                                else if (dr === 1 && dc === 1) cityCenterEdgeIndex = 2; // Bottom-right -> connects to (row+1, col+1)
                                else if (dr === 1 && dc === 0) cityCenterEdgeIndex = 3; // Bottom-left -> connects to (row+1, col)
                                else if (dr === 0 && dc === -1) cityCenterEdgeIndex = 4; // Left -> connects to (row, col-1)
                                else if (dr === -1 && dc === 0) cityCenterEdgeIndex = 5; // Top-left -> connects to (row-1, col)
                            } else {
                                // Even row
                                if (dr === -1 && dc === 0) cityCenterEdgeIndex = 0; // Top-right -> connects to (row-1, col)
                                else if (dr === 0 && dc === 1) cityCenterEdgeIndex = 1; // Right -> connects to (row, col+1)
                                else if (dr === 1 && dc === 0) cityCenterEdgeIndex = 2; // Bottom-right -> connects to (row+1, col)
                                else if (dr === 1 && dc === -1) cityCenterEdgeIndex = 3; // Bottom-left -> connects to (row+1, col-1)
                                else if (dr === 0 && dc === -1) cityCenterEdgeIndex = 4; // Left -> connects to (row, col-1)
                                else if (dr === -1 && dc === -1) cityCenterEdgeIndex = 5; // Top-left -> connects to (row-1, col-1)
                            }
                            
                            // Check if aqueduct tile has any river edges other than the one connecting to city center
                            let hasOtherRiverEdge = false;
                            if (cityCenterEdgeIndex >= 0) {
                                for (let i = 0; i < 6; i++) {
                                    if (tile.rivers[i] && i !== cityCenterEdgeIndex) {
                                        hasOtherRiverEdge = true;
                                        break;
                                    }
                                }
                            } else {
                                // If we couldn't determine the edge, check if there are any river edges at all
                                for (let i = 0; i < 6; i++) {
                                    if (tile.rivers[i]) {
                                        hasOtherRiverEdge = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (!hasOtherRiverEdge) {
                                return false;
                            }
                            // Valid placement if hasOtherRiverEdge is true
                        } else {
                            return false;
                        }
                    } else {
                        // No adjacent city center - invalid
                        return false;
                    }
                }
                
                // Special placement rules for Canal
                if (name === 'Canal') {
                    const neighbors = getNeighbors(row, col);
                    let hasAdjacentWater = false;
                    let validPlacement = false;
                    
                    // Check all neighbors for water tiles
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        
                        // Skip if this is the excluded location (when moving)
                        if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                            continue;
                        }
                        
                        // Check if neighbor is a water tile
                        if (neighborTile && neighborTile.terrain && 
                            (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                            hasAdjacentWater = true;
                            
                            // Calculate the direction from canal to this water tile
                            const dr = neighbor.row - row;
                            const dc = neighbor.col - col;
                            const isOddRow = row % 2 === 1;
                            
                            // Determine direction index (0-5) based on relative position
                            // Directions: 0=Right, 1=Top-right, 2=Top-left, 3=Left, 4=Bottom-left, 5=Bottom-right
                            let directionIndex = -1;
                            
                            if (isOddRow) {
                                if (dr === 0 && dc === 1) directionIndex = 0; // Right
                                else if (dr === -1 && dc === 1) directionIndex = 1; // Top-right
                                else if (dr === -1 && dc === 0) directionIndex = 2; // Top-left
                                else if (dr === 0 && dc === -1) directionIndex = 3; // Left
                                else if (dr === 1 && dc === 0) directionIndex = 4; // Bottom-left
                                else if (dr === 1 && dc === 1) directionIndex = 5; // Bottom-right
                            } else {
                                if (dr === 0 && dc === 1) directionIndex = 0; // Right
                                else if (dr === -1 && dc === 0) directionIndex = 1; // Top-right
                                else if (dr === -1 && dc === -1) directionIndex = 2; // Top-left
                                else if (dr === 0 && dc === -1) directionIndex = 3; // Left
                                else if (dr === 1 && dc === -1) directionIndex = 4; // Bottom-left
                                else if (dr === 1 && dc === 0) directionIndex = 5; // Bottom-right
                            }
                            
                            // If we found the direction, check the opposite 3 tiles
                            if (directionIndex >= 0) {
                                // Opposite 3 tiles are at directions (i+2) mod 6, (i+3) mod 6, (i+4) mod 6
                                const oppositeDirections = [
                                    (directionIndex + 2) % 6,
                                    (directionIndex + 3) % 6,
                                    (directionIndex + 4) % 6
                                ];
                                
                                // Check each opposite direction for water tile or city center
                                for (const oppDir of oppositeDirections) {
                                    const oppNeighbor = getNeighborAtDirection(row, col, oppDir);
                                    if (oppNeighbor) {
                                        const oppKey = `${oppNeighbor.row},${oppNeighbor.col}`;
                                        const oppTile = challengeData.tiles[oppKey];
                                        const oppPlaced = placedItems[oppKey];
                                        
                                        // Skip if this is the excluded location (when moving)
                                        if (excludeLocation && oppNeighbor.row === excludeLocation.row && oppNeighbor.col === excludeLocation.col) {
                                            continue;
                                        }
                                        
                                        // Check if opposite tile has water or city center
                                        if (oppTile && oppTile.terrain && 
                                            (oppTile.terrain === 'Coast' || oppTile.terrain === 'Ocean' || oppTile.terrain === 'Reef')) {
                                            validPlacement = true;
                                            break;
                                        }
                                        if (oppPlaced && oppPlaced.type === 'district' && oppPlaced.name === 'City_Center') {
                                            validPlacement = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            
                            // If we found a valid placement for this water tile, we can break
                            if (validPlacement) break;
                        }
                    }
                    
                    // Canal must be adjacent to water AND have valid opposite tile
                    if (!hasAdjacentWater || !validPlacement) {
                        return false;
                    }
                }
                
                if (itemData.must_be_adjacent_to_city_center && !hasCityCenterAdjacent(row, col)) {
                    return false;
                }
                if (itemData.cant_be_adjacent_to_city_center && hasCityCenterAdjacent(row, col)) {
                    return false;
                }
                
                // Districts cannot be built on strategic or luxury resources (except City_Center)
                if (name !== 'City_Center' && tile.resource && resourcesData) {
                    const isStrategic = resourcesData.strategic_resources.some(r => r.name === tile.resource);
                    const isLuxury = resourcesData.luxury_resources.some(r => r.name === tile.resource);
                    if (isStrategic || isLuxury) {
                        return false;
                    }
                }
                
                // Districts cannot be built on geothermal fissures
                if (tile.feature === 'Geothermal_Fissure') {
                    return false;
                }
                
                // Hard check: No city center can have multiple districts of the same type in its first ring (adjacent tiles)
                if (name !== 'City_Center') {
                    // Check if this tile is adjacent to any City_Center
                    const neighbors = getNeighbors(row, col);
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborPlaced = placedItems[neighborKey];
                        
                        // Skip if this is the excluded location (when moving)
                        if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                            continue;
                        }
                        
                        // If neighbor is a City_Center, check its first ring for duplicate district types
                        if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'City_Center') {
                            const cityCenterNeighbors = getNeighbors(neighbor.row, neighbor.col);
                            for (const cityNeighbor of cityCenterNeighbors) {
                                const cityNeighborKey = `${cityNeighbor.row},${cityNeighbor.col}`;
                                const cityNeighborPlaced = placedItems[cityNeighborKey];
                                
                                // Skip the current location being checked
                                if (cityNeighbor.row === row && cityNeighbor.col === col) {
                                    continue;
                                }
                                
                                // Skip if this is the excluded location (when moving)
                                if (excludeLocation && cityNeighbor.row === excludeLocation.row && cityNeighbor.col === excludeLocation.col) {
                                    continue;
                                }
                                
                                // If there's already a district of the same type in the first ring, prevent placement
                                if (cityNeighborPlaced && 
                                    cityNeighborPlaced.type === 'district' && 
                                    cityNeighborPlaced.name === name) {
                                    return false;
                                }
                            }
                        }
                    }
                }
                
                // Every district (except City_Center) must be owned by a City_Center within 3 tiles
                // Each City_Center can only own one of each district type
                // A City_Center cannot own a district that is in another City_Center's first ring
                if (name !== 'City_Center') {
                    let foundAvailableCityCenter = false;
                    
                    // First, check if this district is in any City_Center's first ring (adjacent)
                    const neighbors = getNeighbors(row, col);
                    let adjacentCityCenter = null;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborPlaced = placedItems[neighborKey];
                        
                        // Skip if this is the excluded location (when moving)
                        if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                            continue;
                        }
                        
                        if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'City_Center') {
                            adjacentCityCenter = neighborKey;
                            break;
                        }
                    }
                    
                    // If district is adjacent to a City_Center, it must be owned by that City_Center
                    if (adjacentCityCenter) {
                        // Check if that City_Center already owns a district of this type
                        // Consider ambiguous owners - if a district has ambiguous owners, we can still place
                        let alreadyOwns = false;
                        for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                            if (districtPlaced.type !== 'district' || districtPlaced.name !== name) continue;
                            
                            // Skip if this is the district being moved (same location)
                            const [districtRow, districtCol] = districtKey.split(',').map(Number);
                            if (excludeLocation && 
                                districtRow === excludeLocation.row && 
                                districtCol === excludeLocation.col) {
                                continue;
                            }
                            
                            // Check if this district is owned by (or could be owned by) this city center
                            if (Array.isArray(districtPlaced.owner)) {
                                // Ambiguous owner - if this city is the only owner, it's taken
                                if (districtPlaced.owner.length === 1 && districtPlaced.owner[0] === adjacentCityCenter) {
                                    alreadyOwns = true;
                                    break;
                                }
                                // If ambiguous with multiple owners, we can still place (allows swapping)
                            } else if (districtPlaced.owner === adjacentCityCenter) {
                                // Direct owner - city center already owns this type
                                alreadyOwns = true;
                                break;
                            }
                        }
                        
                        if (!alreadyOwns) {
                            foundAvailableCityCenter = true;
                        }
                    } else {
                        // District is not adjacent to any City_Center, find any City_Center within 3 tiles
                        // But exclude City_Centers that have this district in their first ring
                        for (const [cityKey, cityPlaced] of Object.entries(placedItems)) {
                            if (cityPlaced.type === 'district' && cityPlaced.name === 'City_Center') {
                                const [cityRow, cityCol] = cityKey.split(',').map(Number);
                                // Skip if this is the same location or excluded location (when moving)
                                if ((cityRow === row && cityCol === col) ||
                                    (excludeLocation && cityRow === excludeLocation.row && cityCol === excludeLocation.col)) {
                                    continue;
                                }
                                
                                // Check if this district is in another City_Center's first ring
                                const cityNeighbors = getNeighbors(cityRow, cityCol);
                                let isInAnotherCityFirstRing = false;
                                for (const cityNeighbor of cityNeighbors) {
                                    if (cityNeighbor.row === row && cityNeighbor.col === col) {
                                        // This district is in this City_Center's first ring
                                        // But we're checking a different City_Center, so this is invalid
                                        isInAnotherCityFirstRing = true;
                                        break;
                                    }
                                }
                                
                                if (isInAnotherCityFirstRing) {
                                    continue; // Skip this City_Center - it can't own a district in another City_Center's first ring
                                }
                                
                                const distance = getHexDistance(row, col, cityRow, cityCol);
                                if (distance <= 3) {
                                    // Check if this City_Center already owns a district of this type
                                    // Consider ambiguous owners - if a district has ambiguous owners, we can still place
                                    let alreadyOwns = false;
                                    for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                                        if (districtPlaced.type !== 'district' || districtPlaced.name !== name) continue;
                                        
                                        // Skip if this is the district being moved (same location)
                                        const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                        if (excludeLocation && 
                                            districtRow === excludeLocation.row && 
                                            districtCol === excludeLocation.col) {
                                            continue;
                                        }
                                        
                                        // Check if this district is owned by (or could be owned by) this city center
                                        if (Array.isArray(districtPlaced.owner)) {
                                            // Ambiguous owner - if this city is the only owner, it's taken
                                            if (districtPlaced.owner.length === 1 && districtPlaced.owner[0] === cityKey) {
                                                alreadyOwns = true;
                                                break;
                                            }
                                            // If ambiguous with multiple owners, we can still place (allows swapping)
                                        } else if (districtPlaced.owner === cityKey) {
                                            // Direct owner - city center already owns this type
                                            alreadyOwns = true;
                                            break;
                                        }
                                    }
                                    
                                    if (!alreadyOwns) {
                                        foundAvailableCityCenter = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    if (!foundAvailableCityCenter) {
                        return false;
                    }
                }
            }
            
            // Check improvement requirements
            if (type === 'improvement') {
                // Check if must be on woods
                if (itemData.must_be_on_woods && tile.feature !== 'Woods') {
                    return false;
                }
                
                // Check if must be coastal
                if (itemData.must_be_coastal) {
                    const neighbors = getNeighbors(row, col);
                    let hasCoast = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        if (neighborTile && (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                            hasCoast = true;
                            break;
                        }
                    }
                    if (!hasCoast) return false;
                }
                
                // Check resource requirements
                if (itemData.only_buildable_on_resources) {
                    if (!tile.resource || !itemData.resources_its_built_on.includes(tile.resource)) {
                        return false;
                    }
                } else if (itemData.resources_its_built_on && itemData.resources_its_built_on.length > 0) {
                    // Can be built on resource or without
                    if (tile.resource && !itemData.resources_its_built_on.includes(tile.resource)) {
                        // If there's a resource on the tile that's not in the list, check if it's a bonus resource
                        // Bonus resources are allowed for improvements with only_buildable_on_resources: false
                        if (resourcesData) {
                            const isBonus = resourcesData.bonus_resources.some(r => r.name === tile.resource);
                            const isStrategic = resourcesData.strategic_resources.some(r => r.name === tile.resource);
                            const isLuxury = resourcesData.luxury_resources.some(r => r.name === tile.resource);
                            
                            // Allow placement if it's a bonus resource
                            // But still block strategic/luxury resources that aren't in the list
                            if (!isBonus && (isStrategic || isLuxury)) {
                                return false;
                            }
                            // If it's a bonus resource, allow placement (don't return false)
                        } else {
                            // If we don't have resources data, use the old behavior
                            return false;
                        }
                    }
                }
            }
            
            // Check wonder requirements
            if (type === 'wonder') {
                // Check allowed features
                if (itemData.allowed_features && itemData.allowed_features.length > 0) {
                    if (!tile.feature || !itemData.allowed_features.includes(tile.feature)) {
                        return false;
                    }
                }
                
                // Check required feature adjacency
                if (itemData.required_feature_adjacency && itemData.required_feature_adjacency.length > 0) {
                    const neighbors = getNeighbors(row, col);
                    let hasRequiredFeature = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        if (neighborTile && itemData.required_feature_adjacency.includes(neighborTile.feature)) {
                            hasRequiredFeature = true;
                            break;
                        }
                    }
                    if (!hasRequiredFeature) return false;
                }
                
                // Check required resource adjacency
                if (itemData.required_resource_adjacency && itemData.required_resource_adjacency.length > 0) {
                    const neighbors = getNeighbors(row, col);
                    let hasRequiredResource = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        if (neighborTile && neighborTile.resource && itemData.required_resource_adjacency.includes(neighborTile.resource)) {
                            hasRequiredResource = true;
                            break;
                        }
                    }
                    if (!hasRequiredResource) return false;
                }
                
                // Check required district adjacency
                if (itemData.required_district_adjacency && itemData.required_district_adjacency.length > 0) {
                    const neighbors = getNeighbors(row, col);
                    let hasRequiredDistrict = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const placed = placedItems[neighborKey];
                        if (placed && placed.type === 'district' && itemData.required_district_adjacency.includes(placed.name)) {
                            hasRequiredDistrict = true;
                            break;
                        }
                    }
                    if (!hasRequiredDistrict) return false;
                }
            }
            
            return true;
        }

        function hasCityCenterAdjacent(row, col) {
            const neighbors = getNeighbors(row, col);
            for (const neighbor of neighbors) {
                const key = `${neighbor.row},${neighbor.col}`;
                const placed = placedItems[key];
                if (placed && placed.type === 'district' && placed.name === 'City_Center') {
                    return true;
                }
            }
            return false;
        }

        function highlightAllTiles(type, name, skipAvailabilityCheck = false, excludeLocation = null) {
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const hexGrid = document.getElementById('hexGrid');
                    if (!hexGrid) continue;
                    const hex = hexGrid.querySelector(`.hex[data-row="${row}"][data-col="${col}"]`);
                    if (!hex) continue;
                    
                    // Remove any existing preview
                    const existingPreview = hex.querySelector('.adjacency-preview');
                    if (existingPreview) {
                        existingPreview.remove();
                    }
                    
                    const key = `${row},${col}`;
                    const tile = challengeData.tiles[key];
                    
                    // Check if placement is valid
                    const isValid = isValidPlacement(row, col, type, name, tile, excludeLocation);
                    const isAvailable = skipAvailabilityCheck || availableItems[name] > 0;
                    
                    if (isValid && isAvailable) {
                        hex.classList.add('valid-placement');
                        hex.classList.remove('invalid-placement');
                        
                        // If dragging a district, show adjacency preview
                        if (type === 'district') {
                            const preview = calculateAdjacencyPreview(row, col, name, excludeLocation);
                            if (preview && preview.total > 0) {
                                const previewIndicator = document.createElement('div');
                                previewIndicator.className = 'adjacency-preview';
                                
                                const yieldTypes = [
                                    { name: 'Science', value: preview.science, icon: 'assets/yields/Science.webp' },
                                    { name: 'Faith', value: preview.faith, icon: 'assets/yields/Faith.webp' },
                                    { name: 'Gold', value: preview.gold, icon: 'assets/yields/Gold.webp' },
                                    { name: 'Production', value: preview.production, icon: 'assets/yields/Production.webp' },
                                    { name: 'Culture', value: preview.culture, icon: 'assets/yields/Culture.webp' }
                                ];
                                
                                yieldTypes.forEach(yieldType => {
                                    if (yieldType.value > 0) {
                                        const badge = document.createElement('div');
                                        badge.className = 'yield-badge';
                                        
                                        const amount = document.createElement('span');
                                        amount.className = 'yield-amount';
                                        amount.textContent = `+${yieldType.value}`;
                                        
                                        const icon = document.createElement('img');
                                        icon.className = 'yield-icon';
                                        icon.src = yieldType.icon;
                                        icon.alt = yieldType.name;
                                        icon.draggable = false;
                                        
                                        badge.appendChild(amount);
                                        badge.appendChild(icon);
                                        previewIndicator.appendChild(badge);
                                    }
                                });
                                
                                hex.appendChild(previewIndicator);
                            }
                        }
                    } else {
                        hex.classList.add('invalid-placement');
                        hex.classList.remove('valid-placement');
                    }
                }
            }
        }

        function clearAllHighlights() {
            const hexGrid = document.getElementById('hexGrid');
            if (!hexGrid) return;
            
            const allHexes = hexGrid.querySelectorAll('.hex');
            allHexes.forEach(hex => {
                hex.classList.remove('valid-placement');
                hex.classList.remove('invalid-placement');
                // Remove any adjacency previews
                const preview = hex.querySelector('.adjacency-preview');
                if (preview) {
                    preview.remove();
                }
            });
        }

        function calculateAdjacencyPreview(row, col, districtName, excludeLocation = null) {
            // Calculate what adjacency would be if this district were placed here
            const districtBonus = adjacencyData.district_adjacency_bonuses.find(d => d.name === districtName);
            if (!districtBonus) return null;
            
            const key = `${row},${col}`;
            const tile = challengeData.tiles[key];
            const neighbors = getNeighbors(row, col);
            
            let science = 0;
            let faith = 0;
            let gold = 0;
            let production = 0;
            let culture = 0;
            
            const bonuses = districtBonus.adjacency_bonuses;
            
            // Check for river edges on this tile (River_Edge is about the tile itself having a river)
            if (tile && tile.rivers) {
                let hasRiver = false;
                for (let i = 0; i < 6; i++) {
                    if (tile.rivers[i]) {
                        hasRiver = true;
                        break;
                    }
                }
                if (hasRiver && bonuses.River_Edge) {
                    const bonus = bonuses.River_Edge;
                    if (bonus.type === 'Gold') gold += bonus.bonus;
                }
            }
            
            // Check neighbors for terrain, features, and resources
            let districtCount = 0;
            let cityCenterCount = 0;
            let harborCount = 0;
            let commercialHubCount = 0;
            let wonderCount = 0;
            let entertainmentComplexCount = 0;
            let waterParkCount = 0;
            let governmentPlazaCount = 0;
            let aqueductCount = 0;
            let damCount = 0;
            let canalCount = 0;
            let improvementCounts = {};
            let mountainCount = 0;
            let rainforestCount = 0;
            let geothermalFissureCount = 0;
            let reefCount = 0;
            let coastalResourceCount = 0;
            
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                // Skip if this is the excluded location (when moving a district)
                if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                    return;
                }
                
                const neighborPlaced = placedItems[neighborKey];
                const neighborTile = challengeData.tiles[neighborKey];
                
                // Check neighbor terrain/features for adjacency bonuses
                // Only count terrain/features if the tile doesn't have a district or improvement on it
                if (neighborTile && !neighborPlaced) {
                    // Check for mountains
                    if (neighborTile.terrain && neighborTile.terrain.includes('Mountain')) {
                        mountainCount++;
                    }
                    // Check for features
                    if (neighborTile.feature === 'Rainforest') {
                        rainforestCount++;
                    }
                    if (neighborTile.feature === 'Geothermal_Fissure') {
                        geothermalFissureCount++;
                    }
                    // Check for reef
                    if (neighborTile.terrain === 'Reef') {
                        reefCount++;
                    }
                    // Check for coastal resources (resources on coast/ocean/reef tiles)
                    if (neighborTile.resource && (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                        coastalResourceCount++;
                    }
                }
                
                if (neighborPlaced) {
                    if (neighborPlaced.type === 'district') {
                        districtCount++;
                        if (neighborPlaced.name === 'City_Center') cityCenterCount++;
                        if (neighborPlaced.name === 'Harbor') harborCount++;
                        if (neighborPlaced.name === 'Commercial_Hub') commercialHubCount++;
                        if (neighborPlaced.name === 'Government_Plaza') governmentPlazaCount++;
                        if (neighborPlaced.name === 'Entertainment_Complex') entertainmentComplexCount++;
                        if (neighborPlaced.name === 'Water_Park') waterParkCount++;
                        if (neighborPlaced.name === 'Aqueduct') aqueductCount++;
                        if (neighborPlaced.name === 'Dam') damCount++;
                        if (neighborPlaced.name === 'Canal') canalCount++;
                    } else if (neighborPlaced.type === 'wonder') {
                        wonderCount++;
                    } else if (neighborPlaced.type === 'improvement') {
                        improvementCounts[neighborPlaced.name] = (improvementCounts[neighborPlaced.name] || 0) + 1;
                    }
                }
            });
            
            // Apply terrain/feature bonuses from neighbors
            if (bonuses.Mountain && mountainCount > 0) {
                const bonus = bonuses.Mountain;
                const amount = mountainCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
            }
            
            if (bonuses.Rainforest && rainforestCount > 0) {
                const bonus = bonuses.Rainforest;
                const amount = Math.floor(rainforestCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Geothermal_Fissure && geothermalFissureCount > 0) {
                const bonus = bonuses.Geothermal_Fissure;
                const amount = geothermalFissureCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Reef && reefCount > 0) {
                const bonus = bonuses.Reef;
                const amount = reefCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Coastal_Resources && coastalResourceCount > 0) {
                const bonus = bonuses.Coastal_Resources;
                const amount = coastalResourceCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            // Apply bonuses (same logic as calculateAdjacency)
            if (bonuses.all_districts && districtCount > 0) {
                const bonus = bonuses.all_districts;
                const amount = Math.floor(districtCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.City_Center && cityCenterCount > 0) {
                const bonus = bonuses.City_Center;
                const amount = cityCenterCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Harbor && harborCount > 0) {
                const bonus = bonuses.Harbor;
                const amount = harborCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Commercial_Hub && commercialHubCount > 0) {
                const bonus = bonuses.Commercial_Hub;
                const amount = commercialHubCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Government_Plaza && governmentPlazaCount > 0) {
                const bonus = bonuses.Government_Plaza;
                const amount = governmentPlazaCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Wonder && wonderCount > 0) {
                const bonus = bonuses.Wonder;
                const amount = wonderCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Entertainment_Complex && entertainmentComplexCount > 0) {
                const bonus = bonuses.Entertainment_Complex;
                const amount = entertainmentComplexCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Water_Park && waterParkCount > 0) {
                const bonus = bonuses.Water_Park;
                const amount = waterParkCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Mine && improvementCounts.Mine) {
                const bonus = bonuses.Mine;
                const amount = Math.floor(improvementCounts.Mine / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Lumber_Mill && improvementCounts.Lumber_Mill) {
                const bonus = bonuses.Lumber_Mill;
                const amount = Math.floor(improvementCounts.Lumber_Mill / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Quarry && improvementCounts.Quarry) {
                const bonus = bonuses.Quarry;
                const amount = improvementCounts.Quarry * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Aqueduct && aqueductCount > 0) {
                const bonus = bonuses.Aqueduct;
                const amount = aqueductCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Dam && damCount > 0) {
                const bonus = bonuses.Dam;
                const amount = damCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Canal && canalCount > 0) {
                const bonus = bonuses.Canal;
                const amount = canalCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            let strategicResourceCount = 0;
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborTile = challengeData.tiles[neighborKey];
                if (neighborTile && neighborTile.resource) {
                    const resourceInfo = resourcesData.strategic_resources.find(r => r.name === neighborTile.resource);
                    if (resourceInfo) {
                        strategicResourceCount++;
                    }
                }
            });
            
            if (bonuses.Strategic_Resource && strategicResourceCount > 0) {
                const bonus = bonuses.Strategic_Resource;
                const amount = strategicResourceCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            return {
                science,
                faith,
                gold,
                production,
                culture,
                total: science + faith + gold + production + culture
            };
        }

        function getHexDistance(row1, col1, row2, col2) {
            // Convert offset coordinates to cube coordinates for distance calculation
            // Using odd-r offset system
            const q1 = col1 - (row1 - (row1 & 1)) / 2;
            const r1 = row1;
            const s1 = -q1 - r1;
            
            const q2 = col2 - (row2 - (row2 & 1)) / 2;
            const r2 = row2;
            const s2 = -q2 - r2;
            
            // Hex distance formula
            return (Math.abs(q1 - q2) + Math.abs(r1 - r2) + Math.abs(s1 - s2)) / 2;
        }

        // Helper function to check if a city center owns (or could own via ambiguous ownership) a district of a type
        function cityCenterOwnsDistrictType(cityKey, districtName, excludeDistrictKey = null) {
            for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                if (districtKey === excludeDistrictKey) continue;
                if (districtPlaced.type !== 'district' || districtPlaced.name !== districtName) continue;
                
                // Check if this district is owned by (or could be owned by) this city center
                if (Array.isArray(districtPlaced.owner)) {
                    // Ambiguous owner - check if city center is in the array
                    if (districtPlaced.owner.includes(cityKey)) {
                        return true;
                    }
                } else if (districtPlaced.owner === cityKey) {
                    // Direct owner
                    return true;
                }
            }
            return false;
        }

        // Helper function to get all possible city center owners for a district at a location
        function getPossibleOwners(row, col, districtName, excludeLocation = null) {
            const possibleOwners = [];
            
            // First, check if this district is adjacent to any City_Center (first ring)
            const neighbors = getNeighbors(row, col);
            let adjacentCityCenter = null;
            for (const neighbor of neighbors) {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborPlaced = placedItems[neighborKey];
                
                // Skip if this is the excluded location
                if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                    continue;
                }
                
                if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'City_Center') {
                    adjacentCityCenter = neighborKey;
                    break;
                }
            }
            
            if (adjacentCityCenter) {
                // District is in a City_Center's first ring - must be owned by that City_Center
                return [adjacentCityCenter];
            } else {
                // District is not adjacent to any City_Center, find all City_Centers within 3 tiles
                // But exclude City_Centers that have this district in their first ring
                for (const [cityKey, cityPlaced] of Object.entries(placedItems)) {
                    if (cityPlaced.type !== 'district' || cityPlaced.name !== 'City_Center') continue;
                    
                    const [cityRow, cityCol] = cityKey.split(',').map(Number);
                    
                    // Skip if this is the excluded location
                    if (excludeLocation && cityRow === excludeLocation.row && cityCol === excludeLocation.col) {
                        continue;
                    }
                    
                    // Check if this district is in another City_Center's first ring
                    const cityNeighbors = getNeighbors(cityRow, cityCol);
                    let isInAnotherCityFirstRing = false;
                    for (const cityNeighbor of cityNeighbors) {
                        if (cityNeighbor.row === row && cityNeighbor.col === col) {
                            isInAnotherCityFirstRing = true;
                            break;
                        }
                    }
                    
                    if (isInAnotherCityFirstRing) {
                        continue; // Skip this City_Center
                    }
                    
                    const distance = getHexDistance(row, col, cityRow, cityCol);
                    if (distance <= 3) {
                        // Check if this City_Center already owns a district of this type
                        // But consider ambiguous owners - if a district has ambiguous owners including this city,
                        // we can still add this city as a possible owner (allows swapping)
                        let alreadyOwns = false;
                        
                        for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                            if (districtPlaced.type !== 'district' || districtPlaced.name !== districtName) continue;
                            
                            // Skip if this is the excluded location (old location when moving)
                            if (excludeLocation) {
                                const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                if (districtRow === excludeLocation.row && districtCol === excludeLocation.col) {
                                    continue;
                                }
                            }
                            
                            // Skip if this is the current location (new location when moving)
                            // The district being assigned ownership is already at this location
                            const [districtRow, districtCol] = districtKey.split(',').map(Number);
                            if (districtRow === row && districtCol === col) {
                                continue;
                            }
                            
                            // Check if this district is owned by this city center
                            if (Array.isArray(districtPlaced.owner)) {
                                // Ambiguous owner - check if this city is included
                                if (districtPlaced.owner.includes(cityKey)) {
                                    // If this city is the ONLY owner (array with 1 element), it's taken
                                    if (districtPlaced.owner.length === 1) {
                                        alreadyOwns = true;
                                        break;
                                    }
                                    // If this city is one of MULTIPLE owners, we can still add this city
                                    // The ambiguous ownership allows flexibility - the existing district could
                                    // belong to one of the other cities, freeing up this city for the new district
                                }
                            } else if (districtPlaced.owner === cityKey) {
                                // Direct owner (not ambiguous) - city center already owns this type
                                alreadyOwns = true;
                                break;
                            }
                        }
                        
                        // Add this city center as a possible owner if it doesn't already own this type
                        // (or if it owns it ambiguously, which allows swapping)
                        if (!alreadyOwns) {
                            possibleOwners.push(cityKey);
                        }
                    }
                }
            }
            
            return possibleOwners;
        }

        // Helper function to assign ownership to a district (supports ambiguous owners)
        function assignDistrictOwnership(districtKey, row, col, districtName, excludeLocation = null) {
            const district = placedItems[districtKey];
            if (!district || district.type !== 'district' || district.name !== districtName) {
                return;
            }
            
            const possibleOwners = getPossibleOwners(row, col, districtName, excludeLocation);
            
            if (possibleOwners.length === 0) {
                // No valid owner - remove ownership
                delete district.owner;
            } else if (possibleOwners.length === 1) {
                // Single owner - assign directly (not ambiguous)
                district.owner = possibleOwners[0];
            } else {
                // Multiple possible owners - assign as ambiguous (array)
                // This allows the district to belong to any of these city centers
                district.owner = possibleOwners;
            }
        }

        // Helper function to check if two districts of the same type can swap positions and owners
        function canDistrictsSwap(district1Key, district2Key) {
            const district1 = placedItems[district1Key];
            const district2 = placedItems[district2Key];
            
            // Both must be districts of the same type
            if (!district1 || !district2 || 
                district1.type !== 'district' || district2.type !== 'district' ||
                district1.name !== district2.name ||
                district1.name === 'City_Center') {
                return false;
            }
            
            // Get possible owners for both districts
            const [district1Row, district1Col] = district1Key.split(',').map(Number);
            const [district2Row, district2Col] = district2Key.split(',').map(Number);
            
            const district1Owners = getPossibleOwners(district1Row, district1Col, district1.name, { row: district2Row, col: district2Col });
            const district2Owners = getPossibleOwners(district2Row, district2Col, district2.name, { row: district1Row, col: district1Col });
            
            // They can swap if:
            // 1. Both have at least 2 possible owners (ambiguous)
            // 2. The possible owners overlap (they share at least 2 city centers)
            if (district1Owners.length >= 2 && district2Owners.length >= 2) {
                // Check if they share at least 2 city centers
                const sharedOwners = district1Owners.filter(owner => district2Owners.includes(owner));
                return sharedOwners.length >= 2;
            }
            
            return false;
        }

        // Helper function to reassign district ownership to the best available city center
        // This allows districts to swap owners when city centers move
        function reassignDistrictOwnership(districtKey) {
            const district = placedItems[districtKey];
            if (!district || district.type !== 'district' || district.name === 'City_Center') {
                return;
            }
            
            const [districtRow, districtCol] = districtKey.split(',').map(Number);
            assignDistrictOwnership(districtKey, districtRow, districtCol, district.name);
        }

        function getNeighbors(row, col) {
            const neighbors = [];
            const isOddRow = row % 2 === 1;
            
            // For flat-top hexagons:
            // Even rows: neighbors are at same col, col-1, col+1
            // Odd rows: neighbors are at same col, col+1, col+1
            
            // Right neighbor
            if (col < GRID_WIDTH - 1) {
                neighbors.push({ row, col: col + 1 });
            }
            
            // Left neighbor
            if (col > 0) {
                neighbors.push({ row, col: col - 1 });
            }
            
            // Top and bottom neighbors depend on row parity
            if (isOddRow) {
                // Odd row: top neighbors are at row-1, same col and col+1
                if (row > 0) {
                    neighbors.push({ row: row - 1, col });
                    if (col < GRID_WIDTH - 1) {
                        neighbors.push({ row: row - 1, col: col + 1 });
                    }
                }
                // Odd row: bottom neighbors are at row+1, same col and col+1
                if (row < GRID_HEIGHT - 1) {
                    neighbors.push({ row: row + 1, col });
                    if (col < GRID_WIDTH - 1) {
                        neighbors.push({ row: row + 1, col: col + 1 });
                    }
                }
            } else {
                // Even row: top neighbors are at row-1, same col and col-1
                if (row > 0) {
                    neighbors.push({ row: row - 1, col });
                    if (col > 0) {
                        neighbors.push({ row: row - 1, col: col - 1 });
                    }
                }
                // Even row: bottom neighbors are at row+1, same col and col-1
                if (row < GRID_HEIGHT - 1) {
                    neighbors.push({ row: row + 1, col });
                    if (col > 0) {
                        neighbors.push({ row: row + 1, col: col - 1 });
                    }
                }
            }
            
            return neighbors;
        }
        
        function getNeighborAtDirection(row, col, direction) {
            // Directions: 0=Right, 1=Top-right, 2=Top-left, 3=Left, 4=Bottom-left, 5=Bottom-right
            const isOddRow = row % 2 === 1;
            
            switch (direction) {
                case 0: // Right
                    if (col < GRID_WIDTH - 1) {
                        return { row, col: col + 1 };
                    }
                    break;
                case 1: // Top-right
                    if (row > 0) {
                        if (isOddRow) {
                            if (col < GRID_WIDTH - 1) {
                                return { row: row - 1, col: col + 1 };
                            }
                        } else {
                            return { row: row - 1, col };
                        }
                    }
                    break;
                case 2: // Top-left
                    if (row > 0) {
                        if (isOddRow) {
                            return { row: row - 1, col };
                        } else {
                            if (col > 0) {
                                return { row: row - 1, col: col - 1 };
                            }
                        }
                    }
                    break;
                case 3: // Left
                    if (col > 0) {
                        return { row, col: col - 1 };
                    }
                    break;
                case 4: // Bottom-left
                    if (row < GRID_HEIGHT - 1) {
                        if (isOddRow) {
                            return { row: row + 1, col };
                        } else {
                            if (col > 0) {
                                return { row: row + 1, col: col - 1 };
                            }
                        }
                    }
                    break;
                case 5: // Bottom-right
                    if (row < GRID_HEIGHT - 1) {
                        if (isOddRow) {
                            if (col < GRID_WIDTH - 1) {
                                return { row: row + 1, col: col + 1 };
                            }
                        } else {
                            return { row: row + 1, col };
                        }
                    }
                    break;
            }
            return null;
        }

        function calculateAdjacency(row, col) {
            const key = `${row},${col}`;
            const placed = placedItems[key];
            if (!placed || placed.type !== 'district') return null;
            
            const districtName = placed.name;
            const districtBonus = adjacencyData.district_adjacency_bonuses.find(d => d.name === districtName);
            if (!districtBonus) return null;
            
            const tile = challengeData.tiles[key];
            const neighbors = getNeighbors(row, col);
            
            let science = 0;
            let faith = 0;
            let gold = 0;
            let production = 0;
            let culture = 0;
            
            const bonuses = districtBonus.adjacency_bonuses;
            
            // Check for river edges on this tile (River_Edge is about the tile itself having a river)
            if (tile && tile.rivers) {
                    let hasRiver = false;
                    for (let i = 0; i < 6; i++) {
                        if (tile.rivers[i]) {
                            hasRiver = true;
                            break;
                        }
                    }
                    if (hasRiver && bonuses.River_Edge) {
                        const bonus = bonuses.River_Edge;
                        if (bonus.type === 'Gold') gold += bonus.bonus;
                }
            }
            
            // Check neighbors for terrain, features, and resources
            let districtCount = 0;
            let cityCenterCount = 0;
            let harborCount = 0;
            let commercialHubCount = 0;
            let wonderCount = 0;
            let entertainmentComplexCount = 0;
            let waterParkCount = 0;
            let governmentPlazaCount = 0;
            let aqueductCount = 0;
            let damCount = 0;
            let canalCount = 0;
            let improvementCounts = {};
            let mountainCount = 0;
            let rainforestCount = 0;
            let geothermalFissureCount = 0;
            let reefCount = 0;
            let coastalResourceCount = 0;
            
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborPlaced = placedItems[neighborKey];
                const neighborTile = challengeData.tiles[neighborKey];
                
                // Check neighbor terrain/features for adjacency bonuses
                // Only count terrain/features if the tile doesn't have a district or improvement on it
                if (neighborTile && !neighborPlaced) {
                    // Check for mountains
                    if (neighborTile.terrain && neighborTile.terrain.includes('Mountain')) {
                        mountainCount++;
                    }
                    // Check for features
                    if (neighborTile.feature === 'Rainforest') {
                        rainforestCount++;
                    }
                    if (neighborTile.feature === 'Geothermal_Fissure') {
                        geothermalFissureCount++;
                    }
                    // Check for reef
                    if (neighborTile.terrain === 'Reef') {
                        reefCount++;
                    }
                    // Check for coastal resources (resources on coast/ocean/reef tiles)
                    if (neighborTile.resource && (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                        coastalResourceCount++;
                    }
                }
                
                if (neighborPlaced) {
                    if (neighborPlaced.type === 'district') {
                        districtCount++;
                        if (neighborPlaced.name === 'City_Center') cityCenterCount++;
                        if (neighborPlaced.name === 'Harbor') harborCount++;
                        if (neighborPlaced.name === 'Commercial_Hub') commercialHubCount++;
                        if (neighborPlaced.name === 'Government_Plaza') governmentPlazaCount++;
                        if (neighborPlaced.name === 'Entertainment_Complex') entertainmentComplexCount++;
                        if (neighborPlaced.name === 'Water_Park') waterParkCount++;
                        if (neighborPlaced.name === 'Aqueduct') aqueductCount++;
                        if (neighborPlaced.name === 'Dam') damCount++;
                        if (neighborPlaced.name === 'Canal') canalCount++;
                    } else if (neighborPlaced.type === 'wonder') {
                        wonderCount++;
                    } else if (neighborPlaced.type === 'improvement') {
                        improvementCounts[neighborPlaced.name] = (improvementCounts[neighborPlaced.name] || 0) + 1;
                    }
                }
            });
            
            // Apply terrain/feature bonuses from neighbors
            if (bonuses.Mountain && mountainCount > 0) {
                const bonus = bonuses.Mountain;
                const amount = mountainCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
            }
            
            if (bonuses.Rainforest && rainforestCount > 0) {
                const bonus = bonuses.Rainforest;
                const amount = Math.floor(rainforestCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Geothermal_Fissure && geothermalFissureCount > 0) {
                const bonus = bonuses.Geothermal_Fissure;
                const amount = geothermalFissureCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Reef && reefCount > 0) {
                const bonus = bonuses.Reef;
                const amount = reefCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Coastal_Resources && coastalResourceCount > 0) {
                const bonus = bonuses.Coastal_Resources;
                const amount = coastalResourceCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            // Apply bonuses
            if (bonuses.all_districts && districtCount > 0) {
                const bonus = bonuses.all_districts;
                const amount = Math.floor(districtCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.City_Center && cityCenterCount > 0) {
                const bonus = bonuses.City_Center;
                const amount = cityCenterCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Harbor && harborCount > 0) {
                const bonus = bonuses.Harbor;
                const amount = harborCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Commercial_Hub && commercialHubCount > 0) {
                const bonus = bonuses.Commercial_Hub;
                const amount = commercialHubCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Government_Plaza && governmentPlazaCount > 0) {
                const bonus = bonuses.Government_Plaza;
                const amount = governmentPlazaCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Wonder && wonderCount > 0) {
                const bonus = bonuses.Wonder;
                const amount = wonderCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Entertainment_Complex && entertainmentComplexCount > 0) {
                const bonus = bonuses.Entertainment_Complex;
                const amount = entertainmentComplexCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Water_Park && waterParkCount > 0) {
                const bonus = bonuses.Water_Park;
                const amount = waterParkCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            // Check improvements
            if (bonuses.Mine && improvementCounts.Mine) {
                const bonus = bonuses.Mine;
                const amount = Math.floor(improvementCounts.Mine / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Lumber_Mill && improvementCounts.Lumber_Mill) {
                const bonus = bonuses.Lumber_Mill;
                const amount = Math.floor(improvementCounts.Lumber_Mill / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Quarry && improvementCounts.Quarry) {
                const bonus = bonuses.Quarry;
                const amount = improvementCounts.Quarry * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Aqueduct && aqueductCount > 0) {
                const bonus = bonuses.Aqueduct;
                const amount = aqueductCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Dam && damCount > 0) {
                const bonus = bonuses.Dam;
                const amount = damCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Canal && canalCount > 0) {
                const bonus = bonuses.Canal;
                const amount = canalCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            // Check for strategic resources
            let strategicResourceCount = 0;
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborTile = challengeData.tiles[neighborKey];
                if (neighborTile && neighborTile.resource) {
                    const resourceInfo = resourcesData.strategic_resources.find(r => r.name === neighborTile.resource);
                    if (resourceInfo) {
                        strategicResourceCount++;
                    }
                }
            });
            
            if (bonuses.Strategic_Resource && strategicResourceCount > 0) {
                const bonus = bonuses.Strategic_Resource;
                const amount = strategicResourceCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            return {
                science,
                faith,
                gold,
                production,
                culture,
                total: science + faith + gold + production + culture
            };
        }

        function updateAllScores() {
            let totalScience = 0;
            let totalFaith = 0;
            let totalGold = 0;
            let totalProduction = 0;
            let totalCulture = 0;
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const adjacency = calculateAdjacency(row, col);
                    if (adjacency) {
                        totalScience += adjacency.science;
                        totalFaith += adjacency.faith;
                        totalGold += adjacency.gold;
                        totalProduction += adjacency.production;
                        totalCulture += adjacency.culture;
                    }
                }
            }
            
            const scorePanel = document.getElementById('scorePanel');
            if (scorePanel) {
                scorePanel.innerHTML = `
                    <h3>Adjacency Bonuses</h3>
                    <div class="score-item">
                        <span class="yield-label">
                            <img src="assets/yields/Science.webp" alt="Science" class="yield-icon">
                            <span>Science:</span>
                        </span>
                        <span>+${totalScience}</span>
                    </div>
                    <div class="score-item">
                        <span class="yield-label">
                            <img src="assets/yields/Culture.webp" alt="Culture" class="yield-icon">
                            <span>Culture:</span>
                        </span>
                        <span>+${totalCulture}</span>
                    </div>
                    <div class="score-item">
                        <span class="yield-label">
                            <img src="assets/yields/Production.webp" alt="Production" class="yield-icon">
                            <span>Production:</span>
                        </span>
                        <span>+${totalProduction}</span>
                    </div>
                    <div class="score-item">
                        <span class="yield-label">
                            <img src="assets/yields/Faith.webp" alt="Faith" class="yield-icon">
                            <span>Faith:</span>
                        </span>
                        <span>+${totalFaith}</span>
                    </div>
                    <div class="score-item">
                        <span class="yield-label">
                            <img src="assets/yields/Gold.webp" alt="Gold" class="yield-icon">
                            <span>Gold:</span>
                        </span>
                        <span>+${totalGold}</span>
                    </div>
                    <div class="score-formula">
                        <div class="score-item" style="justify-content: center; gap: 4px;">
                            <img src="assets/yields/Score.webp" alt="Score" class="yield-icon">
                            <span>=</span>
                            <img src="assets/yields/Science.webp" alt="Science" class="yield-icon">
                            <span>+</span>
                            <img src="assets/yields/Culture.webp" alt="Culture" class="yield-icon">
                            <span>+</span>
                            <img src="assets/yields/Production.webp" alt="Production" class="yield-icon">
                            <span>+</span>
                            <img src="assets/yields/Faith.webp" alt="Faith" class="yield-icon">
                            <span>+</span>
                            <span>0.5</span>
                            <img src="assets/yields/Gold.webp" alt="Gold" class="yield-icon">
                        </div>
                    </div>
                    <div class="score-total">
                        <div class="score-item">
                            <span class="yield-label">
                                <img src="assets/yields/Score.webp" alt="Score" class="yield-icon">
                                <span>Total Score:</span>
                            </span>
                            <span>${totalScience + totalCulture + totalProduction + totalFaith + (totalGold * 0.5)}</span>
                        </div>
                    </div>
                    <input type="file" id="challengeFileInput" accept=".civle" style="display: none;" onchange="loadChallenge(event)">
                    <button id="uploadChallengeBtn" class="submit-score-btn" onclick="document.getElementById('challengeFileInput').click()">Upload Challenge File</button>
                `;
                
                // Add event listener for upload button
                const uploadBtn = document.getElementById('uploadChallengeBtn');
                if (uploadBtn) {
                    // Button click is handled by onclick attribute above
                }
            }
        }
        
        function getTodayKey() {
            // Get current date in EST timezone (same as server)
            const now = new Date();
            const estDate = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
            const month = String(estDate.getMonth() + 1).padStart(2, '0');
            const day = String(estDate.getDate()).padStart(2, '0');
            return `submitted_${estDate.getFullYear()}-${month}-${day}`;
        }
        
        function checkSubmissionStatus() {
            const submitBtn = document.getElementById('submitScoreBtn');
            if (!submitBtn) return;
            
            const todayKey = getTodayKey();
            const hasSubmitted = localStorage.getItem(todayKey) === 'true';
            
            if (hasSubmitted) {
                submitBtn.textContent = 'View Leaderboard';
            } else {
                submitBtn.textContent = 'Submit Score';
            }
        }
        
        async function handleScoreButtonClick() {
            const submitBtn = document.getElementById('submitScoreBtn');
            if (!submitBtn) return;
            
            const todayKey = getTodayKey();
            const hasSubmitted = localStorage.getItem(todayKey) === 'true';
            
            if (hasSubmitted) {
                // Just show leaderboard
                await showLeaderboard(null, false, null, true);
            } else {
                // Submit score
                await submitScore();
            }
        }
        
        async function submitScore() {
            const submitBtn = document.getElementById('submitScoreBtn');
            if (!submitBtn) return;
            
            // Calculate total score
            let totalScience = 0;
            let totalFaith = 0;
            let totalGold = 0;
            let totalProduction = 0;
            let totalCulture = 0;
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const adjacency = calculateAdjacency(row, col);
                    if (adjacency) {
                        totalScience += adjacency.science;
                        totalFaith += adjacency.faith;
                        totalGold += adjacency.gold;
                        totalProduction += adjacency.production;
                        totalCulture += adjacency.culture;
                    }
                }
            }
            
            const totalScore = totalScience + totalCulture + totalProduction + totalFaith + (totalGold * 0.5);
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Submitting...';
            
            try {
                // Capture screenshot before submitting (server will determine if it should be saved)
                let screenshotData = null;
                try {
                    screenshotData = await captureScreenshot();
                } catch (error) {
                    console.error('Error capturing screenshot:', error);
                    // Continue with submission even if screenshot fails
                }
                
                // Send score and screenshot together (server determines if screenshot should be saved)
                const requestBody = {
                    score: totalScore,
                    screenshot: screenshotData
                };
                
                const scoreResponse = await fetch('/submit-score', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await scoreResponse.json();
                
                if (data.success) {
                    // Mark as submitted for today
                    const todayKey = getTodayKey();
                    localStorage.setItem(todayKey, 'true');
                    
                    // Update button text
                    submitBtn.textContent = 'View Leaderboard';
                    submitBtn.disabled = false;
                    
                    // Show leaderboard
                    await showLeaderboard(data.rank, data.inTop10, totalScore);
                } else {
                    alert('Failed to submit score: ' + (data.error || 'Unknown error'));
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Submit Score';
                }
            } catch (error) {
                console.error('Error submitting score:', error);
                alert('Failed to submit score. Please try again.');
                submitBtn.disabled = false;
                submitBtn.textContent = 'Submit Score';
            }
        }
        
        async function showLeaderboard(rank, inTop10, totalScore, viewOnly = false) {
            const modal = document.getElementById('leaderboardModal');
            const rankInfo = document.getElementById('rankInfo');
            const nameInputSection = document.getElementById('nameInputSection');
            const nameInput = document.getElementById('playerName');
            const charCount = document.getElementById('charCount');
            const leaderboardList = document.getElementById('leaderboardList');
            
            // Update rank info
            if (rank !== null) {
                rankInfo.textContent = `Your rank: #${rank}`;
            } else {
                rankInfo.textContent = '';
            }
            
            // Show name input if in top 10 and not view-only
            if (inTop10 && !viewOnly) {
                nameInputSection.style.display = 'block';
                nameInput.value = '';
                charCount.textContent = '0';
                
                // Character count update
                nameInput.addEventListener('input', () => {
                    charCount.textContent = nameInput.value.length;
                });
            } else {
                nameInputSection.style.display = 'none';
            }
            
            // Fetch and display leaderboard
            try {
                const response = await fetch('/leaderboard');
                const data = await response.json();
                
                if (data.success) {
                    leaderboardList.innerHTML = '';
                    data.leaderboard.forEach((entry, index) => {
                        const li = document.createElement('li');
                        li.className = `leaderboard-item rank-${index + 1}`;
                        li.innerHTML = `
                            <span class="rank">#${index + 1}</span>
                            <span class="name">${entry.name || 'Anonymous'}</span>
                            <span class="score">
                                <img src="assets/yields/Score.webp" alt="Score" class="score-icon">
                                ${entry.score}
                            </span>
                        `;
                        leaderboardList.appendChild(li);
                    });
                } else {
                    leaderboardList.innerHTML = '<li>Failed to load leaderboard</li>';
                }
            } catch (error) {
                console.error('Error loading leaderboard:', error);
                leaderboardList.innerHTML = '<li>Failed to load leaderboard</li>';
            }
            
            modal.classList.add('active');
            
            // If in top 10, wait for name submission
            if (inTop10) {
                const submitName = async () => {
                    const name = nameInput.value.trim();
                    if (name.length === 0) {
                        alert('Please enter your name');
                        return;
                    }
                    
                    try {
                        const response = await fetch('/submit-score', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ 
                                score: totalScore,
                                name: name 
                            })
                        });
                        
                        const data = await response.json();
                        if (data.success) {
                            // Reload leaderboard
                            const leaderboardResponse = await fetch('/leaderboard');
                            const leaderboardData = await leaderboardResponse.json();
                            if (leaderboardData.success) {
                                leaderboardList.innerHTML = '';
                                leaderboardData.leaderboard.forEach((entry, index) => {
                                    const li = document.createElement('li');
                                    li.className = `leaderboard-item rank-${index + 1}`;
                                    li.innerHTML = `
                                        <span class="rank">#${index + 1}</span>
                                        <span class="name">${entry.name || 'Anonymous'}</span>
                                        <span class="score">
                                            <img src="assets/yields/Score.webp" alt="Score" class="score-icon">
                                            ${entry.score}
                                        </span>
                                    `;
                                    leaderboardList.appendChild(li);
                                });
                            }
                            nameInputSection.style.display = 'none';
                        } else {
                            if (data.error === 'Name already taken') {
                                alert('This name is already taken. Please choose a different name.');
                            } else if (data.error === 'Name contains inappropriate content') {
                                alert('This name contains inappropriate content. Please choose a different name.');
                            } else {
                                alert('Failed to submit name: ' + (data.error || 'Unknown error'));
                            }
                        }
                    } catch (error) {
                        console.error('Error submitting name:', error);
                        alert('Failed to submit name. Please try again.');
                    }
                };
                
                nameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        submitName();
                    }
                });
                
                // Add submit button for name
                const existingSubmitBtn = nameInputSection.querySelector('.name-submit-btn');
                if (existingSubmitBtn) {
                    existingSubmitBtn.remove();
                }
                const submitNameBtn = document.createElement('button');
                submitNameBtn.className = 'submit-score-btn name-submit-btn';
                submitNameBtn.textContent = 'Submit Name';
                submitNameBtn.style.marginTop = '8px';
                submitNameBtn.onclick = submitName;
                nameInputSection.appendChild(submitNameBtn);
            }
        }
        
        function closeLeaderboard() {
            const modal = document.getElementById('leaderboardModal');
            modal.classList.remove('active');
            
            // Update button text based on submission status
            checkSubmissionStatus();
            
            const submitBtn = document.getElementById('submitScoreBtn');
            if (submitBtn) {
                submitBtn.disabled = false;
            }
        }

        async function captureScreenshot() {
            try {
                const mapTransformWrapper = document.getElementById('mapTransformWrapper');
                if (!mapTransformWrapper) {
                    console.error('Map container not found');
                    return null;
                }

                // Capture using onclone to fix all transforms and dimensions
                const canvas = await html2canvas(mapTransformWrapper, {
                    scale: 2,
                    backgroundColor: '#1a1a1b',
                    useCORS: true,
                    logging: false,
                    allowTaint: false,
                    onclone: (clonedDoc, element) => {
                        // Reset transform on the wrapper
                        const clonedWrapper = clonedDoc.getElementById('mapTransformWrapper');
                        if (clonedWrapper) {
                            clonedWrapper.style.transform = 'none';
                            clonedWrapper.style.position = 'relative';
                        }
                        
                        // Fix all district images - ensure they fit properly within their hex containers
                        const districtImages = clonedDoc.querySelectorAll('.hex-district');
                        districtImages.forEach(img => {
                            // Get the parent container (district-shape)
                            const parent = img.parentElement;
                            if (parent) {
                                // Make districts 15% wider and 5% taller, moved left a bit
                                img.style.width = '100%'; // 85% + 15% = 100%
                                img.style.height = '90%'; // 85% + 5% = 90%
                                img.style.objectFit = 'contain'; // Fit within bounds without cropping
                                img.style.top = '5%';
                                img.style.left = '-2%'; // Moved left (reduced from 7.5%)
                                img.style.position = 'absolute';
                                img.style.margin = '0';
                                img.style.padding = '0';
                            }
                        });
                        
                        // Ensure district-shape containers have proper dimensions
                        const districtShapes = clonedDoc.querySelectorAll('#districtsLayer .hex-shape');
                        districtShapes.forEach(shape => {
                            const hex = shape.closest('.hex');
                            if (hex) {
                                shape.style.width = '100%';
                                shape.style.height = '100%';
                            }
                        });
                        
                        // Fix all hex shapes to ensure proper dimensions
                        const hexShapes = clonedDoc.querySelectorAll('.hex-shape');
                        hexShapes.forEach(shape => {
                            const hex = shape.closest('.hex');
                            if (hex) {
                                const computedStyle = window.getComputedStyle(hex);
                                shape.style.width = computedStyle.width;
                                shape.style.height = computedStyle.height;
                            }
                        });
                    }
                });

                // Convert canvas to base64 and return
                return canvas.toDataURL('image/png');
            } catch (error) {
                console.error('Error capturing screenshot:', error);
                return null;
            }
        }

        async function showYesterdayBest() {
            const modal = document.getElementById('yesterdayBestModal');
            const imageContainer = document.getElementById('yesterdayBestImage');
            const titleElement = modal.querySelector('h2');
            
            modal.classList.add('active');
            imageContainer.innerHTML = '<p>Loading...</p>';

            try {
                // Calculate yesterday's date in EST
                const now = new Date();
                const estDate = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
                const yesterday = new Date(estDate);
                yesterday.setDate(yesterday.getDate() - 1);
                const month = String(yesterday.getMonth() + 1).padStart(2, '0');
                const day = String(yesterday.getDate()).padStart(2, '0');
                const dateString = `${month}/${day}`;
                
                const response = await fetch(`/yesterday-best-setup`);
                const data = await response.json();
                
                if (data.success && data.screenshot) {
                    // Update title with date and player name
                    if (data.playerName) {
                        titleElement.textContent = `Yesterday's Best Setup (${dateString}) - By: ${data.playerName}`;
                    } else {
                        titleElement.textContent = `Yesterday's Best Setup (${dateString})`;
                    }
                    
                    // Show screenshot
                    imageContainer.innerHTML = `<img src="${data.screenshot}" alt="Yesterday's Best Setup" style="max-width: 100%; height: auto; border: 1px solid #565758; border-radius: 4px;">`;
                } else {
                    titleElement.textContent = `Yesterday (${dateString})`;
                    imageContainer.innerHTML = '<p>No setup available for yesterday.</p>';
                }
            } catch (error) {
                console.error('Error loading yesterday\'s best setup:', error);
                titleElement.textContent = "Yesterday's Best Setup";
                imageContainer.innerHTML = '<p>Error loading yesterday\'s best setup.</p>';
            }
        }

        function closeYesterdayBest() {
            const modal = document.getElementById('yesterdayBestModal');
            modal.classList.remove('active');
        }
        
        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('leaderboardModal');
            if (e.target === modal) {
                closeLeaderboard();
            }
            
            const yesterdayModal = document.getElementById('yesterdayBestModal');
            if (e.target === yesterdayModal) {
                closeYesterdayBest();
            }
        });

        // Add event listener for yesterday's best button
        // Removed yesterday's best setup button for custom game

        function initMapZoomPan() {
            const mapContainer = document.getElementById('mapContainer');
            const mapTransformWrapper = document.getElementById('mapTransformWrapper');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const resetZoomBtn = document.getElementById('resetZoomBtn');

            function updateTransform() {
                mapTransformWrapper.style.transform = `translate(${mapPanX}px, ${mapPanY}px) scale(${mapZoom})`;
            }

            zoomInBtn.onclick = (e) => {
                e.stopPropagation();
                mapZoom = Math.min(mapZoom * 1.2, 3.0);
                updateTransform();
            };

            zoomOutBtn.onclick = (e) => {
                e.stopPropagation();
                mapZoom = Math.max(mapZoom / 1.2, 0.5);
                updateTransform();
            };

            resetZoomBtn.onclick = (e) => {
                e.stopPropagation();
                mapZoom = 2.0; // Increased from 1.0 to zoom in more by default
                mapPanX = 0;
                mapPanY = 0;
                updateTransform();
            };

            mapContainer.addEventListener('wheel', (e) => {
                if (!e.ctrlKey && !e.shiftKey && !e.altKey) {
                    e.preventDefault();
                    const rect = mapContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const containerCenterX = rect.width / 2;
                    const containerCenterY = rect.height / 2;
                    
                    const deltaX = mouseX - containerCenterX;
                    const deltaY = mouseY - containerCenterY;
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.5, Math.min(3.0, mapZoom * zoomFactor));
                    
                    const zoomChange = newZoom / mapZoom;
                    mapPanX = mapPanX * zoomChange + (deltaX * (1 - zoomChange));
                    mapPanY = mapPanY * zoomChange + (deltaY * (1 - zoomChange));
                    mapZoom = newZoom;
                    
                    updateTransform();
                }
            }, { passive: false });

            mapContainer.addEventListener('mousedown', (e) => {
                const isHexClick = e.target.closest('.hex');
                const isButtonClick = e.target.closest('button');
                const isScorePanel = e.target.closest('.score-panel');
                const isDistrict = e.target.closest('.hex-district');
                
                // Don't start map panning if clicking on a district
                if (e.button === 0 && !isHexClick && !isButtonClick && !isScorePanel && !isDistrict) {
                    if (e.target === mapContainer || e.target === mapTransformWrapper || e.target.id === 'hexGrid') {
                        isDragging = true;
                        mapContainer.classList.add('dragging');
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        dragStartPanX = mapPanX;
                        dragStartPanY = mapPanY;
                        e.preventDefault();
                    }
                }
            });

            mapContainer.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    mapPanX = dragStartPanX + deltaX;
                    mapPanY = dragStartPanY + deltaY;
                    updateTransform();
                }
            });

            mapContainer.addEventListener('mouseup', (e) => {
                if (isDragging && e.button === 0) {
                    isDragging = false;
                    mapContainer.classList.remove('dragging');
                }
            });

            mapContainer.addEventListener('mouseleave', () => {
                if (isDragging) {
                    isDragging = false;
                    mapContainer.classList.remove('dragging');
                }
            });

            // Allow dropping districts and improvements in the void to delete them
            mapContainer.addEventListener('dragover', (e) => {
                if (draggedDistrict || draggedImprovement) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                }
            });

            mapContainer.addEventListener('drop', (e) => {
                // Only delete if dropping on the map container itself (not on a hex)
                // Check if the drop target is actually the map container, not a hex
                const dropTarget = e.target;
                const isDroppingOnHex = dropTarget.closest('.hex') !== null;
                
                // If dropping on a hex, the hex handler should have already handled it
                // Only delete if we're actually dropping on the map container background
                if (!isDroppingOnHex) {
                    if (draggedDistrict) {
                        e.preventDefault();
                        // Delete the district by removing it
                        removeItem(draggedDistrict.row, draggedDistrict.col);
                        draggedDistrict = null;
                    } else if (draggedImprovement) {
                        e.preventDefault();
                        // Delete the improvement by removing it
                        removeItem(draggedImprovement.row, draggedImprovement.col);
                        draggedImprovement = null;
                    }
                }
            });

            updateTransform();
        }
        
        // Initialize on load
        // Load game data (don't auto-load daily challenge for custom game)
        loadGameData().then(() => {
            // Show upload prompt in sidebar
            populateSidebar();
        });
    </script>
    
    <!-- Leaderboard Modal -->
    <div id="leaderboardModal" class="leaderboard-modal">
        <div class="leaderboard-content">
            <h2>Leaderboard</h2>
            <div id="rankInfo" class="rank-info"></div>
            <ul id="leaderboardList" class="leaderboard-list"></ul>
            <div id="nameInputSection" class="name-input-section" style="display: none;">
                <label for="playerName">Enter your name:</label>
                <input type="text" id="playerName" maxlength="20" placeholder="Your name">
                <div class="char-count"><span id="charCount">0</span>/20</div>
            </div>
            <button class="leaderboard-close-btn" onclick="closeLeaderboard()">Close</button>
        </div>
    </div>

    <!-- Yesterday's Best Setup Modal -->
    <div id="yesterdayBestModal" class="yesterday-best-modal">
        <div class="yesterday-best-content">
            <h2>Yesterday's Best Setup</h2>
            <div id="yesterdayBestImage"></div>
            <button class="close-btn" onclick="closeYesterdayBest()">Close</button>
        </div>
    </div>
</body>
</html>


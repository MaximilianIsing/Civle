<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Civle - A daily Civilization-inspired puzzle game. Build cities, place districts, and optimize your score in this strategic hex-based puzzle challenge.">
    <meta name="keywords" content="Civle, Civilization, puzzle game, strategy game, daily puzzle, hex game, city building, districts, Civ 6">
    <meta name="author" content="Civle">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://civle.cc/">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://civle.cc/">
    <meta property="og:title" content="Civle - Daily Civ 6 Puzzle Game">
    <meta property="og:description" content="A daily Civ 6 puzzle game. Place districts, improvements, and wonders to get the highest adjacencies.">
    <meta property="og:image" content="https://civle.cc/assets/logo/Logo320x320.png">
    <meta property="og:site_name" content="Civle">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://civle.cc/">
    <meta name="twitter:title" content="Civle - Daily Civilization Puzzle Game">
    <meta name="twitter:description" content="A daily Civ 6 puzzle game. Place districts, improvements, and wonders to get the highest adjacencies.">
    <meta name="twitter:image" content="https://civle.cc/assets/logo/Logo320x320.png">
    
    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Civle",
        "description": "A daily Civilization-inspired puzzle game. Build cities, place districts, and optimize your score in this strategic hex-based puzzle challenge.",
        "url": "https://civle.cc/",
        "applicationCategory": "Game",
        "operatingSystem": "Web Browser",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "5",
            "ratingCount": "1"
        },
        "game": {
            "@type": "VideoGame",
            "name": "Civle",
            "genre": "Strategy, Puzzle",
            "gamePlatform": "Web Browser"
        }
    }
    </script>
    
    <title>Civle Game</title>
    <link rel="icon" type="image/png" href="assets/logo/Logo320x320.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
        // Update title with today's date (EST timezone)
        (function() {
            const now = new Date();
            const estDate = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
            const month = estDate.getMonth() + 1;
            const day = estDate.getDate();
            document.title = `Civle ${month}/${day}`;
        })();
    </script>
    <style>
        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-Medium.ttf') format('truetype');
            font-weight: 500;
            font-style: normal;
        }

        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-Bold.ttf') format('truetype');
            font-weight: 700;
            font-style: normal;
        }

        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-ExtraBold.ttf') format('truetype');
            font-weight: 800;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #121213;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            margin: 0;
        }

        .mobile-message {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: #121213;
            color: #ffffff;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 32px;
            z-index: 99999;
        }

        .mobile-message.active {
            display: flex;
        }

        .mobile-message h1 {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 24px;
            color: #ffffff;
        }

        .mobile-message p {
            font-size: 20px;
            line-height: 1.6;
            color: #818384;
            max-width: 500px;
        }

        body.mobile .header,
        body.mobile .main-container {
            display: none;
        }

        .header {
            background: #121213;
            padding: 16px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 1px solid #3a3a3c;
            position: relative;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .header-logo {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }

        .header h1 {
            font-size: 48px;
            font-weight: 700;
            margin: 0;
            letter-spacing: 0.01em;
            color: #ffffff;
        }

        .header-date {
            font-size: 24px;
            font-weight: 500;
            margin: 0;
            color: #818384;
            margin-left: 12px;
        }

        .header-right {
            position: absolute;
            right: 16px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .yesterday-best-btn {
            padding: 10px 20px;
            background: #3a3a3c;
            color: #ffffff;
            border: 1px solid #565758;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background 0.1s;
        }

        .yesterday-best-btn:hover {
            background: #565758;
        }

        .yesterday-best-btn:active {
            background: #4a4a4c;
        }

        .controls {
            position: absolute;
            right: 16px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        button {
            padding: 6px 12px;
            background: #3a3a3c;
            color: #ffffff;
            border: 1px solid #565758;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: background 0.1s;
        }

        button:hover {
            background: #565758;
        }

        button:active {
            background: #6b6b6d;
        }

        .file-label {
            display: inline-block;
            padding: 8px;
            background: transparent;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 20px;
            font-weight: 400;
            transition: background 0.1s;
            line-height: 1;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .file-label:hover {
            background: #3a3a3c;
        }

        input[type="file"] {
            display: none;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            background: #121213;
        }

        .sidebar {
            width: 280px;
            background: #121213;
            border-right: 1px solid #3a3a3c;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        
        .sidebar-footer {
            padding: 20px 24px;
            border-top: 1px solid #3a3a3c;
            background: #121213;
            flex-shrink: 0;
        }

        .sidebar-content::-webkit-scrollbar {
            width: 8px;
        }

        .sidebar-content::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .sidebar-content::-webkit-scrollbar-thumb {
            background: #3a3a3c;
            border-radius: 4px;
        }

        .sidebar-content::-webkit-scrollbar-thumb:hover {
            background: #565758;
        }

        .sidebar h2 {
            font-size: 16px;
            margin-bottom: 16px;
            color: #ffffff;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .available-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 12px;
            margin: 4px 0;
            background: #3a3a3c;
            border: 1.5px solid #565758;
            border-radius: 4px;
            cursor: grab;
            user-select: none;
            transition: all 0.1s;
        }

        .available-item:hover {
            border-color: #818384;
            background: #565758;
        }

        .available-item:active {
            cursor: grabbing;
        }

        .available-item.dragging {
            opacity: 0.5;
        }

        .available-item img {
            width: 28px;
            height: 28px;
            object-fit: contain;
        }

        .available-item .count {
            margin-left: auto;
            font-weight: 600;
            color: #ffffff;
            font-size: 14px;
        }

        .available-item .count.zero {
            color: #818384;
        }
        
        .placement-tooltip {
            position: fixed;
            background: #3a3a3c;
            border: 1px solid #565758;
            border-radius: 6px;
            padding: 12px;
            color: #ffffff;
            font-size: 13px;
            max-width: 300px;
            z-index: 10002;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            line-height: 1.5;
        }
        
        .placement-tooltip h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: 700;
            color: #ffffff;
        }
        
        .placement-tooltip .requirement-section {
            margin-bottom: 8px;
        }
        
        .placement-tooltip .requirement-section:last-child {
            margin-bottom: 0;
        }
        
        .placement-tooltip .requirement-label {
            font-weight: 600;
            color: #818384;
        }
        
        .placement-tooltip .requirement-value {
            color: #ffffff;
        }
        
        .placement-tooltip .resource-images {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }
        
        .placement-tooltip .resource-tooltip-icon {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .hex-tooltip {
            position: fixed;
            background: #2a2a2c;
            border: 1px solid #565758;
            border-radius: 6px;
            padding: 12px;
            color: #ffffff;
            font-size: 13px;
            max-width: 300px;
            z-index: 10003;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            line-height: 1.5;
            opacity: 0;
            transition: opacity 0.15s ease-in;
        }

        .hex-tooltip.visible {
            opacity: 1;
        }

        .hex-tooltip.instant-hide {
            transition: none;
            opacity: 0;
        }

        .hex-tooltip h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: 700;
            color: #ffffff;
        }

        .hex-tooltip .tooltip-section {
            margin-bottom: 8px;
        }

        .hex-tooltip .tooltip-section:last-child {
            margin-bottom: 0;
        }

        .hex-tooltip .tooltip-label {
            font-weight: 600;
            color: #818384;
        }

        .hex-tooltip .tooltip-value {
            color: #ffffff;
        }

        .hex-tooltip .adjacency-source {
            margin: 4px 0;
            padding-left: 12px;
        }

        .hex-tooltip .tooltip-icons {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .hex-tooltip .tooltip-icon {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .map-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 24px;
            overflow: hidden;
            position: relative;
            background: #121213;
        }
        
        .reset-button {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 10px 20px;
            background: #7b4040;
            color: #d4a5a5;
            border: 1px solid #8b5050;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.1s;
            z-index: 1000;
        }
        
        .reset-button:hover:not(:disabled) {
            background: #8b5050;
            color: #e0b0b0;
        }
        
        .reset-button:active:not(:disabled) {
            background: #6a3030;
        }
        
        .reset-button:disabled {
            background: #3a3a3c;
            color: #818384;
            border: 1px solid #565758;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .map-transform-wrapper {
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            will-change: transform;
        }

        .map-container.dragging .map-transform-wrapper {
            transition: none;
        }

        .hex-grid {
            display: grid;
            gap: 0;
            line-height: 0;
        }

        .hex-row {
            display: flex;
            gap: 0;
            margin-bottom: -26px;
        }

        .hex-row.offset {
            margin-left: 36px;
        }

        .hex {
            width: 80px;
            height: 92.376px;
            position: relative;
            cursor: pointer;
            margin: 0;
            margin-right: -8px;
        }

        .hex.not-rightmost-column {
            clip-path: polygon(0% 0%, calc(100% - 5px) 0%, calc(100% - 5px) 100%, 0% 100%);
        }

        .hex.drag-over {
            outline: 2px solid #4a90e2;
            outline-offset: -2px;
        }

        .hex.valid-placement::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            background-image: url('assets/game_ui/Green_Hex.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.4;
            z-index: 100;
            pointer-events: none;
        }

        .hex.invalid-placement::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            background-image: url('assets/game_ui/Red_Hex.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.4;
            z-index: 100;
            pointer-events: none;
        }

        .hex-shape {
            width: 100%;
            height: 100%;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background: transparent;
            border: none;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 15;
        }

        .hex-base {
            width: 100%;
            height: 100%;
            object-fit: cover;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .hex-feature {
            width: 70%;
            height: 70%;
            object-fit: contain;
            position: absolute;
            top: 15%;
            left: 15%;
            z-index: 2;
        }

        .hex-resource {
            height: 40px;
            object-fit: contain;
            position: absolute;
            bottom: 8px;
            right: 20px;
            z-index: 3;
            filter: drop-shadow(0 1px 3px rgba(0,0,0,0.3));
        }

        .hex-district {
            width: 90%;
            height: 90%;
            object-fit: cover;
            position: absolute;
            top: 5%;
            left: calc(5% - 1px);
            z-index: 25000000;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
            cursor: grab;
        }
        
        .hex-district:hover {
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
        }
        
        .hex-district:active {
            cursor: grabbing;
        }
        
        .hex-district.dragging {
            opacity: 0.6;
        }

        .hex-improvement {
            width: 50%;
            height: 50%;
            object-fit: contain;
            position: absolute;
            bottom: calc(15% + 12px);
            left: calc(15% + 7px);
            z-index: 5;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
            cursor: grab;
        }
        
        .hex-improvement:hover {
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
        }
        
        
        .hex-improvement:active {
            cursor: grabbing;
        }

        .hex-improvement.has-resource {
            bottom: calc(15% + 25px);
        }

        .hex-wonder {
            width: 80%;
            height: 80%;
            object-fit: contain;
            position: absolute;
            top: 10%;
            left: 10%;
            z-index: 6;
            filter: drop-shadow(0 2px 6px rgba(255,215,0,0.6));
        }

        .hex-rivers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            overflow: visible;
        }

        .river-edge-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
            z-index: 21;
        }

        .adjacency-indicator {
            position: absolute;
            top: 70%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(58, 58, 60, 0.95);
            border: 1px solid #565758;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: 600;
            z-index: 25000001;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 1px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .yield-badge {
            display: flex;
            align-items: center;
            gap: 1px;
        }

        .yield-icon {
            width: 12px;
            height: 12px;
            object-fit: contain;
        }

        .yield-amount {
            color: #ffffff;
            font-size: 8px;
            line-height: 1;
        }

        .adjacency-preview {
            position: absolute;
            top: 70%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(58, 58, 60, 0.95);
            border: 1px solid #565758;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: 600;
            z-index: 25000001;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 1px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .score-panel {
            position: absolute;
            top: 24px;
            right: 24px;
            background: #3a3a3c;
            border: 1px solid #565758;
            border-radius: 8px;
            padding: 16px;
            min-width: 180px;
            z-index: 1001;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .score-panel h3 {
            margin-bottom: 12px;
            color: #ffffff;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            text-align: center;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            font-size: 13px;
            color: #ffffff;
            gap: 8px;
        }
        
        .score-item .yield-icon {
            width: 16px;
            height: 16px;
            object-fit: contain;
        }
        
        .score-item .yield-label {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .score-formula {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #565758;
            font-size: 13px;
            color: #ffffff;
        }

        .score-total {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #565758;
            font-weight: 700;
            font-size: 16px;
            color: #ffffff;
        }
        
        .submit-score-btn {
            width: 100%;
            margin-top: 16px;
            padding: 10px;
            background: #6aaa64;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.1s;
        }
        
        .submit-score-btn:hover {
            background: #5c9a56;
        }
        
        .submit-score-btn:active {
            background: #4d8a46;
        }
        
        .submit-score-btn:disabled {
            background: #3a3a3c;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .leaderboard-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .leaderboard-modal.active {
            display: flex;
        }
        
        .leaderboard-content {
            background: #121213;
            border: 1px solid #565758;
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow: visible;
            color: #ffffff;
            display: flex;
            flex-direction: column;
        }
        
        .leaderboard-content h2 {
            margin: 0 0 16px 0;
            font-size: 24px;
            font-weight: 700;
            text-align: center;
        }
        
        .leaderboard-content .rank-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 16px;
            color: #ffffff;
        }

        .yesterday-best-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .yesterday-best-modal.active {
            display: flex;
        }

        .yesterday-best-content {
            background: #121213;
            border: 1px solid #565758;
            border-radius: 8px;
            padding: 24px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            color: #ffffff;
            text-align: center;
        }

        .yesterday-best-content h2 {
            margin: 0 0 16px 0;
            font-size: 24px;
            font-weight: 700;
            color: #ffffff;
            white-space: nowrap;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            flex-wrap: nowrap;
            text-align: center;
        }
        
        .yesterday-best-content h2 img {
            display: inline-block;
            vertical-align: middle;
            flex-shrink: 0;
            border: none;
            outline: none;
            background: transparent;
        }

        .yesterday-best-content img {
            max-width: 100%;
            max-height: 70vh;
            width: auto;
            height: auto;
            object-fit: contain;
            border: 1px solid #565758;
            border-radius: 4px;
            display: block;
            margin: 0 auto;
        }

        .yesterday-best-content .close-btn {
            margin-top: 16px;
            padding: 8px 16px;
            background: #6aaa64;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .yesterday-best-content .close-btn:hover {
            background: #5c9a56;
        }

        .tutorial-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10001;
            justify-content: center;
            align-items: center;
        }

        .tutorial-modal.active {
            display: flex;
        }

        .tutorial-content {
            background: #121213;
            border: 1px solid #565758;
            border-radius: 8px;
            padding: 32px;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            color: #ffffff;
        }

        .tutorial-content h2 {
            margin: 0 0 20px 0;
            font-size: 28px;
            font-weight: 700;
            color: #ffffff;
            text-align: center;
        }

        .tutorial-content p {
            margin: 12px 0;
            font-size: 16px;
            line-height: 1.6;
        }

        .tutorial-content ul {
            margin: 12px 0;
            padding-left: 24px;
        }

        .tutorial-content li {
            margin: 8px 0;
            font-size: 16px;
            line-height: 1.6;
        }

        .tutorial-content .close-btn {
            margin-top: 24px;
            padding: 10px 20px;
            background: #6aaa64;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            width: 100%;
        }

        .tutorial-content .close-btn:hover {
            background: #5c9a56;
        }
        
        .name-input-section {
            margin-bottom: 20px;
        }
        
        .name-input-section label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .name-input-section input {
            width: 100%;
            padding: 10px;
            background: #3a3a3c;
            color: #ffffff;
            border: 1px solid #565758;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        .name-input-section input:focus {
            outline: none;
            border-color: #818384;
        }
        
        .name-input-section .char-count {
            font-size: 12px;
            color: #818384;
            margin-top: 4px;
            text-align: right;
        }
        
        .leaderboard-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 400px;
            overflow-y: auto;
            flex: 1;
        }

        .leaderboard-list::-webkit-scrollbar {
            width: 8px;
        }

        .leaderboard-list::-webkit-scrollbar-track {
            background: #1a1a1c;
            border-radius: 4px;
        }

        .leaderboard-list::-webkit-scrollbar-thumb {
            background: #565758;
            border-radius: 4px;
        }

        .leaderboard-list::-webkit-scrollbar-thumb:hover {
            background: #818384;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: #3a3a3c;
            border: 1px solid #565758;
            border-radius: 4px;
        }
        
        .leaderboard-item.rank-1 {
            background: #c9b458;
            border-color: #b8a347;
        }
        
        .leaderboard-item .rank {
            font-weight: 700;
            font-size: 16px;
            min-width: 30px;
        }
        
        .leaderboard-item .name {
            flex: 1;
            margin: 0 12px;
            font-size: 14px;
        }
        
        .leaderboard-item .score {
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .leaderboard-item .score-icon {
            width: 16px;
            height: 16px;
            object-fit: contain;
        }
        
        .leaderboard-close-btn {
            width: 100%;
            margin-top: 16px;
            padding: 10px;
            background: #3a3a3c;
            color: #ffffff;
            border: 1px solid #565758;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.1s;
        }
        
        .leaderboard-close-btn:hover {
            background: #565758;
        }
        
        .bug-report-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .bug-report-modal.active {
            display: flex;
        }
        
        .bug-report-content {
            background: #121213;
            border: 1px solid #565758;
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            color: #ffffff;
        }
        
        .bug-report-content h2 {
            margin: 0 0 16px 0;
            font-size: 24px;
            font-weight: 700;
            text-align: center;
        }
        
        .bug-report-content textarea {
            width: 100%;
            min-height: 150px;
            padding: 10px;
            background: #3a3a3c;
            color: #ffffff;
            border: 1px solid #565758;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 0;
            box-sizing: border-box;
        }
        
        .bug-report-content textarea:focus {
            outline: none;
            border-color: #818384;
        }
        
        .bug-report-content textarea::placeholder {
            color: #818384;
        }
        
        .bug-report-message {
            margin-top: 16px;
            margin-bottom: 16px;
            padding: 12px 16px;
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
            display: none;
            border: 1px solid;
            line-height: 1.5;
        }
        
        .bug-report-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 0;
        }
        
        .bug-report-btn {
            padding: 10px 20px;
            background: #3a3a3c;
            color: #ffffff;
            border: 1px solid #565758;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.1s;
        }
        
        .bug-report-btn:hover {
            background: #565758;
        }
        
        .bug-report-btn.submit {
            background: #6aaa64;
            border-color: #6aaa64;
        }
        
        .bug-report-btn.submit:hover {
            background: #5c9a56;
        }
        
        .bug-report-btn.submit:active {
            background: #4d8a46;
        }
        
        .bug-report-btn.submit:disabled {
            background: #3a3a3c;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .bug-report-message.success {
            background: #1a3a1a;
            color: #6aaa64;
            border-color: #6aaa64;
            display: block;
        }
        
        .bug-report-message.error {
            background: #3a1a1a;
            color: #d32f2f;
            border-color: #d32f2f;
            display: block;
        }
        
        .countdown-section {
            margin-top: 20px;
            padding: 12px;
            background: #1a1a1c;
            border: 1px solid #565758;
            border-radius: 4px;
            text-align: center;
            display: none;
        }
        
        .countdown-section.visible {
            display: block;
        }
        
        .countdown-label {
            font-size: 12px;
            color: #818384;
            margin-bottom: 6px;
        }
        
        .countdown-time {
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
        }

        .zoom-controls {
            position: absolute;
            top: 24px;
            left: 24px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 1001;
        }

        .help-button {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #3a3a3c;
            border: 1px solid #565758;
            color: #ffffff;
            font-size: 24px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001;
            transition: background 0.1s;
        }

        .help-button:hover {
            background: #565758;
            border-color: #818384;
        }

        .help-button:active {
            background: #4a4a4c;
        }

        .zoom-controls button {
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #3a3a3c;
            border: 1px solid #565758;
            color: #ffffff;
        }

        .zoom-controls button:hover {
            background: #565758;
            border-color: #818384;
        }

        .hex-row:last-child {
            margin-bottom: 0;
        }

        .empty-state {
            text-align: center;
            color: #818384;
            padding: 40px;
        }

        .empty-state h2 {
            margin-bottom: 12px;
            color: #ffffff;
            font-weight: 600;
            font-size: 18px;
        }

        .empty-state p {
            color: #818384;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- Mobile Message -->
    <div id="mobileMessage" class="mobile-message">
        <img src="assets/logo/Logo320x320.png" alt="Civle Logo" style="width: 120px; height: 120px; margin-bottom: 24px; object-fit: contain;">
        <h1>CIVLE</h1>
        <p>Civle is only available on computer. Please visit this site on a desktop or laptop to play.</p>
    </div>

    <div class="header">
        <div class="header-left">
            <img src="assets/logo/Logo320x320.png" alt="Civle Logo" class="header-logo">
            <h1>CIVLE</h1>
            <span id="headerDate" class="header-date"></span>
        </div>
        <div class="header-right">
            <button id="yesterdayBestBtn" class="yesterday-best-btn">Yesterday's Best Setup</button>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div class="empty-state">
                <h2>Loading Today's Challenge...</h2>
                <p>Please wait while we load the daily challenge</p>
            </div>
        </div>

        <div class="map-container" id="mapContainer">
            <div class="empty-state">
                <h2>Loading...</h2>
                <p>Please wait</p>
            </div>
            <button class="reset-button" id="resetButton" style="display: none;">Reset</button>
        </div>
    </div>

    <script>
        // Game state
        let challengeData = null;
        let GRID_WIDTH = 0;
        let GRID_HEIGHT = 0;
        let placedItems = {}; // { "row,col": { type: "district"|"improvement"|"wonder", name: "..." } }
        let availableItems = {}; // { "District_Name": count, "Improvement_Name": count }
        
        // Helper function to get today's date string (YYYY-MM-DD) in EST
        function getTodayDateString() {
            const now = new Date();
            const estDate = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
            const year = estDate.getFullYear();
            const month = String(estDate.getMonth() + 1).padStart(2, '0');
            const day = String(estDate.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // Save game state to localStorage
        function saveGameState() {
            try {
                const today = getTodayDateString();
                const gameState = {
                    date: today,
                    placedItems: placedItems,
                    availableItems: availableItems
                };
                localStorage.setItem('civle_game_state', JSON.stringify(gameState));
            } catch (e) {
                console.error('Failed to save game state:', e);
            }
        }
        
        // Load game state from localStorage (only if it's the same day)
        function loadGameState() {
            try {
                const savedState = localStorage.getItem('civle_game_state');
                if (!savedState) return false;
                
                const gameState = JSON.parse(savedState);
                const today = getTodayDateString();
                
                // Only load if it's from today
                if (gameState.date === today && gameState.placedItems && gameState.availableItems) {
                    placedItems = gameState.placedItems;
                    availableItems = gameState.availableItems;
                    return true;
                } else {
                    // Clear old state if it's a new day
                    localStorage.removeItem('civle_game_state');
                    return false;
                }
            } catch (e) {
                console.error('Failed to load game state:', e);
                return false;
            }
        }
        let adjacencyData = null;
        let placementData = null;
        let resourcesData = null;

        // Zoom and pan state
        let mapZoom = 1.5;
        let mapPanX = 0;
        let mapPanY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartPanX = 0;
        let dragStartPanY = 0;
        let draggedItem = null;
        let draggedDistrict = null; // { row, col, name }
        let draggedImprovement = null; // { row, col, name }
        let draggedWonder = null; // { row, col, name }
        
        // Tooltip state
        let hexTooltip = null;
        let tooltipTimeout = null;
        let currentTooltipRow = null;
        let currentTooltipCol = null;
        let activeSidebarTooltip = null; // Track active sidebar tooltip to ensure only one at a time
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // Touch drag state
        let touchDragState = null; // { type, name, startX, startY, element } for sidebar items
        let touchDragDistrict = null; // { row, col, name, startX, startY, element } for districts
        let touchDragImprovement = null; // { row, col, name, startX, startY, element } for improvements
        let touchDragWonder = null; // { row, col, name, startX, startY, element, dragElement } for wonders

        // Load game data from JSON files
        async function loadGameData() {
            try {
                const [adjacencyResponse, placementResponse, resourcesResponse] = await Promise.all([
                    fetch('../data/adjacency_database.json'),
                    fetch('../data/placement_database.json'),
                    fetch('../data/resources_database.json')
                ]);
                
                if (!adjacencyResponse.ok || !placementResponse.ok || !resourcesResponse.ok) {
                    throw new Error('One or more files could not be loaded');
                }
                
                adjacencyData = await adjacencyResponse.json();
                placementData = await placementResponse.json();
                resourcesData = await resourcesResponse.json();
            } catch (error) {
                console.error('Error loading game data:', error);
                const isCorsError = error.message.includes('Failed to fetch') || 
                                   error.message.includes('CORS') ||
                                   error.name === 'TypeError' ||
                                   window.location.protocol === 'file:';
                
                if (isCorsError || window.location.protocol === 'file:') {
                    alert('CORS Error: Cannot load files when opening HTML directly.\n\n' +
                          'Please run a local web server:\n\n' +
                          'Python 3: python -m http.server 8000\n' +
                          'Python 2: python -m SimpleHTTPServer 8000\n' +
                          'Node.js: npx http-server\n\n' +
                          'Then open http://localhost:8000/public/game.html in your browser.');
                } else {
                    alert('Failed to load game data files. Make sure the data folder contains adjacency_database.json, placement_database.json, and resources_database.json.\n\nError: ' + error.message);
                }
            }
        }

        // Base36 encoding/decoding (same as map maker)
        function toBase36(num) {
            if (num === 0) return '0';
            let result = '';
            while (num > 0) {
                result = (num % 36).toString(36) + result;
                num = Math.floor(num / 36);
            }
            return result;
        }

        function fromBase36(str) {
            return parseInt(str, 36);
        }

        // Terrain, features, and resources data (same as map maker)
        // IMPORTANT: terrainBases and features use index-based encoding in saves - add new items at the END
        const terrainBases = [
            { name: 'Desert', path: 'assets/terrain/base/flat/Desert.webp' },
            { name: 'Grassland', path: 'assets/terrain/base/flat/Grassland.webp' },
            { name: 'Plains', path: 'assets/terrain/base/flat/Plains.webp' },
            { name: 'Snow', path: 'assets/terrain/base/flat/Snow.webp' },
            { name: 'Tundra', path: 'assets/terrain/base/flat/Tundra.webp' },
            { name: 'Desert_Hill', path: 'assets/terrain/base/hills/Desert_Hill.webp' },
            { name: 'Grassland_Hill', path: 'assets/terrain/base/hills/Grassland_Hill.webp' },
            { name: 'Plains_Hill', path: 'assets/terrain/base/hills/Plains_Hill.webp' },
            { name: 'Snow_Hill', path: 'assets/terrain/base/hills/Snow_Hill.webp' },
            { name: 'Tundra_Hills', path: 'assets/terrain/base/hills/Tundra_Hills.webp' },
            { name: 'Desert_Floodplains', path: 'assets/terrain/base/floodplains/Desert_Floodplains.webp' },
            { name: 'Grassland_Floodplains', path: 'assets/terrain/base/floodplains/Grassland_Floodplains.webp' },
            { name: 'Plains_Floodplains', path: 'assets/terrain/base/floodplains/Plains_Floodplains.webp' },
            { name: 'Mountain_Desert', path: 'assets/terrain/base/mountain/Mountain_Desert.webp' },
            { name: 'Mountain_Plains', path: 'assets/terrain/base/mountain/Mountain_Plains.webp' },
            { name: 'Mountain_Snow', path: 'assets/terrain/base/mountain/Mountain_Snow.webp' },
            { name: 'Mountain_Tundra', path: 'assets/terrain/base/mountain/Mountain_Tundra.webp' },
            { name: 'Mountains_Grassland', path: 'assets/terrain/base/mountain/Mountains_Grassland.webp' },
            { name: 'Coast', path: 'assets/terrain/base/water/Coast.webp' },
            { name: 'Ocean', path: 'assets/terrain/base/water/Ocean.webp' },
            { name: 'Reef', path: 'assets/terrain/base/water/Reef.webp' },
            { name: 'Chocolate_Hills', path: 'assets/natural_wonders/Chocolate_Hills.webp' },
            { name: 'Dead_Sea', path: 'assets/natural_wonders/Dead_Sea.webp' },
            { name: 'Delicate_Arch', path: 'assets/natural_wonders/Delicate_Arch.webp' },
            { name: 'Eye_of_the_Sahara', path: 'assets/natural_wonders/Eye_of_the_Sahara.webp' },
            { name: 'Fountain_of_Youth', path: 'assets/natural_wonders/Fountain_of_Youth.webp' },
            { name: 'Gobustan', path: 'assets/natural_wonders/Gobustan.webp' },
            { name: 'Great_Barrier_Reef', path: 'assets/natural_wonders/Great_Barrier_Reef.webp' },
            { name: 'Ik-kil', path: 'assets/natural_wonders/Ik-kil.webp' },
            { name: 'Mato_Tipila', path: 'assets/natural_wonders/Mato_Tipila.webp' },
            { name: 'Matterhorn', path: 'assets/natural_wonders/Matterhorn.webp' },
            { name: 'Mount_Kilimanjaro', path: 'assets/natural_wonders/Mount_Kilimanjaro.webp' },
            { name: 'Tsingy_de_Bemaraha', path: 'assets/natural_wonders/Tsingy_de_Bemaraha.webp' }
        ];

        // Features use index-based encoding - add new features at the END
        const features = [
            { name: 'Woods', path: 'assets/terrain/features/Woods.webp' },
            { name: 'Rainforest', path: 'assets/terrain/features/Rainforest.webp' },
            { name: 'Marsh', path: 'assets/terrain/features/Marsh.webp' },
            { name: 'Geothermal_Fissure', path: 'assets/terrain/features/Geothermal_Fissure.webp' }
        ];

        // IMPORTANT: Order matters for save file compatibility! Tile resources use index-based encoding.
        // Always add new resources at the END to avoid breaking old challenge files.
        const resources = [
            'Aluminum', 'Amber', 'Bananas', 'Cattle', 'Citrus', 'Coal', 'Cocoa', 'Coffee',
            'Copper', 'Cotton', 'Crabs', 'Deer', 'Diamonds', 'Dyes', 'Fish', 'Furs',
            'Gypsum', 'Honey', 'Horses', 'Incense', 'Ivory', 'Jade', 'Maize', 'Marble',
            'Mercury', 'Niter', 'Oil', 'Olives', 'Pearls', 'Rice', 'Salt', 'Sheep',
            'Silk', 'Silver', 'Spices', 'Stone', 'Sugar', 'Tea', 'Tobacco', 'Truffles',
            'Turtles', 'Uranium', 'Whales', 'Wheat', 'Wine', 'Iron'
        ];

        // Natural wonder terrains (for Holy Site adjacency) - derived from terrainBases
        const NATURAL_WONDER_TERRAINS = new Set(terrainBases.filter(t => t.path.includes('natural_wonders')).map(t => t.name));

        // Create lookup maps
        const terrainIndexMap = new Map();
        terrainBases.forEach((t, i) => terrainIndexMap.set(t.name, i));
        const terrainNameMap = new Map();
        terrainBases.forEach((t, i) => terrainNameMap.set(i, t));

        const featureIndexMap = new Map();
        features.forEach((f, i) => featureIndexMap.set(f.name, i));
        const featureNameMap = new Map();
        features.forEach((f, i) => featureNameMap.set(i, f));

        const resourceIndexMap = new Map();
        resources.forEach((r, i) => resourceIndexMap.set(r, i));
        const resourceNameMap = new Map();
        resources.forEach((r, i) => resourceNameMap.set(i, r));

        // River edge images
        const riverEdgeImages = {
            0: 'Top_Right',
            1: 'Right',
            2: 'Bottom_Right',
            3: 'Bottom_Left',
            4: 'Left',
            5: 'Top_Left'
        };

        function loadChallenge(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Clear saved game state when uploading a new challenge
            localStorage.removeItem('civle_game_state');

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = e.target.result;
                    
                    if (data.startsWith('CIV1')) {
                        // New optimized format
                        const width = data.charCodeAt(4) - 48;
                        const height = data.charCodeAt(5) - 48;
                        
                        GRID_WIDTH = width;
                        GRID_HEIGHT = height;
                        
                        challengeData = {
                            width: width,
                            height: height,
                            tiles: {},
                            allocations: {
                                districts: {},
                                improvements: {},
                                wonders: {}
                            }
                        };
                        
                        const tilesData = data.substring(7);
                        const parts = tilesData.split('||');
                        const tilesStr = parts[0];
                        
                        if (tilesStr) {
                            const tiles = tilesStr.split('|');
                            tiles.forEach(tileStr => {
                                if (!tileStr) return;
                                const [pos, data] = tileStr.split(':');
                                if (!pos || !data) return;
                                
                                const [rowStr, colStr] = pos.split(',');
                                const row = parseInt(rowStr);
                                const col = parseInt(colStr);
                                
                                const dataParts = data.split(';');
                                let mainData = dataParts[0];
                                
                                let tStr = '';
                                let fStr = '';
                                let rStr = '';
                                
                                if (mainData.includes(',') && mainData.split(',').length >= 3) {
                                    const fields = mainData.split(',');
                                    tStr = fields[0] || '.';
                                    fStr = fields[1] || '.';
                                    rStr = fields[2] || '.';
                                } else {
                                    tStr = mainData[0] || '.';
                                    fStr = mainData[1] || '.';
                                    rStr = mainData[2] || '.';
                                }
                                
                                const key = `${row},${col}`;
                                challengeData.tiles[key] = {};
                                
                                if (tStr && tStr !== '.') {
                                    const tIdx = fromBase36(tStr) - 1;
                                    const terrain = terrainNameMap.get(tIdx);
                                    if (terrain) {
                                        challengeData.tiles[key].terrain = terrain.name;
                                        challengeData.tiles[key].terrainPath = terrain.path;
                                    }
                                }
                                
                                if (fStr && fStr !== '.') {
                                    const fIdx = fromBase36(fStr) - 1;
                                    const feature = featureNameMap.get(fIdx);
                                    if (feature) {
                                        challengeData.tiles[key].feature = feature.name;
                                        challengeData.tiles[key].featurePath = feature.path;
                                    }
                                }
                                
                                if (rStr && rStr !== '.') {
                                    const rIdx = fromBase36(rStr) - 1;
                                    const resource = resourceNameMap.get(rIdx);
                                    if (resource) {
                                        challengeData.tiles[key].resource = resource;
                                        challengeData.tiles[key].resourcePath = `assets/recources/${resource}.webp`;
                                    }
                                }
                                
                                if (dataParts.length > 1 && dataParts[1]) {
                                    const riversBin = parseInt(dataParts[1], 36).toString(2).padStart(6, '0');
                                    challengeData.tiles[key].rivers = [];
                                    for (let i = 0; i < 6; i++) {
                                        challengeData.tiles[key].rivers[i] = riversBin[i] === '1';
                                    }
                                }
                            });
                        }
                        
                        // Load allocations
                        const allocationsStr = parts.length > 1 ? parts[1] : null;
                        if (allocationsStr) {
                            const allocations = allocationsStr.split(',');
                            allocations.forEach(allocStr => {
                                if (!allocStr) return;
                                const parts = allocStr.split(':');
                                const type = parts[0];
                                const name = parts[1];
                                
                                if (type === 'd') {
                                    if (parts[2] === 'c') {
                                        challengeData.allocations.districts[name] = true;
                                    } else {
                                        challengeData.allocations.districts[name] = parseInt(parts[2]) || 0;
                                    }
                                } else if (type === 'i') {
                                    challengeData.allocations.improvements[name] = parseInt(parts[2]) || 0;
                                } else if (type === 'w') {
                                    challengeData.allocations.wonders[name] = true;
                                }
                            });
                        }
                    } else {
                        // Old JSON format
                        const loadedData = JSON.parse(data);
                        challengeData = loadedData;
                        GRID_WIDTH = loadedData.width;
                        GRID_HEIGHT = loadedData.height;
                    }
                    
                    // Initialize game
                    placedItems = {};
                    availableItems = {};
                    
                    // Copy allocations to available items
                    Object.keys(challengeData.allocations.districts).forEach(name => {
                        const count = challengeData.allocations.districts[name];
                        if (count === true) {
                            availableItems[name] = 1;
                        } else if (count > 0) {
                            availableItems[name] = count;
                        }
                    });
                    
                    Object.keys(challengeData.allocations.improvements).forEach(name => {
                        const count = challengeData.allocations.improvements[name];
                        if (count > 0) {
                            availableItems[name] = count;
                        }
                    });
                    
                    Object.keys(challengeData.allocations.wonders).forEach(name => {
                        if (challengeData.allocations.wonders[name]) {
                            availableItems[name] = 1;
                        }
                    });
                    
                    // Don't load saved game state when uploading a new challenge (already cleared above)
                    initializeGame();
                } catch (error) {
                    console.error('Error loading challenge:', error);
                    alert('Failed to load challenge file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Load daily challenge from server
        async function loadDailyChallenge() {
            try {
                const response = await fetch('/daily-challenge');
                if (!response.ok) {
                    if (response.status === 404) {
                        console.log('No challenge available for today');
                        // Show message that challenge will be available later
                        const sidebar = document.getElementById('sidebar');
                        if (sidebar) {
                            sidebar.innerHTML = `
                                <div class="empty-state">
                                    <h2>No Challenge Today</h2>
                                    <p>Check back tomorrow for a new challenge!</p>
                                </div>
                            `;
                        }
                        return;
                    }
                    throw new Error('Failed to load daily challenge');
                }
                
                const data = await response.text();
                
                // Parse the challenge data (same logic as loadChallenge)
                if (data.startsWith('CIV1')) {
                    // New optimized format
                    const width = data.charCodeAt(4) - 48;
                    const height = data.charCodeAt(5) - 48;
                    
                    GRID_WIDTH = width;
                    GRID_HEIGHT = height;
                    
                    challengeData = {
                        width: width,
                        height: height,
                        tiles: {},
                        allocations: {
                            districts: {},
                            improvements: {},
                            wonders: {}
                        }
                    };
                    
                    const tilesData = data.substring(7);
                    const parts = tilesData.split('||');
                    const tilesStr = parts[0];
                    
                    if (tilesStr) {
                        const tiles = tilesStr.split('|');
                        tiles.forEach(tileStr => {
                            if (!tileStr) return;
                            const [pos, data] = tileStr.split(':');
                            if (!pos || !data) return;
                            
                            const [rowStr, colStr] = pos.split(',');
                            const row = parseInt(rowStr);
                            const col = parseInt(colStr);
                            
                            const dataParts = data.split(';');
                            let mainData = dataParts[0];
                            
                            let tStr = '';
                            let fStr = '';
                            let rStr = '';
                            
                            if (mainData.includes(',') && mainData.split(',').length >= 3) {
                                const fields = mainData.split(',');
                                tStr = fields[0] || '.';
                                fStr = fields[1] || '.';
                                rStr = fields[2] || '.';
                            } else {
                                tStr = mainData[0] || '.';
                                fStr = mainData[1] || '.';
                                rStr = mainData[2] || '.';
                            }
                            
                            const key = `${row},${col}`;
                            challengeData.tiles[key] = {};
                            
                            if (tStr && tStr !== '.') {
                                const tIdx = fromBase36(tStr) - 1;
                                const terrain = terrainNameMap.get(tIdx);
                                if (terrain) {
                                    challengeData.tiles[key].terrain = terrain.name;
                                    challengeData.tiles[key].terrainPath = terrain.path;
                                }
                            }
                            
                            if (fStr && fStr !== '.') {
                                const fIdx = fromBase36(fStr) - 1;
                                const feature = featureNameMap.get(fIdx);
                                if (feature) {
                                    challengeData.tiles[key].feature = feature.name;
                                    challengeData.tiles[key].featurePath = feature.path;
                                }
                            }
                            
                            if (rStr && rStr !== '.') {
                                const rIdx = fromBase36(rStr) - 1;
                                const resource = resourceNameMap.get(rIdx);
                                if (resource) {
                                    challengeData.tiles[key].resource = resource;
                                    challengeData.tiles[key].resourcePath = `assets/recources/${resource}.webp`;
                                }
                            }
                            
                            if (dataParts.length > 1 && dataParts[1]) {
                                const riversBin = parseInt(dataParts[1], 36).toString(2).padStart(6, '0');
                                challengeData.tiles[key].rivers = [];
                                for (let i = 0; i < 6; i++) {
                                    challengeData.tiles[key].rivers[i] = riversBin[i] === '1';
                                }
                            }
                        });
                    }
                    
                    // Load allocations
                    const allocationsStr = parts.length > 1 ? parts[1] : null;
                    if (allocationsStr) {
                        const allocations = allocationsStr.split(',');
                        allocations.forEach(allocStr => {
                            if (!allocStr) return;
                            const parts = allocStr.split(':');
                            const type = parts[0];
                            const name = parts[1];
                            
                            if (type === 'd') {
                                if (parts[2] === 'c') {
                                    challengeData.allocations.districts[name] = true;
                                } else {
                                    challengeData.allocations.districts[name] = parseInt(parts[2]) || 0;
                                }
                            } else if (type === 'i') {
                                challengeData.allocations.improvements[name] = parseInt(parts[2]) || 0;
                            } else if (type === 'w') {
                                challengeData.allocations.wonders[name] = true;
                            }
                        });
                    }
                } else {
                    // Old JSON format
                    const loadedData = JSON.parse(data);
                    challengeData = loadedData;
                    GRID_WIDTH = loadedData.width;
                    GRID_HEIGHT = loadedData.height;
                }
                
                // Initialize game
                placedItems = {};
                availableItems = {};
                
                // Copy allocations to available items
                Object.keys(challengeData.allocations.districts).forEach(name => {
                    const count = challengeData.allocations.districts[name];
                    if (count === true) {
                        availableItems[name] = 1;
                    } else if (count > 0) {
                        availableItems[name] = count;
                    }
                });
                
                Object.keys(challengeData.allocations.improvements).forEach(name => {
                    const count = challengeData.allocations.improvements[name];
                    if (count > 0) {
                        availableItems[name] = count;
                    }
                });
                
                Object.keys(challengeData.allocations.wonders).forEach(name => {
                    if (challengeData.allocations.wonders[name]) {
                        availableItems[name] = 1;
                    }
                });
                
                // Try to load saved game state (only if same day)
                const loadedState = loadGameState();
                
                initializeGame();
                
                // If we loaded a saved state, update all visuals
                if (loadedState) {
                    // Update visuals for all placed items
                    Object.keys(placedItems).forEach(key => {
                        const [row, col] = key.split(',').map(Number);
                        updateHexVisual(row, col);
                        const neighbors = getNeighbors(row, col);
                        neighbors.forEach(neighbor => {
                            updateHexVisual(neighbor.row, neighbor.col);
                        });
                    });
                    updateAllScores();
                }
            } catch (error) {
                console.error('Error loading daily challenge:', error);
                // Show error message but don't block the UI
                const sidebar = document.getElementById('sidebar');
                if (sidebar) {
                    sidebar.innerHTML = `
                        <div class="empty-state">
                            <h2>Error Loading Challenge</h2>
                            <p>${error.message}</p>
                            <p>You can still load a challenge file manually.</p>
                        </div>
                    `;
                }
            }
        }

        function initializeGame() {
            // Create tooltip element
            if (!hexTooltip) {
                hexTooltip = document.createElement('div');
                hexTooltip.className = 'hex-tooltip';
                hexTooltip.id = 'hexTooltip';
                document.body.appendChild(hexTooltip);
            }
            createHexGrid();
            populateSidebar();
            initMapZoomPan();
            updateAllScores();
            updateResetButton();
        }
        
        function resetGame() {
            if (!challengeData) return;
            
            // Clear all placed items
            placedItems = {};
            
            // Restore available items from challenge allocations
            availableItems = {};
            
            // Copy allocations to available items
            Object.keys(challengeData.allocations.districts).forEach(name => {
                const count = challengeData.allocations.districts[name];
                if (count === true) {
                    availableItems[name] = 1;
                } else if (count > 0) {
                    availableItems[name] = count;
                }
            });
            
            Object.keys(challengeData.allocations.improvements).forEach(name => {
                const count = challengeData.allocations.improvements[name];
                if (count > 0) {
                    availableItems[name] = count;
                }
            });
            
            Object.keys(challengeData.allocations.wonders).forEach(name => {
                if (challengeData.allocations.wonders[name]) {
                    availableItems[name] = 1;
                }
            });
            
            // Update all visuals
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    updateHexVisual(row, col);
                }
            }
            
            updateAllScores();
            populateSidebar();
            
            // Clear saved game state
            localStorage.removeItem('civle_game_state');
            
            // Update reset button state
            updateResetButton();
        }
        
        function updateResetButton() {
            const resetButton = document.getElementById('resetButton');
            if (resetButton) {
                const hasPlacedItems = Object.keys(placedItems).length > 0;
                resetButton.disabled = !hasPlacedItems;
            }
        }

        function createHexGrid() {
            const mapContainer = document.getElementById('mapContainer');
            mapContainer.innerHTML = '';
            
            const mapTransformWrapper = document.createElement('div');
            mapTransformWrapper.className = 'map-transform-wrapper';
            mapTransformWrapper.id = 'mapTransformWrapper';
            
            const grid = document.createElement('div');
            grid.className = 'hex-grid';
            grid.id = 'hexGrid';
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                const hexRow = document.createElement('div');
                hexRow.className = 'hex-row';
                if (row % 2 === 1) {
                    hexRow.classList.add('offset');
                }

                for (let col = 0; col < GRID_WIDTH; col++) {
                    const hex = createHex(row, col);
                    hexRow.appendChild(hex);
                }

                grid.appendChild(hexRow);
            }
            
            mapTransformWrapper.appendChild(grid);
            
            // Create a separate districts layer on top of everything
            const districtsLayer = document.createElement('div');
            districtsLayer.className = 'hex-grid';
            districtsLayer.id = 'districtsLayer';
            districtsLayer.style.position = 'absolute';
            districtsLayer.style.top = '0';
            districtsLayer.style.left = '0';
            districtsLayer.style.pointerEvents = 'none';
            districtsLayer.style.zIndex = '1000';
            
            // Create districts grid structure
            for (let row = 0; row < GRID_HEIGHT; row++) {
                const hexRow = document.createElement('div');
                hexRow.className = 'hex-row';
                if (row % 2 === 1) {
                    hexRow.classList.add('offset');
                }

                for (let col = 0; col < GRID_WIDTH; col++) {
                    const districtHex = document.createElement('div');
                    districtHex.className = 'hex';
                    districtHex.dataset.row = row;
                    districtHex.dataset.col = col;
                    districtHex.style.pointerEvents = 'none';
                    
                    const districtShape = document.createElement('div');
                    districtShape.className = 'hex-shape';
                    districtShape.id = `district-shape-${row}-${col}`;
                    
                    districtHex.appendChild(districtShape);
                    hexRow.appendChild(districtHex);
                }
                
                districtsLayer.appendChild(hexRow);
            }
            
            mapTransformWrapper.appendChild(districtsLayer);
            mapTransformWrapper.style.position = 'relative';
            mapContainer.appendChild(mapTransformWrapper);
            
            // Update visuals for all hexes after they're in the DOM
            // First pass: render everything EXCEPT districts
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    updateHexVisualBase(row, col);
                }
            }
            // Second pass: render districts in separate layer
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    updateHexVisualDistricts(row, col);
                }
            }
            
            // Add score panel
            const scorePanel = document.createElement('div');
            scorePanel.className = 'score-panel';
            scorePanel.id = 'scorePanel';
            mapContainer.appendChild(scorePanel);
            
            // Add zoom controls
            const zoomControls = document.createElement('div');
            zoomControls.className = 'zoom-controls';
            zoomControls.innerHTML = `
                <button id="zoomInBtn" title="Zoom In">+</button>
                <button id="zoomOutBtn" title="Zoom Out"></button>
                <button id="resetZoomBtn" title="Reset Zoom"></button>
            `;
            mapContainer.appendChild(zoomControls);
            
            // Add reset button
            let resetButton = document.getElementById('resetButton');
            if (!resetButton) {
                resetButton = document.createElement('button');
                resetButton.className = 'reset-button';
                resetButton.id = 'resetButton';
                resetButton.textContent = 'Reset';
                resetButton.onclick = resetGame;
                mapContainer.appendChild(resetButton);
            } else {
                // Re-append existing button if it was removed
                resetButton.onclick = resetGame;
                mapContainer.appendChild(resetButton);
            }
            
            // Update reset button state
            updateResetButton();
        }

        function createHex(row, col) {
            const hex = document.createElement('div');
            hex.className = 'hex';
            // Add class if not in rightmost column
            if (col < GRID_WIDTH - 1) {
                hex.classList.add('not-rightmost-column');
            } else {
                hex.classList.add('rightmost-column');
            }
            hex.dataset.row = row;
            hex.dataset.col = col;

            const hexShape = document.createElement('div');
            hexShape.className = 'hex-shape';

            const riversContainer = document.createElement('div');
            riversContainer.className = 'hex-rivers';

            hex.appendChild(hexShape);
            hex.appendChild(riversContainer);

            // Tooltip handlers
            hex.addEventListener('mouseenter', (e) => {
                // Don't show tooltip if dragging
                if (draggedDistrict || draggedImprovement || draggedItem || draggedWonder) {
                    return;
                }
                
                // Clear any existing timeout
                if (tooltipTimeout) {
                    clearTimeout(tooltipTimeout);
                    tooltipTimeout = null;
                }
                
                // Store initial mouse position
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                // Check if we're moving from another tile (tooltip was visible on a different tile)
                const wasOnDifferentTile = currentTooltipRow !== null && 
                                          currentTooltipCol !== null && 
                                          (currentTooltipRow !== row || currentTooltipCol !== col);
                const isTooltipVisible = hexTooltip && hexTooltip.classList.contains('visible');
                
                // If tooltip is visible and we're moving to a different tile, show instantly
                if (isTooltipVisible && wasOnDifferentTile) {
                    // Show tooltip immediately
                    if (hexTooltip) {
                        currentTooltipRow = row;
                        currentTooltipCol = col;
                        const content = formatTooltipContent(row, col);
                        if (content) {
                            hexTooltip.innerHTML = content;
                            // Position tooltip using current mouse position
                            hexTooltip.style.left = (e.clientX + 10) + 'px';
                            hexTooltip.style.top = (e.clientY + 10) + 'px';
                            hexTooltip.classList.add('visible');
                        }
                    }
                } else if (!isTooltipVisible) {
                    // Set timeout to show tooltip after 1 second (only if not already visible)
                    tooltipTimeout = setTimeout(() => {
                        // Double-check we're not dragging before showing
                        if (!draggedDistrict && !draggedImprovement && !draggedItem && !draggedWonder && hexTooltip) {
                            currentTooltipRow = row;
                            currentTooltipCol = col;
                            const content = formatTooltipContent(row, col);
                            if (content) {
                                hexTooltip.innerHTML = content;
                                // Position tooltip using last known mouse position
                                hexTooltip.style.left = (lastMouseX + 10) + 'px';
                                hexTooltip.style.top = (lastMouseY + 10) + 'px';
                                hexTooltip.classList.add('visible');
                            }
                        }
                    }, 1000);
                }
            });
            
            hex.addEventListener('mouseleave', (e) => {
                // Clear timeout if tooltip hasn't shown yet
                if (tooltipTimeout) {
                    clearTimeout(tooltipTimeout);
                    tooltipTimeout = null;
                }
                
                // Check if we're moving to another hex element
                const relatedTarget = e.relatedTarget;
                const isMovingToHex = relatedTarget && (
                    relatedTarget.classList.contains('hex') ||
                    relatedTarget.closest('.hex') !== null
                );
                
                // Only hide tooltip if we're not moving to another hex
                if (!isMovingToHex) {
                    if (hexTooltip) {
                        hexTooltip.classList.remove('visible');
                        currentTooltipRow = null;
                        currentTooltipCol = null;
                    }
                }
            });
            
            hex.addEventListener('mousemove', (e) => {
                // Update last known mouse position
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                // Update tooltip position if it's visible
                if (hexTooltip && hexTooltip.classList.contains('visible') && 
                    currentTooltipRow === row && currentTooltipCol === col) {
                    hexTooltip.style.left = (e.clientX + 10) + 'px';
                    hexTooltip.style.top = (e.clientY + 10) + 'px';
                }
            });

            // Drag and drop handlers
            hex.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                // Don't show blue box when dragging districts - we have red/green highlights instead
            });

            hex.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (draggedItem) {
                    // Dragging from sidebar
                    placeItem(row, col, draggedItem.type, draggedItem.name);
                    draggedItem = null;
                } else if (draggedDistrict) {
                    // Dragging a district to move it
                    const sourceKey = `${draggedDistrict.row},${draggedDistrict.col}`;
                    const targetKey = `${row},${col}`;
                    
                    // If dropping on the same hex, do nothing and clear the dragged state IMMEDIATELY
                    if (sourceKey === targetKey) {
                        // Dropped back on original location - restore opacity first, then clear
                        const draggedImg = document.querySelector(`.hex-district[data-row="${draggedDistrict.row}"][data-col="${draggedDistrict.col}"]`);
                        if (draggedImg) {
                            draggedImg.style.opacity = '1';
                            draggedImg.style.cursor = 'grab';
                        }
                        // Clear IMMEDIATELY before anything else to prevent map container handler from seeing it
                        draggedDistrict = null;
                        // Make sure event doesn't bubble
                        e.stopPropagation();
                        e.preventDefault();
                        return; // Exit early, don't process further
                    } else {
                        const tile = challengeData.tiles[targetKey];
                        const districtName = draggedDistrict.name;
                        const targetDistrict = placedItems[targetKey];
                        
                        // Check if we're swapping with another district of the same type
                        let isSwap = false;
                        if (targetDistrict && 
                            targetDistrict.type === 'district' && 
                            targetDistrict.name === districtName &&
                            districtName !== 'City_Center') {
                            isSwap = canDistrictsSwap(sourceKey, targetKey);
                        }
                        
                        if (isSwap) {
                            // Perform swap: exchange positions and owners
                            const sourceDistrict = placedItems[sourceKey];
                            const targetDistrictOwner = targetDistrict.owner;
                            
                            // Remove both from their current locations
                            delete placedItems[sourceKey];
                            delete placedItems[targetKey];
                            
                            // Place them in swapped positions
                            // First, place source district at target location
                            placedItems[targetKey] = { 
                                type: 'district', 
                                name: districtName
                            };
                            
                            // Then, place target district at source location
                            placedItems[sourceKey] = { 
                                type: 'district', 
                                name: districtName
                            };
                            
                            // Assign ownership for both districts (will use ambiguous owners if applicable)
                            assignDistrictOwnership(targetKey, row, col, districtName, { row: draggedDistrict.row, col: draggedDistrict.col });
                            assignDistrictOwnership(sourceKey, draggedDistrict.row, draggedDistrict.col, districtName, { row, col });
                            
                            // Validate and delete invalid adjacent wonders at both locations
                            validateAndDeleteInvalidWonders(draggedDistrict.row, draggedDistrict.col);
                            validateAndDeleteInvalidWonders(row, col);
                            
                            // Update visuals for both locations and their neighbors
                            updateHexVisual(draggedDistrict.row, draggedDistrict.col);
                            const oldNeighbors = getNeighbors(draggedDistrict.row, draggedDistrict.col);
                            oldNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            updateHexVisual(row, col);
                            const newNeighbors = getNeighbors(row, col);
                            newNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            updateAllScores();
                            populateSidebar();
                            saveGameState();
                            updateResetButton();
                            draggedDistrict = null;
                        } else if (isValidPlacement(row, col, 'district', districtName, tile, { row: draggedDistrict.row, col: draggedDistrict.col })) {
                            // Normal move (not a swap)
                            // Remove from old location (this adds it back to availableItems)
                            const oldKey = `${draggedDistrict.row},${draggedDistrict.col}`;
                            // Get the old owner before removing
                            const oldDistrict = placedItems[oldKey];
                            const oldOwner = oldDistrict ? oldDistrict.owner : null;
                            delete placedItems[oldKey];
                            availableItems[districtName] = (availableItems[districtName] || 0) + 1;
                            
                            // Place at new location (subtract from availableItems to keep count correct)
                            const key = `${row},${col}`;
                            // Remove any existing item at this location
                            if (placedItems[key]) {
                                const oldItem = placedItems[key];
                                availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
                            }
                            placedItems[key] = { type: 'district', name: districtName };
                            
                            // Assign district to a City_Center if it's not a City_Center itself
                            // This allows districts to swap city center owners when moved to a new location
                            // Uses ambiguous ownership if multiple city centers are valid
                            if (districtName !== 'City_Center') {
                                assignDistrictOwnership(key, row, col, districtName, { row: draggedDistrict.row, col: draggedDistrict.col });
                            }
                            
                            availableItems[districtName] = (availableItems[districtName] || 0) - 1;
                            
                            // If a City_Center was moved, reassign ownership of districts it owned
                            // This allows districts to swap to other city centers if they're better positioned
                            if (districtName === 'City_Center') {
                                const districtsToReassign = [];
                                const districtsToDelete = [];
                                
                                // Find all districts that were owned by this City_Center at its old location
                                // Handle both direct owners and ambiguous owners
                                for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                                    if (districtPlaced.type === 'district' && 
                                        districtPlaced.name !== 'City_Center') {
                                        // Check if this district is owned by (or could be owned by) the old city center
                                        if (Array.isArray(districtPlaced.owner)) {
                                            if (districtPlaced.owner.includes(oldKey)) {
                                                districtsToReassign.push(districtKey);
                                            }
                                        } else if (districtPlaced.owner === oldKey) {
                                            districtsToReassign.push(districtKey);
                                        }
                                    }
                                }
                                
                                // Reassign ownership for all districts that were owned by the old city center
                                // This will find the best available city center (could be the moved one or a different one)
                                for (const districtKey of districtsToReassign) {
                                    reassignDistrictOwnership(districtKey);
                                    
                                    const district = placedItems[districtKey];
                                    if (district) {
                                        // If no valid owner was found (district is out of range of all city centers), delete it
                                        if (!district.owner) {
                                            districtsToDelete.push(districtKey);
                                        } else {
                                            // Update visuals for the reassigned district and its neighbors
                                            const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                            updateHexVisual(districtRow, districtCol);
                                            const districtNeighbors = getNeighbors(districtRow, districtCol);
                                            districtNeighbors.forEach(neighbor => {
                                                updateHexVisual(neighbor.row, neighbor.col);
                                            });
                                        }
                                    }
                                }
                                
                                // Delete districts that are out of range of all city centers
                                for (const districtKey of districtsToDelete) {
                                    const district = placedItems[districtKey];
                                    if (district) {
                                        // Add back to available items
                                        availableItems[district.name] = (availableItems[district.name] || 0) + 1;
                                        // Delete the district
                                        delete placedItems[districtKey];
                                        // Update visuals for the deleted district location
                                        const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                        updateHexVisual(districtRow, districtCol);
                                        const districtNeighbors = getNeighbors(districtRow, districtCol);
                                        districtNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                    }
                                }
                                
                                // Also check all districts that might now be better owned by the moved city center
                                // This handles the case where a district was within range of 2 city centers
                                // and the moved city center is now closer
                                for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                                    if (districtPlaced.type === 'district' && 
                                        districtPlaced.name !== 'City_Center' &&
                                        districtPlaced.owner) {
                                        // Check if this district is not already owned by the new city center location
                                        let isOwnedByNewCity = false;
                                        if (Array.isArray(districtPlaced.owner)) {
                                            isOwnedByNewCity = districtPlaced.owner.includes(key);
                                        } else {
                                            isOwnedByNewCity = districtPlaced.owner === key;
                                        }
                                        
                                        if (!isOwnedByNewCity) {
                                            // Reassign to see if the moved city center is now a better owner
                                            reassignDistrictOwnership(districtKey);
                                            
                                            // Update visuals if ownership changed
                                            const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                            updateHexVisual(districtRow, districtCol);
                                            const districtNeighbors = getNeighbors(districtRow, districtCol);
                                            districtNeighbors.forEach(neighbor => {
                                                updateHexVisual(neighbor.row, neighbor.col);
                                            });
                                        }
                                    }
                                }
                                
                                // Check all Aqueducts adjacent to both old and new City_Center locations
                                // Delete any that no longer meet placement requirements
                                const aqueductsToCheck = new Set();
                                
                                // Check neighbors of new location
                                const newCityNeighbors = getNeighbors(row, col);
                                for (const neighbor of newCityNeighbors) {
                                    const neighborKey = `${neighbor.row},${neighbor.col}`;
                                    const neighborPlaced = placedItems[neighborKey];
                                    if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'Aqueduct') {
                                        aqueductsToCheck.add(neighborKey);
                                    }
                                }
                                
                                // Check neighbors of old location
                                const oldCityNeighbors = getNeighbors(draggedDistrict.row, draggedDistrict.col);
                                for (const neighbor of oldCityNeighbors) {
                                    const neighborKey = `${neighbor.row},${neighbor.col}`;
                                    const neighborPlaced = placedItems[neighborKey];
                                    if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'Aqueduct') {
                                        aqueductsToCheck.add(neighborKey);
                                    }
                                }
                                
                                const aqueductsToDelete = [];
                                for (const aqueductKey of aqueductsToCheck) {
                                    const [aqueductRow, aqueductCol] = aqueductKey.split(',').map(Number);
                                    const aqueductTile = challengeData.tiles[aqueductKey];
                                    // Validate this Aqueduct against placement rules
                                    if (!isValidPlacement(aqueductRow, aqueductCol, 'district', 'Aqueduct', aqueductTile)) {
                                        aqueductsToDelete.push(aqueductKey);
                                    }
                                }
                                
                                // Delete Aqueducts that no longer meet requirements
                                for (const aqueductKey of aqueductsToDelete) {
                                    const aqueduct = placedItems[aqueductKey];
                                    if (aqueduct) {
                                        // Add back to available items
                                        availableItems[aqueduct.name] = (availableItems[aqueduct.name] || 0) + 1;
                                        // Delete the Aqueduct
                                        delete placedItems[aqueductKey];
                                        // Update visuals for the deleted Aqueduct location
                                        const [aqueductRow, aqueductCol] = aqueductKey.split(',').map(Number);
                                        updateHexVisual(aqueductRow, aqueductCol);
                                        const aqueductNeighbors = getNeighbors(aqueductRow, aqueductCol);
                                        aqueductNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                    }
                                }
                                
                                // Check all Canals that might be affected by the city center move
                                // A Canal can be valid if it has a city center on one of its opposite tiles
                                // Check all Canals within 4 tiles of both old and new city center locations
                                const canalsToCheck = new Set();
                                
                                // Check all placed items for Canals within range
                                for (const [canalKey, canalPlaced] of Object.entries(placedItems)) {
                                    if (canalPlaced.type === 'district' && canalPlaced.name === 'Canal') {
                                        const [canalRow, canalCol] = canalKey.split(',').map(Number);
                                        
                                        // Check distance to old city center location
                                        const distanceToOld = getHexDistance(canalRow, canalCol, draggedDistrict.row, draggedDistrict.col);
                                        // Check distance to new city center location
                                        const distanceToNew = getHexDistance(canalRow, canalCol, row, col);
                                        
                                        // A city center could be on one of the opposite tiles if it's within 4 tiles
                                        // (water tile is 1 tile away, opposite tiles are 3 tiles from water = 4 tiles from canal)
                                        if (distanceToOld <= 4 || distanceToNew <= 4) {
                                            canalsToCheck.add(canalKey);
                                        }
                                    }
                                }
                                
                                const canalsToDelete = [];
                                for (const canalKey of canalsToCheck) {
                                    const [canalRow, canalCol] = canalKey.split(',').map(Number);
                                    const canalTile = challengeData.tiles[canalKey];
                                    // Validate this Canal against placement rules
                                    if (!isValidPlacement(canalRow, canalCol, 'district', 'Canal', canalTile)) {
                                        canalsToDelete.push(canalKey);
                                    }
                                }
                                
                                // Delete Canals that no longer meet requirements
                                for (const canalKey of canalsToDelete) {
                                    const canal = placedItems[canalKey];
                                    if (canal) {
                                        // Add back to available items
                                        availableItems[canal.name] = (availableItems[canal.name] || 0) + 1;
                                        // Delete the Canal
                                        delete placedItems[canalKey];
                                        // Update visuals for the deleted Canal location
                                        const [canalRow, canalCol] = canalKey.split(',').map(Number);
                                        updateHexVisual(canalRow, canalCol);
                                        const canalNeighbors = getNeighbors(canalRow, canalCol);
                                        canalNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                    }
                                }
                                
                                // Check all Wonders that might be affected by the city center move
                                // Wonders must be within 3 tiles of a city center
                                const wondersToCheck = new Set();
                                
                                // Check all placed items for Wonders
                                for (const [wonderKey, wonderPlaced] of Object.entries(placedItems)) {
                                    if (wonderPlaced.type === 'wonder') {
                                        const [wonderRow, wonderCol] = wonderKey.split(',').map(Number);
                                        
                                        // Check distance to old city center location
                                        const distanceToOld = getHexDistance(wonderRow, wonderCol, draggedDistrict.row, draggedDistrict.col);
                                        // Check distance to new city center location
                                        const distanceToNew = getHexDistance(wonderRow, wonderCol, row, col);
                                        
                                        // If the wonder was within 3 tiles of the old location or new location, check it
                                        if (distanceToOld <= 3 || distanceToNew <= 3) {
                                            wondersToCheck.add(wonderKey);
                                        }
                                    }
                                }
                                
                                // Also check all wonders to see if they're still within range of any city center
                                for (const [wonderKey, wonderPlaced] of Object.entries(placedItems)) {
                                    if (wonderPlaced.type === 'wonder') {
                                        wondersToCheck.add(wonderKey);
                                    }
                                }
                                
                                const wondersToDelete = [];
                                for (const wonderKey of wondersToCheck) {
                                    const [wonderRow, wonderCol] = wonderKey.split(',').map(Number);
                                    const wonder = placedItems[wonderKey];
                                    if (wonder) {
                                        const wonderTile = challengeData.tiles[wonderKey];
                                        // Validate this Wonder against placement rules
                                        if (!isValidPlacement(wonderRow, wonderCol, 'wonder', wonder.name, wonderTile)) {
                                            wondersToDelete.push(wonderKey);
                                        }
                                    }
                                }
                                
                                // Delete Wonders that no longer meet requirements
                                for (const wonderKey of wondersToDelete) {
                                    const wonder = placedItems[wonderKey];
                                    if (wonder) {
                                        // Add back to available items
                                        availableItems[wonder.name] = (availableItems[wonder.name] || 0) + 1;
                                        // Delete the Wonder
                                        delete placedItems[wonderKey];
                                        // Update visuals for the deleted Wonder location
                                        const [wonderRow, wonderCol] = wonderKey.split(',').map(Number);
                                        updateHexVisual(wonderRow, wonderCol);
                                        const wonderNeighbors = getNeighbors(wonderRow, wonderCol);
                                        wonderNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                    }
                                }
                            }
                            
                            // Validate and delete invalid adjacent wonders at old location
                            validateAndDeleteInvalidWonders(draggedDistrict.row, draggedDistrict.col);
                            
                            // Validate and delete invalid adjacent wonders at new location
                            validateAndDeleteInvalidWonders(row, col);
                            
                            // Update visuals for old location and its neighbors
                            updateHexVisual(draggedDistrict.row, draggedDistrict.col);
                            const oldNeighbors = getNeighbors(draggedDistrict.row, draggedDistrict.col);
                            oldNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            // Update visuals for new location and its neighbors
                            updateHexVisual(row, col);
                            const newNeighbors = getNeighbors(row, col);
                            newNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            updateAllScores();
                            populateSidebar();
                            saveGameState();
                            updateResetButton();
                            // Clear draggedDistrict on successful move
                            draggedDistrict = null;
                        } else {
                            // Invalid placement - district stays in original location
                            // draggedDistrict will be cleared in dragend
                        }
                    }
                } else if (draggedImprovement) {
                    // Dragging an improvement to move it
                    const sourceKey = `${draggedImprovement.row},${draggedImprovement.col}`;
                    const targetKey = `${row},${col}`;
                    
                    // If dropping on the same hex, do nothing and clear the dragged state
                    if (sourceKey === targetKey) {
                        // Dropped back on original location - restore opacity first, then clear
                        const draggedImg = document.querySelector(`.hex-improvement[data-row="${draggedImprovement.row}"][data-col="${draggedImprovement.col}"]`);
                        if (draggedImg) {
                            draggedImg.style.opacity = '1';
                            draggedImg.style.cursor = 'grab';
                        }
                        // Clear immediately to prevent map container drop handler from deleting it
                        draggedImprovement = null;
                        e.stopPropagation(); // Prevent event from bubbling to map container
                        return; // Exit early, don't process further
                    } else {
                        const tile = challengeData.tiles[targetKey];
                        const improvementName = draggedImprovement.name;
                        
                        // Check if valid placement
                        if (isValidPlacement(row, col, 'improvement', improvementName, tile)) {
                            // Remove from old location (this adds it back to availableItems)
                            const oldKey = `${draggedImprovement.row},${draggedImprovement.col}`;
                            delete placedItems[oldKey];
                            availableItems[improvementName] = (availableItems[improvementName] || 0) + 1;
                            
                            // Place at new location (subtract from availableItems to keep count correct)
                            const key = `${row},${col}`;
                            // Remove any existing item at this location
                            if (placedItems[key]) {
                                const oldItem = placedItems[key];
                                availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
                            }
                            placedItems[key] = { type: 'improvement', name: improvementName };
                            availableItems[improvementName] = (availableItems[improvementName] || 0) - 1;
                            
                            // Validate and delete invalid adjacent wonders at old location
                            validateAndDeleteInvalidWonders(draggedImprovement.row, draggedImprovement.col);
                            
                            // Validate and delete invalid adjacent wonders at new location
                            validateAndDeleteInvalidWonders(row, col);
                            
                            // Update visuals for old location and its neighbors (to update adjacent district adjacencies)
                            updateHexVisual(draggedImprovement.row, draggedImprovement.col);
                            const oldNeighbors = getNeighbors(draggedImprovement.row, draggedImprovement.col);
                            oldNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            // Update visuals for new location and its neighbors (to update adjacent district adjacencies)
                            updateHexVisual(row, col);
                            const newNeighbors = getNeighbors(row, col);
                            newNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            updateAllScores();
                            populateSidebar();
                            saveGameState();
                            updateResetButton();
                            // Clear draggedImprovement on successful move
                            draggedImprovement = null;
                        } else {
                            // Invalid placement - improvement stays in original location
                            // draggedImprovement will be cleared in dragend
                        }
                    }
                } else if (draggedWonder) {
                    // Dragging a wonder to move it
                    const sourceKey = `${draggedWonder.row},${draggedWonder.col}`;
                    const targetKey = `${row},${col}`;
                    
                    // If dropping on the same hex, do nothing and clear the dragged state
                    if (sourceKey === targetKey) {
                        // Dropped back on original location - restore opacity first, then clear
                        const draggedImg = document.querySelector(`.hex-wonder[data-row="${draggedWonder.row}"][data-col="${draggedWonder.col}"]`);
                        if (draggedImg) {
                            draggedImg.style.opacity = '1';
                            draggedImg.style.cursor = 'grab';
                        }
                        // Clear immediately to prevent map container drop handler from deleting it
                        draggedWonder = null;
                        e.stopPropagation(); // Prevent event from bubbling to map container
                        return; // Exit early, don't process further
                    } else {
                        const tile = challengeData.tiles[targetKey];
                        const wonderName = draggedWonder.name;
                        
                        // Check if valid placement
                        if (isValidPlacement(row, col, 'wonder', wonderName, tile, { row: draggedWonder.row, col: draggedWonder.col })) {
                            // Remove from old location (this adds it back to availableItems)
                            const oldKey = `${draggedWonder.row},${draggedWonder.col}`;
                            delete placedItems[oldKey];
                            availableItems[wonderName] = (availableItems[wonderName] || 0) + 1;
                            
                            // Place at new location (subtract from availableItems to keep count correct)
                            const key = `${row},${col}`;
                            // Remove any existing item at this location
                            if (placedItems[key]) {
                                const oldItem = placedItems[key];
                                availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
                            }
                            placedItems[key] = { type: 'wonder', name: wonderName };
                            availableItems[wonderName] = (availableItems[wonderName] || 0) - 1;
                            
                            // Update visuals for old location and its neighbors
                            updateHexVisual(draggedWonder.row, draggedWonder.col);
                            const oldNeighbors = getNeighbors(draggedWonder.row, draggedWonder.col);
                            oldNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            // Update visuals for new location and its neighbors
                            updateHexVisual(row, col);
                            const newNeighbors = getNeighbors(row, col);
                            newNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            updateAllScores();
                            populateSidebar();
                            saveGameState();
                            updateResetButton();
                            // Clear draggedWonder on successful move
                            draggedWonder = null;
                        } else {
                            // Invalid placement - wonder stays in original location
                            // draggedWonder will be cleared in dragend
                        }
                    }
                }
            });

            // Right-click to remove item
            hex.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                removeItem(row, col);
            });

            return hex;
        }

        function updateHexVisualBase(row, col) {
            const hexGrid = document.getElementById('hexGrid');
            if (!hexGrid) return;
            const hex = hexGrid.querySelector(`.hex[data-row="${row}"][data-col="${col}"]`);
            if (!hex) return;

            const hexShape = hex.querySelector('.hex-shape');
            if (!hexShape) return;

            // Remove existing images
            hexShape.querySelectorAll('img').forEach(el => el.remove());
            hexShape.querySelectorAll('.adjacency-indicator').forEach(el => el.remove());

            const key = `${row},${col}`;
            const tile = challengeData.tiles[key];
            const placed = placedItems[key];

            // Always add Blank.webp as base
            const blankImg = document.createElement('img');
            blankImg.className = 'hex-base';
            blankImg.src = 'assets/terrain/base/other/Blank.webp';
            blankImg.alt = 'Blank';
            blankImg.draggable = false;
            hexShape.appendChild(blankImg);

            if (tile) {
                if (tile.terrainPath) {
                    blankImg.src = tile.terrainPath;
                    blankImg.alt = tile.terrain;
                }
                if (tile.featurePath) {
                    const img = document.createElement('img');
                    img.className = 'hex-feature';
                    img.src = tile.featurePath;
                    img.alt = tile.feature;
                    img.draggable = false;
                    hexShape.appendChild(img);
                }
                if (tile.resourcePath) {
                    const img = document.createElement('img');
                    img.className = 'hex-resource';
                    img.src = tile.resourcePath;
                    img.alt = tile.resource;
                    img.draggable = false;
                    hexShape.appendChild(img);
                }
                
                // Draw river edges
                if (tile.rivers) {
                    const riversContainer = hex.querySelector('.hex-rivers');
                    if (riversContainer) {
                        riversContainer.innerHTML = '';
                        for (let edge = 0; edge < 6; edge++) {
                            if (tile.rivers[edge] === true) {
                                const imageName = riverEdgeImages[edge];
                                if (imageName) {
                                    const img = document.createElement('img');
                                    img.className = 'river-edge-image';
                                    img.src = `assets/terrain/river_edges/${imageName}.png`;
                                    img.alt = `River edge ${edge}`;
                                    img.style.zIndex = (21 + edge);
                                    img.draggable = false;
                                    riversContainer.appendChild(img);
                                }
                            }
                        }
                    }
                }
            }

            // Add placed items (but NOT districts yet - they go last)
            if (placed) {
                if (placed.type === 'improvement') {
                    const img = document.createElement('img');
                    img.className = 'hex-improvement';
                    // If tile has a resource, add class to position improvement higher
                    if (tile && tile.resource) {
                        img.classList.add('has-resource');
                    }
                    img.src = `assets/improvements/${placed.name}.webp`;
                    img.alt = placed.name;
                    img.draggable = true;
                    img.dataset.row = row;
                    img.dataset.col = col;
                    img.style.pointerEvents = 'auto';
                    img.style.cursor = 'grab';
                    
                    // Add tooltip handlers to improvement image
                    img.addEventListener('mouseenter', (e) => {
                        // Don't show tooltip if actually dragging
                        if (draggedImprovement) {
                            return;
                        }
                        
                        // Clear any existing timeout
                        if (tooltipTimeout) {
                            clearTimeout(tooltipTimeout);
                            tooltipTimeout = null;
                        }
                        
                        // Store initial mouse position
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                        
                        // Check if we're moving from another tile
                        const wasOnDifferentTile = currentTooltipRow !== null && 
                                                  currentTooltipCol !== null && 
                                                  (currentTooltipRow !== row || currentTooltipCol !== col);
                        const isTooltipVisible = hexTooltip && hexTooltip.classList.contains('visible');
                        
                        // If tooltip is visible and we're moving to a different tile, show instantly
                        if (isTooltipVisible && wasOnDifferentTile) {
                            if (hexTooltip) {
                                currentTooltipRow = row;
                                currentTooltipCol = col;
                                const content = formatTooltipContent(row, col);
                                if (content) {
                                    hexTooltip.innerHTML = content;
                                    hexTooltip.style.left = (e.clientX + 10) + 'px';
                                    hexTooltip.style.top = (e.clientY + 10) + 'px';
                                    hexTooltip.classList.add('visible');
                                }
                            }
                        } else if (!isTooltipVisible) {
                            // Set timeout to show tooltip after 1 second
                            tooltipTimeout = setTimeout(() => {
                                // Double-check we're not dragging before showing
                                if (!draggedImprovement && hexTooltip) {
                                    currentTooltipRow = row;
                                    currentTooltipCol = col;
                                    const content = formatTooltipContent(row, col);
                                    if (content) {
                                        hexTooltip.innerHTML = content;
                                        hexTooltip.style.left = (lastMouseX + 10) + 'px';
                                        hexTooltip.style.top = (lastMouseY + 10) + 'px';
                                        hexTooltip.classList.add('visible');
                                    }
                                }
                            }, 1000);
                        }
                    });
                    
                    img.addEventListener('mouseleave', (e) => {
                        // Clear timeout if tooltip hasn't shown yet
                        if (tooltipTimeout) {
                            clearTimeout(tooltipTimeout);
                            tooltipTimeout = null;
                        }
                        
                        // Check if we're moving to another hex element or improvement image
                        const relatedTarget = e.relatedTarget;
                        const isMovingToHex = relatedTarget && (
                            relatedTarget.classList.contains('hex') ||
                            relatedTarget.classList.contains('hex-improvement') ||
                            relatedTarget.closest('.hex') !== null
                        );
                        
                        // Only hide tooltip if we're not moving to another hex/improvement
                        if (!isMovingToHex) {
                            if (hexTooltip) {
                                hexTooltip.classList.remove('visible');
                                currentTooltipRow = null;
                                currentTooltipCol = null;
                            }
                        }
                    });
                    
                    img.addEventListener('mousemove', (e) => {
                        // Update last known mouse position
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                        
                        // Update tooltip position if it's visible
                        if (hexTooltip && hexTooltip.classList.contains('visible') && 
                            currentTooltipRow === row && currentTooltipCol === col) {
                            hexTooltip.style.left = (e.clientX + 10) + 'px';
                            hexTooltip.style.top = (e.clientY + 10) + 'px';
                        }
                    });
                    
                    img.addEventListener('dragstart', (e) => {
                        e.stopPropagation();
                        draggedImprovement = { row, col, name: placed.name };
                        
                        // Hide tooltip when dragging starts
                        if (hexTooltip) {
                            hexTooltip.classList.remove('visible');
                            currentTooltipRow = null;
                            currentTooltipCol = null;
                        }
                        // Clear any pending tooltip timeout
                        if (tooltipTimeout) {
                            clearTimeout(tooltipTimeout);
                            tooltipTimeout = null;
                        }
                        
                        // Make the image semi-transparent while dragging
                        img.style.opacity = '0.5';
                        img.style.cursor = 'grabbing';
                        
                        // Create a custom drag image (opaque version)
                        const dragImg = document.createElement('img');
                        dragImg.src = img.src;
                        dragImg.style.width = '64px';
                        dragImg.style.height = '64px';
                        dragImg.style.position = 'absolute';
                        dragImg.style.top = '-1000px';
                        dragImg.style.opacity = '1';
                        document.body.appendChild(dragImg);
                        
                        // Set drag image - use the center of the 64x64 image
                        if (dragImg.complete && dragImg.naturalWidth > 0) {
                            e.dataTransfer.setDragImage(dragImg, 32, 32);
                            setTimeout(() => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            }, 0);
                        } else {
                            dragImg.onload = () => {
                                e.dataTransfer.setDragImage(dragImg, 32, 32);
                                setTimeout(() => {
                                    if (dragImg.parentNode) {
                                        document.body.removeChild(dragImg);
                                    }
                                }, 0);
                            };
                            dragImg.onerror = () => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            };
                        }
                        
                        e.dataTransfer.effectAllowed = 'move';
                        // Show red/green highlights just like dragging from sidebar
                        // Skip availability check since we're moving an already-placed improvement
                        highlightAllTiles('improvement', placed.name, true);
                    });
                    
                    img.addEventListener('dragend', (e) => {
                        e.stopPropagation();
                        
                        // Clear all highlights
                        clearAllHighlights();
                        
                        // Restore opacity if improvement wasn't moved (drop failed or cancelled)
                        if (draggedImprovement) {
                            const draggedImg = document.querySelector(`.hex-improvement[data-row="${draggedImprovement.row}"][data-col="${draggedImprovement.col}"]`);
                            if (draggedImg) {
                                draggedImg.style.opacity = '1';
                                draggedImg.style.cursor = 'grab';
                            }
                            // Clear if not already cleared by successful drop
                            setTimeout(() => {
                                if (draggedImprovement) {
                                    draggedImprovement = null;
                                }
                            }, 100);
                        }
                });
                
                // Touch support for dragging improvements
                img.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    
                    // Create a visual element that follows the touch (same approach as regular drag)
                    const dragElement = new Image();
                    dragElement.src = `assets/improvements/${placed.name}.webp`;
                    dragElement.style.width = '64px';
                    dragElement.style.height = '64px';
                    dragElement.style.opacity = '0.5';
                    dragElement.style.position = 'fixed';
                    dragElement.style.left = (touch.clientX - 32) + 'px';
                    dragElement.style.top = (touch.clientY - 32) + 'px';
                    dragElement.style.pointerEvents = 'none';
                    dragElement.style.zIndex = '99999';
                    document.body.appendChild(dragElement);
                    
                    touchDragImprovement = {
                        row: row,
                        col: col,
                        name: placed.name,
                        startX: touch.clientX,
                        startY: touch.clientY,
                        element: img,
                        dragElement: dragElement
                    };
                    img.style.opacity = '0.5';
                    highlightAllTiles('improvement', placed.name, true);
                    e.preventDefault();
                }, { passive: false });
                
                img.addEventListener('touchmove', (e) => {
                    if (touchDragImprovement && touchDragImprovement.element === img) {
                        const touch = e.touches[0];
                        // Update drag element position
                        if (touchDragImprovement.dragElement) {
                            touchDragImprovement.dragElement.style.left = (touch.clientX - 32) + 'px';
                            touchDragImprovement.dragElement.style.top = (touch.clientY - 32) + 'px';
                        }
                        e.preventDefault();
                    }
                }, { passive: false });
                
                img.addEventListener('touchend', (e) => {
                    if (touchDragImprovement && touchDragImprovement.element === img) {
                        const touch = e.changedTouches[0];
                        const elementAtPoint = document.elementFromPoint(touch.clientX, touch.clientY);
                        const hexElement = elementAtPoint?.closest('.hex');
                        
                        if (hexElement) {
                            const targetRow = parseInt(hexElement.dataset.row);
                            const targetCol = parseInt(hexElement.dataset.col);
                            if (!isNaN(targetRow) && !isNaN(targetCol)) {
                                const sourceKey = `${touchDragImprovement.row},${touchDragImprovement.col}`;
                                const targetKey = `${targetRow},${targetCol}`;
                                
                                // If dropping on the same hex, restore opacity and do nothing
                                if (sourceKey === targetKey) {
                                    // Dropped back on original location - restore opacity
                                    img.style.opacity = '1';
                                    img.style.cursor = 'grab';
                                    
                                    // Remove drag element
                                    if (touchDragImprovement.dragElement && touchDragImprovement.dragElement.parentNode) {
                                        touchDragImprovement.dragElement.parentNode.removeChild(touchDragImprovement.dragElement);
                                    }
                                    
                                    touchDragImprovement = null;
                                    clearAllHighlights();
                                    e.preventDefault();
                                    return;
                                }
                                
                                if (sourceKey !== targetKey) {
                                    const tile = challengeData.tiles[targetKey];
                                    if (isValidPlacement(targetRow, targetCol, 'improvement', touchDragImprovement.name, tile, { row: touchDragImprovement.row, col: touchDragImprovement.col })) {
                                        // Remove from old location
                                        delete placedItems[sourceKey];
                                        availableItems[touchDragImprovement.name] = (availableItems[touchDragImprovement.name] || 0) + 1;
                                        
                                        // Place at new location
                                        if (placedItems[targetKey]) {
                                            const oldItem = placedItems[targetKey];
                                            availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
                                        }
                                        placedItems[targetKey] = { type: 'improvement', name: touchDragImprovement.name };
                                        availableItems[touchDragImprovement.name] = (availableItems[touchDragImprovement.name] || 0) - 1;
                                        
                                        // Validate and delete invalid adjacent wonders at old location
                                        validateAndDeleteInvalidWonders(touchDragImprovement.row, touchDragImprovement.col);
                                        
                                        // Validate and delete invalid adjacent wonders at new location
                                        validateAndDeleteInvalidWonders(targetRow, targetCol);
                                        
                                        updateHexVisual(touchDragImprovement.row, touchDragImprovement.col);
                                        const oldNeighbors = getNeighbors(touchDragImprovement.row, touchDragImprovement.col);
                                        oldNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                        
                                        updateHexVisual(targetRow, targetCol);
                                        const newNeighbors = getNeighbors(targetRow, targetCol);
                                        newNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                        
                                        updateAllScores();
                                        populateSidebar();
                                        saveGameState();
                                        updateResetButton();
                                    }
                                }
                            }
                        } else {
                            // Touch ended outside a hex - delete the item
                            removeItem(touchDragImprovement.row, touchDragImprovement.col);
                            img.style.opacity = '1';
                        }
                        
                        // Remove drag element
                        if (touchDragImprovement.dragElement && touchDragImprovement.dragElement.parentNode) {
                            touchDragImprovement.dragElement.parentNode.removeChild(touchDragImprovement.dragElement);
                        }
                        
                        img.style.opacity = '1';
                        touchDragImprovement = null;
                        clearAllHighlights();
                        e.preventDefault();
                    }
                }, { passive: false });
                
                img.addEventListener('touchcancel', () => {
                    if (touchDragImprovement && touchDragImprovement.element === img) {
                        // Remove drag element
                        if (touchDragImprovement.dragElement && touchDragImprovement.dragElement.parentNode) {
                            touchDragImprovement.dragElement.parentNode.removeChild(touchDragImprovement.dragElement);
                        }
                        img.style.opacity = '1';
                        touchDragImprovement = null;
                        clearAllHighlights();
                    }
                });
                
                // Right-click to delete improvement
                    img.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        removeItem(row, col);
                    });
                    
                    hexShape.appendChild(img);
                } else if (placed.type === 'wonder') {
                    const img = document.createElement('img');
                    img.className = 'hex-wonder';
                    img.src = `assets/wonders/${placed.name}.webp`;
                    img.alt = placed.name;
                    img.draggable = true;
                    img.dataset.row = row;
                    img.dataset.col = col;
                    img.style.pointerEvents = 'auto';
                    img.style.cursor = 'grab';
                    
                    // Add tooltip handlers to wonder image (same as district/improvement)
                    img.addEventListener('mouseenter', (e) => {
                        if (draggedWonder) return;
                        if (tooltipTimeout) {
                            clearTimeout(tooltipTimeout);
                            tooltipTimeout = null;
                        }
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                        const wasOnDifferentTile = currentTooltipRow !== null && currentTooltipCol !== null &&
                            (currentTooltipRow !== row || currentTooltipCol !== col);
                        const isTooltipVisible = hexTooltip && hexTooltip.classList.contains('visible');
                        if (isTooltipVisible && wasOnDifferentTile) {
                            if (hexTooltip) {
                                currentTooltipRow = row;
                                currentTooltipCol = col;
                                const content = formatTooltipContent(row, col);
                                if (content) {
                                    hexTooltip.innerHTML = content;
                                    hexTooltip.style.left = (e.clientX + 10) + 'px';
                                    hexTooltip.style.top = (e.clientY + 10) + 'px';
                                    hexTooltip.classList.add('visible');
                                }
                            }
                        } else if (!isTooltipVisible) {
                            tooltipTimeout = setTimeout(() => {
                                if (!draggedWonder && hexTooltip) {
                                    currentTooltipRow = row;
                                    currentTooltipCol = col;
                                    const content = formatTooltipContent(row, col);
                                    if (content) {
                                        hexTooltip.innerHTML = content;
                                        hexTooltip.style.left = (lastMouseX + 10) + 'px';
                                        hexTooltip.style.top = (lastMouseY + 10) + 'px';
                                        hexTooltip.classList.add('visible');
                                    }
                                }
                            }, 1000);
                        }
                    });
                    
                    img.addEventListener('mouseleave', (e) => {
                        if (tooltipTimeout) {
                            clearTimeout(tooltipTimeout);
                            tooltipTimeout = null;
                        }
                        const relatedTarget = e.relatedTarget;
                        const isMovingToHex = relatedTarget && (
                            relatedTarget.classList.contains('hex') ||
                            relatedTarget.classList.contains('hex-wonder') ||
                            relatedTarget.closest('.hex') !== null
                        );
                        if (!isMovingToHex) {
                            if (hexTooltip) {
                                hexTooltip.classList.remove('visible');
                                currentTooltipRow = null;
                                currentTooltipCol = null;
                            }
                        }
                    });
                    
                    img.addEventListener('mousemove', (e) => {
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                        if (hexTooltip && hexTooltip.classList.contains('visible') &&
                            currentTooltipRow === row && currentTooltipCol === col) {
                            hexTooltip.style.left = (e.clientX + 10) + 'px';
                            hexTooltip.style.top = (e.clientY + 10) + 'px';
                        }
                    });
                    
                    // Add drag handlers for wonders
                    img.addEventListener('dragstart', (e) => {
                        draggedWonder = { row, col, name: placed.name };
                        img.style.opacity = '0.5';
                        img.style.cursor = 'grabbing';
                        e.stopPropagation();
                        
                        // Hide tooltip when dragging starts
                        if (hexTooltip) {
                            hexTooltip.classList.remove('visible');
                            currentTooltipRow = null;
                            currentTooltipCol = null;
                        }
                        if (tooltipTimeout) {
                            clearTimeout(tooltipTimeout);
                            tooltipTimeout = null;
                        }
                        
                        // Create a custom drag image
                        const dragImg = new Image();
                        dragImg.src = `assets/wonders/${placed.name}.webp`;
                        dragImg.style.width = '64px';
                        dragImg.style.height = '64px';
                        dragImg.style.opacity = '1';
                        dragImg.style.position = 'fixed';
                        dragImg.style.left = '-1000px';
                        dragImg.style.top = '-1000px';
                        dragImg.style.pointerEvents = 'none';
                        document.body.appendChild(dragImg);
                        
                        if (dragImg.complete && dragImg.naturalWidth > 0) {
                            e.dataTransfer.setDragImage(dragImg, 32, 32);
                            setTimeout(() => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            }, 0);
                        } else {
                            dragImg.onload = () => {
                                e.dataTransfer.setDragImage(dragImg, 32, 32);
                                setTimeout(() => {
                                    if (dragImg.parentNode) {
                                        document.body.removeChild(dragImg);
                                    }
                                }, 0);
                            };
                            dragImg.onerror = () => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            };
                        }
                        
                        e.dataTransfer.effectAllowed = 'move';
                        // Show highlights for valid wonder placement
                        highlightAllTiles('wonder', placed.name, true, { row, col });
                    });
                    
                    img.addEventListener('dragend', (e) => {
                        e.stopPropagation();
                        clearAllHighlights();
                        
                        // Restore opacity if wonder wasn't moved
                        if (draggedWonder) {
                            const draggedImg = document.querySelector(`.hex-wonder[data-row="${draggedWonder.row}"][data-col="${draggedWonder.col}"]`);
                            if (draggedImg) {
                                draggedImg.style.opacity = '1';
                                draggedImg.style.cursor = 'grab';
                            }
                            setTimeout(() => {
                                if (draggedWonder) {
                                    draggedWonder = null;
                                }
                            }, 100);
                        }
                    });
                    
                    // Touch support for dragging wonders
                    img.addEventListener('touchstart', (e) => {
                        const touch = e.touches[0];
                        
                        // Create a visual element that follows the touch (same approach as regular drag)
                        const dragElement = new Image();
                        dragElement.src = `assets/wonders/${placed.name}.webp`;
                        dragElement.style.width = '64px';
                        dragElement.style.height = '64px';
                        dragElement.style.opacity = '0.5';
                        dragElement.style.position = 'fixed';
                        dragElement.style.left = (touch.clientX - 32) + 'px';
                        dragElement.style.top = (touch.clientY - 32) + 'px';
                        dragElement.style.pointerEvents = 'none';
                        dragElement.style.zIndex = '99999';
                        document.body.appendChild(dragElement);
                        
                        touchDragWonder = {
                            row: row,
                            col: col,
                            name: placed.name,
                            startX: touch.clientX,
                            startY: touch.clientY,
                            element: img,
                            dragElement: dragElement
                        };
                        img.style.opacity = '0.5';
                        highlightAllTiles('wonder', placed.name, true, { row, col });
                        e.preventDefault();
                    }, { passive: false });
                    
                    img.addEventListener('touchmove', (e) => {
                        if (touchDragWonder && touchDragWonder.element === img) {
                            const touch = e.touches[0];
                            // Update drag element position
                            if (touchDragWonder.dragElement) {
                                touchDragWonder.dragElement.style.left = (touch.clientX - 32) + 'px';
                                touchDragWonder.dragElement.style.top = (touch.clientY - 32) + 'px';
                            }
                            e.preventDefault();
                        }
                    }, { passive: false });
                    
                    img.addEventListener('touchend', (e) => {
                        if (touchDragWonder && touchDragWonder.element === img) {
                            const touch = e.changedTouches[0];
                            const elementAtPoint = document.elementFromPoint(touch.clientX, touch.clientY);
                            const hexElement = elementAtPoint?.closest('.hex');
                            
                            if (hexElement) {
                                const targetRow = parseInt(hexElement.dataset.row);
                                const targetCol = parseInt(hexElement.dataset.col);
                                if (!isNaN(targetRow) && !isNaN(targetCol)) {
                                    // Simulate the drop logic
                                    draggedWonder = { row: touchDragWonder.row, col: touchDragWonder.col, name: touchDragWonder.name };
                                    const sourceKey = `${touchDragWonder.row},${touchDragWonder.col}`;
                                    const targetKey = `${targetRow},${targetCol}`;
                                    
                                    // If dropping on the same hex, restore opacity and do nothing
                                    if (sourceKey === targetKey) {
                                        // Dropped back on original location - restore opacity
                                        img.style.opacity = '1';
                                        img.style.cursor = 'grab';
                                        
                                        // Remove drag element
                                        if (touchDragWonder.dragElement && touchDragWonder.dragElement.parentNode) {
                                            touchDragWonder.dragElement.parentNode.removeChild(touchDragWonder.dragElement);
                                        }
                                        
                                        touchDragWonder = null;
                                        clearAllHighlights();
                                        e.preventDefault();
                                        return;
                                    }
                                    
                                    if (sourceKey !== targetKey) {
                                        const tile = challengeData.tiles[targetKey];
                                        if (isValidPlacement(targetRow, targetCol, 'wonder', touchDragWonder.name, tile, { row: touchDragWonder.row, col: touchDragWonder.col })) {
                                            // Remove from old location
                                            delete placedItems[sourceKey];
                                            availableItems[touchDragWonder.name] = (availableItems[touchDragWonder.name] || 0) + 1;
                                            
                                            // Place at new location
                                            if (placedItems[targetKey]) {
                                                const oldItem = placedItems[targetKey];
                                                availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
                                            }
                                            placedItems[targetKey] = { type: 'wonder', name: touchDragWonder.name };
                                            availableItems[touchDragWonder.name] = (availableItems[touchDragWonder.name] || 0) - 1;
                                            
                                            // Validate and delete invalid adjacent wonders at old location
                                            validateAndDeleteInvalidWonders(touchDragWonder.row, touchDragWonder.col);
                                            
                                            // Validate and delete invalid adjacent wonders at new location
                                            validateAndDeleteInvalidWonders(targetRow, targetCol);
                                            
                                            updateHexVisual(touchDragWonder.row, touchDragWonder.col);
                                            const oldNeighbors = getNeighbors(touchDragWonder.row, touchDragWonder.col);
                                            oldNeighbors.forEach(neighbor => {
                                                updateHexVisual(neighbor.row, neighbor.col);
                                            });
                                            
                                            updateHexVisual(targetRow, targetCol);
                                            const newNeighbors = getNeighbors(targetRow, targetCol);
                                            newNeighbors.forEach(neighbor => {
                                                updateHexVisual(neighbor.row, neighbor.col);
                                            });
                                            
                                            updateAllScores();
                                            populateSidebar();
                                            saveGameState();
                                            updateResetButton();
                                        }
                                    }
                                    
                                    draggedWonder = null;
                                }
                            } else {
                                // Touch ended outside a hex - delete the item
                                removeItem(touchDragWonder.row, touchDragWonder.col);
                                img.style.opacity = '1';
                            }
                            
                            // Remove drag element (if not already removed in same-position case)
                            if (touchDragWonder && touchDragWonder.dragElement && touchDragWonder.dragElement.parentNode) {
                                touchDragWonder.dragElement.parentNode.removeChild(touchDragWonder.dragElement);
                            }
                            
                            touchDragWonder = null;
                            clearAllHighlights();
                            e.preventDefault();
                        }
                    }, { passive: false });
                    
                    img.addEventListener('touchcancel', () => {
                        if (touchDragWonder && touchDragWonder.element === img) {
                            // Remove drag element
                            if (touchDragWonder.dragElement && touchDragWonder.dragElement.parentNode) {
                                touchDragWonder.dragElement.parentNode.removeChild(touchDragWonder.dragElement);
                            }
                            img.style.opacity = '1';
                            touchDragWonder = null;
                            clearAllHighlights();
                        }
                    });
                    
                    // Right-click to delete wonder
                    img.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        removeItem(row, col);
                    });
                    
                    hexShape.appendChild(img);
                }
            }
        }

        function updateHexVisualDistricts(row, col) {
            // Render districts in the separate districts layer
            const districtShape = document.getElementById(`district-shape-${row}-${col}`);
            if (!districtShape) return;

            // Clear existing content
            districtShape.innerHTML = '';

            const key = `${row},${col}`;
            const placed = placedItems[key];

            // Add districts LAST so they appear on top of everything
            if (placed && placed.type === 'district') {
                const img = document.createElement('img');
                img.className = 'hex-district';
                img.src = `assets/districts/${placed.name}.webp`;
                img.alt = placed.name;
                img.draggable = true;
                img.dataset.row = row;
                img.dataset.col = col;
                img.style.pointerEvents = 'auto'; // Allow drag events
                
                // Add tooltip handlers to district image so it works when hovering over the district
                img.addEventListener('mouseenter', (e) => {
                    // Don't show tooltip if actually dragging
                    if (draggedDistrict) {
                        return;
                    }
                    
                    // Clear any existing timeout
                    if (tooltipTimeout) {
                        clearTimeout(tooltipTimeout);
                        tooltipTimeout = null;
                    }
                    
                    // Store initial mouse position
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    
                    // Check if we're moving from another tile
                    const wasOnDifferentTile = currentTooltipRow !== null && 
                                              currentTooltipCol !== null && 
                                              (currentTooltipRow !== row || currentTooltipCol !== col);
                    const isTooltipVisible = hexTooltip && hexTooltip.classList.contains('visible');
                    
                    // If tooltip is visible and we're moving to a different tile, show instantly
                    if (isTooltipVisible && wasOnDifferentTile) {
                        if (hexTooltip) {
                            currentTooltipRow = row;
                            currentTooltipCol = col;
                            const content = formatTooltipContent(row, col);
                            if (content) {
                                hexTooltip.innerHTML = content;
                                hexTooltip.style.left = (e.clientX + 10) + 'px';
                                hexTooltip.style.top = (e.clientY + 10) + 'px';
                                hexTooltip.classList.add('visible');
                            }
                        }
                    } else if (!isTooltipVisible) {
                        // Set timeout to show tooltip after 1 second
                        tooltipTimeout = setTimeout(() => {
                            // Double-check we're not dragging before showing
                            if (!draggedDistrict && hexTooltip) {
                                currentTooltipRow = row;
                                currentTooltipCol = col;
                                const content = formatTooltipContent(row, col);
                                if (content) {
                                    hexTooltip.innerHTML = content;
                                    hexTooltip.style.left = (lastMouseX + 10) + 'px';
                                    hexTooltip.style.top = (lastMouseY + 10) + 'px';
                                    hexTooltip.classList.add('visible');
                                }
                            }
                        }, 1000);
                    }
                });
                
                img.addEventListener('mouseleave', (e) => {
                    // Clear timeout if tooltip hasn't shown yet
                    if (tooltipTimeout) {
                        clearTimeout(tooltipTimeout);
                        tooltipTimeout = null;
                    }
                    
                    // Check if we're moving to another hex element or district image
                    const relatedTarget = e.relatedTarget;
                    const isMovingToHex = relatedTarget && (
                        relatedTarget.classList.contains('hex') ||
                        relatedTarget.classList.contains('hex-district') ||
                        relatedTarget.closest('.hex') !== null
                    );
                    
                    // Only hide tooltip if we're not moving to another hex/district
                    if (!isMovingToHex) {
                        if (hexTooltip) {
                            hexTooltip.classList.remove('visible');
                            currentTooltipRow = null;
                            currentTooltipCol = null;
                        }
                    }
                });
                
                img.addEventListener('mousemove', (e) => {
                    // Update last known mouse position
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    
                    // Update tooltip position if it's visible
                    if (hexTooltip && hexTooltip.classList.contains('visible') && 
                        currentTooltipRow === row && currentTooltipCol === col) {
                        hexTooltip.style.left = (e.clientX + 10) + 'px';
                        hexTooltip.style.top = (e.clientY + 10) + 'px';
                    }
                });
                
                // Add drag handlers for districts
                img.addEventListener('dragstart', (e) => {
                    draggedDistrict = { row, col, name: placed.name };
                    img.style.opacity = '0.5';
                    img.style.cursor = 'grabbing';
                    e.stopPropagation(); // Prevent event from bubbling
                    
                    // Hide tooltip when dragging starts
                    if (hexTooltip) {
                        hexTooltip.classList.remove('visible');
                        currentTooltipRow = null;
                        currentTooltipCol = null;
                    }
                    // Clear any pending tooltip timeout
                    if (tooltipTimeout) {
                        clearTimeout(tooltipTimeout);
                        tooltipTimeout = null;
                    }
                    
                    // Create a custom drag image with an opaque version of the district
                    const dragImg = new Image();
                    dragImg.src = `assets/districts/${placed.name}.webp`;
                    dragImg.style.width = '64px';
                    dragImg.style.height = '64px';
                    dragImg.style.opacity = '1';
                    dragImg.style.position = 'fixed';
                    dragImg.style.left = '-1000px';
                    dragImg.style.top = '-1000px';
                    dragImg.style.pointerEvents = 'none';
                    document.body.appendChild(dragImg);
                    
                    // Set drag image - use the center of the 64x64 image
                    if (dragImg.complete && dragImg.naturalWidth > 0) {
                        e.dataTransfer.setDragImage(dragImg, 32, 32);
                        setTimeout(() => {
                            if (dragImg.parentNode) {
                                document.body.removeChild(dragImg);
                            }
                        }, 0);
                    } else {
                        dragImg.onload = () => {
                            e.dataTransfer.setDragImage(dragImg, 32, 32);
                            setTimeout(() => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            }, 0);
                        };
                        dragImg.onerror = () => {
                            if (dragImg.parentNode) {
                                document.body.removeChild(dragImg);
                            }
                        };
                    }
                    
                    e.dataTransfer.effectAllowed = 'move';
                    // Show red/green highlights just like dragging from sidebar
                    // Skip availability check since we're moving an already-placed district
                    // Exclude the old location from adjacency calculations
                    highlightAllTiles('district', placed.name, true, { row, col });
                });
                
                img.addEventListener('dragend', (e) => {
                    e.stopPropagation();
                    
                    // Clear all highlights
                    clearAllHighlights();
                    
                    // Restore opacity if district wasn't moved (drop failed or cancelled)
                    if (draggedDistrict) {
                        const draggedImg = document.querySelector(`.hex-district[data-row="${draggedDistrict.row}"][data-col="${draggedDistrict.col}"]`);
                        if (draggedImg) {
                            draggedImg.style.opacity = '1';
                            draggedImg.style.cursor = 'grab';
                        }
                        // Clear if not already cleared by successful drop
                        setTimeout(() => {
                            if (draggedDistrict) {
                                draggedDistrict = null;
                            }
                        }, 100);
                    }
                });
                
                // Touch support for dragging districts
                img.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    
                    // Create a visual element that follows the touch (same approach as regular drag)
                    const dragElement = new Image();
                    dragElement.src = `assets/districts/${placed.name}.webp`;
                    dragElement.style.width = '64px';
                    dragElement.style.height = '64px';
                    dragElement.style.opacity = '0.5';
                    dragElement.style.position = 'fixed';
                    dragElement.style.left = (touch.clientX - 32) + 'px';
                    dragElement.style.top = (touch.clientY - 32) + 'px';
                    dragElement.style.pointerEvents = 'none';
                    dragElement.style.zIndex = '99999';
                    document.body.appendChild(dragElement);
                    
                    touchDragDistrict = {
                        row: row,
                        col: col,
                        name: placed.name,
                        startX: touch.clientX,
                        startY: touch.clientY,
                        element: img,
                        dragElement: dragElement
                    };
                    img.style.opacity = '0.5';
                    highlightAllTiles('district', placed.name, true, { row, col });
                    e.preventDefault();
                }, { passive: false });
                
                img.addEventListener('touchmove', (e) => {
                    if (touchDragDistrict && touchDragDistrict.element === img) {
                        const touch = e.touches[0];
                        // Update drag element position
                        if (touchDragDistrict.dragElement) {
                            touchDragDistrict.dragElement.style.left = (touch.clientX - 32) + 'px';
                            touchDragDistrict.dragElement.style.top = (touch.clientY - 32) + 'px';
                        }
                        e.preventDefault();
                    }
                }, { passive: false });
                
                img.addEventListener('touchend', (e) => {
                    if (touchDragDistrict && touchDragDistrict.element === img) {
                        const touch = e.changedTouches[0];
                        const elementAtPoint = document.elementFromPoint(touch.clientX, touch.clientY);
                        const hexElement = elementAtPoint?.closest('.hex');
                        
                        if (hexElement) {
                            const targetRow = parseInt(hexElement.dataset.row);
                            const targetCol = parseInt(hexElement.dataset.col);
                            if (!isNaN(targetRow) && !isNaN(targetCol)) {
                                // Simulate the drop logic from the drop handler
                                draggedDistrict = { row: touchDragDistrict.row, col: touchDragDistrict.col, name: touchDragDistrict.name };
                                const sourceKey = `${touchDragDistrict.row},${touchDragDistrict.col}`;
                                const targetKey = `${targetRow},${targetCol}`;
                                
                                // If dropping on the same hex, restore opacity and do nothing
                                if (sourceKey === targetKey) {
                                    // Dropped back on original location - restore opacity
                                    img.style.opacity = '1';
                                    img.style.cursor = 'grab';
                                    
                                    // Remove drag element
                                    if (touchDragDistrict.dragElement && touchDragDistrict.dragElement.parentNode) {
                                        touchDragDistrict.dragElement.parentNode.removeChild(touchDragDistrict.dragElement);
                                    }
                                    
                                    touchDragDistrict = null;
                                    clearAllHighlights();
                                    e.preventDefault();
                                    return;
                                }
                                
                                if (sourceKey !== targetKey) {
                                    const tile = challengeData.tiles[targetKey];
                                    const districtName = touchDragDistrict.name;
                                    const targetDistrict = placedItems[targetKey];
                                    
                                    // Check if we're swapping with another district of the same type
                                    let isSwap = false;
                                    if (targetDistrict && 
                                        targetDistrict.type === 'district' && 
                                        targetDistrict.name === districtName &&
                                        districtName !== 'City_Center') {
                                        isSwap = canDistrictsSwap(sourceKey, targetKey);
                                    }
                                    
                                    if (isSwap) {
                                        // Perform swap (same logic as drop handler)
                                        const sourceDistrict = placedItems[sourceKey];
                                        const targetDistrictOwner = targetDistrict.owner;
                                        
                                        delete placedItems[sourceKey];
                                        delete placedItems[targetKey];
                                        
                                        placedItems[targetKey] = { type: 'district', name: districtName };
                                        placedItems[sourceKey] = { type: 'district', name: districtName };
                                        
                                        assignDistrictOwnership(targetKey, targetRow, targetCol, districtName, { row: touchDragDistrict.row, col: touchDragDistrict.col });
                                        assignDistrictOwnership(sourceKey, touchDragDistrict.row, touchDragDistrict.col, districtName, { row: targetRow, col: targetCol });
                                        
                                        validateAndDeleteInvalidWonders(touchDragDistrict.row, touchDragDistrict.col);
                                        validateAndDeleteInvalidWonders(targetRow, targetCol);
                                        
                                        updateHexVisual(touchDragDistrict.row, touchDragDistrict.col);
                                        const oldNeighbors = getNeighbors(touchDragDistrict.row, touchDragDistrict.col);
                                        oldNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                        
                                        updateHexVisual(targetRow, targetCol);
                                        const newNeighbors = getNeighbors(targetRow, targetCol);
                                        newNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                        
                                        updateAllScores();
                                        populateSidebar();
                                        saveGameState();
                                        updateResetButton();
                                    } else if (isValidPlacement(targetRow, targetCol, 'district', districtName, tile, { row: touchDragDistrict.row, col: touchDragDistrict.col })) {
                                        // Normal move (same logic as drop handler)
                                        const oldKey = `${touchDragDistrict.row},${touchDragDistrict.col}`;
                                        const oldDistrict = placedItems[oldKey];
                                        const oldOwner = oldDistrict ? oldDistrict.owner : null;
                                        delete placedItems[oldKey];
                                        availableItems[districtName] = (availableItems[districtName] || 0) + 1;
                                        
                                        const key = `${targetRow},${targetCol}`;
                                        if (placedItems[key]) {
                                            const oldItem = placedItems[key];
                                            availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
                                        }
                                        placedItems[key] = { type: 'district', name: districtName };
                                        
                                        if (districtName !== 'City_Center') {
                                            assignDistrictOwnership(key, targetRow, targetCol, districtName, { row: touchDragDistrict.row, col: touchDragDistrict.col });
                                        }
                                        
                                        availableItems[districtName] = (availableItems[districtName] || 0) - 1;
                                        
                                        // If a City_Center was moved, reassign ownership of districts it owned
                                        // This allows districts to swap to other city centers if they're better positioned
                                        if (districtName === 'City_Center') {
                                            const districtsToReassign = [];
                                            const districtsToDelete = [];
                                            
                                            // Find all districts that were owned by this City_Center at its old location
                                            // Handle both direct owners and ambiguous owners
                                            for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                                                if (districtPlaced.type === 'district' && 
                                                    districtPlaced.name !== 'City_Center') {
                                                    // Check if this district is owned by (or could be owned by) the old city center
                                                    if (Array.isArray(districtPlaced.owner)) {
                                                        if (districtPlaced.owner.includes(oldKey)) {
                                                            districtsToReassign.push(districtKey);
                                                        }
                                                    } else if (districtPlaced.owner === oldKey) {
                                                        districtsToReassign.push(districtKey);
                                                    }
                                                }
                                            }
                                            
                                            // Reassign ownership for all districts that were owned by the old city center
                                            // This will find the best available city center (could be the moved one or a different one)
                                            for (const districtKey of districtsToReassign) {
                                                reassignDistrictOwnership(districtKey);
                                                
                                                const district = placedItems[districtKey];
                                                if (district) {
                                                    // If no valid owner was found (district is out of range of all city centers), delete it
                                                    if (!district.owner) {
                                                        districtsToDelete.push(districtKey);
                                                    } else {
                                                        // Update visuals for the reassigned district and its neighbors
                                                        const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                                        updateHexVisual(districtRow, districtCol);
                                                        const districtNeighbors = getNeighbors(districtRow, districtCol);
                                                        districtNeighbors.forEach(neighbor => {
                                                            updateHexVisual(neighbor.row, neighbor.col);
                                                        });
                                                    }
                                                }
                                            }
                                            
                                            // Delete districts that are out of range of all city centers
                                            for (const districtKey of districtsToDelete) {
                                                const district = placedItems[districtKey];
                                                if (district) {
                                                    // Add back to available items
                                                    availableItems[district.name] = (availableItems[district.name] || 0) + 1;
                                                    // Delete the district
                                                    delete placedItems[districtKey];
                                                    // Update visuals for the deleted district location
                                                    const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                                    updateHexVisual(districtRow, districtCol);
                                                    const districtNeighbors = getNeighbors(districtRow, districtCol);
                                                    districtNeighbors.forEach(neighbor => {
                                                        updateHexVisual(neighbor.row, neighbor.col);
                                                    });
                                                }
                                            }
                                            
                                            // Also check all districts that might now be better owned by the moved city center
                                            // This handles the case where a district was within range of 2 city centers
                                            // and the moved city center is now closer
                                            for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                                                if (districtPlaced.type === 'district' && 
                                                    districtPlaced.name !== 'City_Center' &&
                                                    districtPlaced.owner) {
                                                    // Check if this district is not already owned by the new city center location
                                                    let isOwnedByNewCity = false;
                                                    if (Array.isArray(districtPlaced.owner)) {
                                                        isOwnedByNewCity = districtPlaced.owner.includes(key);
                                                    } else {
                                                        isOwnedByNewCity = districtPlaced.owner === key;
                                                    }
                                                    
                                                    if (!isOwnedByNewCity) {
                                                        // Reassign to see if the moved city center is now a better owner
                                                        reassignDistrictOwnership(districtKey);
                                                        
                                                        // Update visuals if ownership changed
                                                        const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                                        updateHexVisual(districtRow, districtCol);
                                                        const districtNeighbors = getNeighbors(districtRow, districtCol);
                                                        districtNeighbors.forEach(neighbor => {
                                                            updateHexVisual(neighbor.row, neighbor.col);
                                                        });
                                                    }
                                                }
                                            }
                                            
                                            // Check all Aqueducts adjacent to both old and new City_Center locations
                                            // Delete any that no longer meet placement requirements
                                            const aqueductsToCheck = new Set();
                                            
                                            // Check neighbors of new location
                                            const newCityNeighbors = getNeighbors(targetRow, targetCol);
                                            for (const neighbor of newCityNeighbors) {
                                                const neighborKey = `${neighbor.row},${neighbor.col}`;
                                                const neighborPlaced = placedItems[neighborKey];
                                                if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'Aqueduct') {
                                                    aqueductsToCheck.add(neighborKey);
                                                }
                                            }
                                            
                                            // Check neighbors of old location
                                            const oldCityNeighbors = getNeighbors(touchDragDistrict.row, touchDragDistrict.col);
                                            for (const neighbor of oldCityNeighbors) {
                                                const neighborKey = `${neighbor.row},${neighbor.col}`;
                                                const neighborPlaced = placedItems[neighborKey];
                                                if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'Aqueduct') {
                                                    aqueductsToCheck.add(neighborKey);
                                                }
                                            }
                                            
                                            const aqueductsToDelete = [];
                                            for (const aqueductKey of aqueductsToCheck) {
                                                const [aqueductRow, aqueductCol] = aqueductKey.split(',').map(Number);
                                                const aqueductTile = challengeData.tiles[aqueductKey];
                                                // Validate this Aqueduct against placement rules
                                                if (!isValidPlacement(aqueductRow, aqueductCol, 'district', 'Aqueduct', aqueductTile)) {
                                                    aqueductsToDelete.push(aqueductKey);
                                                }
                                            }
                                            
                                            // Delete Aqueducts that no longer meet requirements
                                            for (const aqueductKey of aqueductsToDelete) {
                                                const aqueduct = placedItems[aqueductKey];
                                                if (aqueduct) {
                                                    // Add back to available items
                                                    availableItems[aqueduct.name] = (availableItems[aqueduct.name] || 0) + 1;
                                                    // Delete the Aqueduct
                                                    delete placedItems[aqueductKey];
                                                    // Update visuals for the deleted Aqueduct location
                                                    const [aqueductRow, aqueductCol] = aqueductKey.split(',').map(Number);
                                                    updateHexVisual(aqueductRow, aqueductCol);
                                                    const aqueductNeighbors = getNeighbors(aqueductRow, aqueductCol);
                                                    aqueductNeighbors.forEach(neighbor => {
                                                        updateHexVisual(neighbor.row, neighbor.col);
                                                    });
                                                }
                                            }
                                            
                                            // Check all Canals that might be affected by the city center move
                                            // A Canal can be valid if it has a city center on one of its opposite tiles
                                            // Check all Canals within 4 tiles of both old and new city center locations
                                            const canalsToCheck = new Set();
                                            
                                            // Check all placed items for Canals within range
                                            for (const [canalKey, canalPlaced] of Object.entries(placedItems)) {
                                                if (canalPlaced.type === 'district' && canalPlaced.name === 'Canal') {
                                                    const [canalRow, canalCol] = canalKey.split(',').map(Number);
                                                    
                                                    // Check distance to old city center location
                                                    const distanceToOld = getHexDistance(canalRow, canalCol, touchDragDistrict.row, touchDragDistrict.col);
                                                    // Check distance to new city center location
                                                    const distanceToNew = getHexDistance(canalRow, canalCol, targetRow, targetCol);
                                                    
                                                    // A city center could be on one of the opposite tiles if it's within 4 tiles
                                                    // (water tile is 1 tile away, opposite tiles are 3 tiles from water = 4 tiles from canal)
                                                    if (distanceToOld <= 4 || distanceToNew <= 4) {
                                                        canalsToCheck.add(canalKey);
                                                    }
                                                }
                                            }
                                            
                                            const canalsToDelete = [];
                                            for (const canalKey of canalsToCheck) {
                                                const [canalRow, canalCol] = canalKey.split(',').map(Number);
                                                const canalTile = challengeData.tiles[canalKey];
                                                // Validate this Canal against placement rules
                                                if (!isValidPlacement(canalRow, canalCol, 'district', 'Canal', canalTile)) {
                                                    canalsToDelete.push(canalKey);
                                                }
                                            }
                                            
                                            // Delete Canals that no longer meet requirements
                                            for (const canalKey of canalsToDelete) {
                                                const canal = placedItems[canalKey];
                                                if (canal) {
                                                    // Add back to available items
                                                    availableItems[canal.name] = (availableItems[canal.name] || 0) + 1;
                                                    // Delete the Canal
                                                    delete placedItems[canalKey];
                                                    // Update visuals for the deleted Canal location
                                                    const [canalRow, canalCol] = canalKey.split(',').map(Number);
                                                    updateHexVisual(canalRow, canalCol);
                                                    const canalNeighbors = getNeighbors(canalRow, canalCol);
                                                    canalNeighbors.forEach(neighbor => {
                                                        updateHexVisual(neighbor.row, neighbor.col);
                                                    });
                                                }
                                            }
                                            
                                            // Check all Wonders that might be affected by the city center move
                                            // Wonders must be within 3 tiles of a city center
                                            const wondersToCheck = new Set();
                                            
                                            // Check all placed items for Wonders
                                            for (const [wonderKey, wonderPlaced] of Object.entries(placedItems)) {
                                                if (wonderPlaced.type === 'wonder') {
                                                    const [wonderRow, wonderCol] = wonderKey.split(',').map(Number);
                                                    
                                                    // Check distance to old city center location
                                                    const distanceToOld = getHexDistance(wonderRow, wonderCol, touchDragDistrict.row, touchDragDistrict.col);
                                                    // Check distance to new city center location
                                                    const distanceToNew = getHexDistance(wonderRow, wonderCol, targetRow, targetCol);
                                                    
                                                    // If the wonder was within 3 tiles of the old location or new location, check it
                                                    if (distanceToOld <= 3 || distanceToNew <= 3) {
                                                        wondersToCheck.add(wonderKey);
                                                    }
                                                }
                                            }
                                            
                                            // Also check all wonders to see if they're still within range of any city center
                                            for (const [wonderKey, wonderPlaced] of Object.entries(placedItems)) {
                                                if (wonderPlaced.type === 'wonder') {
                                                    wondersToCheck.add(wonderKey);
                                                }
                                            }
                                            
                                            const wondersToDelete = [];
                                            for (const wonderKey of wondersToCheck) {
                                                const [wonderRow, wonderCol] = wonderKey.split(',').map(Number);
                                                const wonder = placedItems[wonderKey];
                                                if (wonder) {
                                                    const wonderTile = challengeData.tiles[wonderKey];
                                                    // Validate this Wonder against placement rules
                                                    if (!isValidPlacement(wonderRow, wonderCol, 'wonder', wonder.name, wonderTile)) {
                                                        wondersToDelete.push(wonderKey);
                                                    }
                                                }
                                            }
                                            
                                            // Delete Wonders that no longer meet requirements
                                            for (const wonderKey of wondersToDelete) {
                                                const wonder = placedItems[wonderKey];
                                                if (wonder) {
                                                    // Add back to available items
                                                    availableItems[wonder.name] = (availableItems[wonder.name] || 0) + 1;
                                                    // Delete the Wonder
                                                    delete placedItems[wonderKey];
                                                    // Update visuals for the deleted Wonder location
                                                    const [wonderRow, wonderCol] = wonderKey.split(',').map(Number);
                                                    updateHexVisual(wonderRow, wonderCol);
                                                    const wonderNeighbors = getNeighbors(wonderRow, wonderCol);
                                                    wonderNeighbors.forEach(neighbor => {
                                                        updateHexVisual(neighbor.row, neighbor.col);
                                                    });
                                                }
                                            }
                                        }
                                        
                                        // Validate and delete invalid adjacent wonders at old location
                                        validateAndDeleteInvalidWonders(touchDragDistrict.row, touchDragDistrict.col);
                                        
                                        // Validate and delete invalid adjacent wonders at new location
                                        validateAndDeleteInvalidWonders(targetRow, targetCol);
                                        
                                        updateHexVisual(touchDragDistrict.row, touchDragDistrict.col);
                                        const oldNeighbors = getNeighbors(touchDragDistrict.row, touchDragDistrict.col);
                                        oldNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                        
                                        updateHexVisual(targetRow, targetCol);
                                        const newNeighbors = getNeighbors(targetRow, targetCol);
                                        newNeighbors.forEach(neighbor => {
                                            updateHexVisual(neighbor.row, neighbor.col);
                                        });
                                        
                                        updateAllScores();
                                        populateSidebar();
                                        saveGameState();
                                        updateResetButton();
                                    }
                                }
                                
                                draggedDistrict = null;
                            }
                        } else {
                            // Touch ended outside a hex - delete the item
                            removeItem(touchDragDistrict.row, touchDragDistrict.col);
                            img.style.opacity = '1';
                        }
                        
                        // Remove drag element
                        if (touchDragDistrict.dragElement && touchDragDistrict.dragElement.parentNode) {
                            touchDragDistrict.dragElement.parentNode.removeChild(touchDragDistrict.dragElement);
                        }
                        
                        touchDragDistrict = null;
                        clearAllHighlights();
                        e.preventDefault();
                    }
                }, { passive: false });
                
                img.addEventListener('touchcancel', () => {
                    if (touchDragDistrict && touchDragDistrict.element === img) {
                        // Remove drag element
                        if (touchDragDistrict.dragElement && touchDragDistrict.dragElement.parentNode) {
                            touchDragDistrict.dragElement.parentNode.removeChild(touchDragDistrict.dragElement);
                        }
                        img.style.opacity = '1';
                        touchDragDistrict = null;
                        clearAllHighlights();
                    }
                });
                
                // Right-click to delete district
                img.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    removeItem(row, col);
                });
                
                districtShape.appendChild(img);
                
                // Add adjacency indicator for districts with yield icons
                const adjacency = calculateAdjacency(row, col);
                if (adjacency && adjacency.total > 0) {
                    const indicator = document.createElement('div');
                    indicator.className = 'adjacency-indicator';
                    
                    // Add yield badges for each yield type that has a bonus
                    const yieldTypes = [
                        { name: 'Science', value: adjacency.science, icon: 'assets/yields/Science.webp' },
                        { name: 'Faith', value: adjacency.faith, icon: 'assets/yields/Faith.webp' },
                        { name: 'Gold', value: adjacency.gold, icon: 'assets/yields/Gold.webp' },
                        { name: 'Production', value: adjacency.production, icon: 'assets/yields/Production.webp' },
                        { name: 'Culture', value: adjacency.culture, icon: 'assets/yields/Culture.webp' }
                    ];
                    
                    yieldTypes.forEach(yieldType => {
                        if (yieldType.value > 0) {
                            const badge = document.createElement('div');
                            badge.className = 'yield-badge';
                            
                            const amount = document.createElement('span');
                            amount.className = 'yield-amount';
                            amount.textContent = `+${yieldType.value}`;
                            
                            const icon = document.createElement('img');
                            icon.className = 'yield-icon';
                            icon.src = yieldType.icon;
                            icon.alt = yieldType.name;
                            icon.draggable = false;
                            
                            badge.appendChild(amount);
                            badge.appendChild(icon);
                            indicator.appendChild(badge);
                        }
                    });
                    
                    districtShape.appendChild(indicator);
                }
            }
        }

        function updateHexVisual(row, col) {
            updateHexVisualBase(row, col);
            updateHexVisualDistricts(row, col);
        }

        function populateSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.innerHTML = '';
            
            // Create scrollable content area
            const sidebarContent = document.createElement('div');
            sidebarContent.className = 'sidebar-content';
            
            const contentWrapper = document.createElement('div');
            contentWrapper.style.display = 'flex';
            contentWrapper.style.flexDirection = 'column';
            
            contentWrapper.innerHTML = '<h2>Available Items</h2>';
            
            // Districts
            const districtsSection = document.createElement('div');
            districtsSection.innerHTML = '<h3 style="margin-top: 15px; margin-bottom: 10px; color: #4a90e2; font-size: 16px;">Districts</h3>';
            
            // Define the desired order for districts
            const districtOrder = [
                'City_Center',
                'Government_Plaza',
                'Diplomatic_Quarter',
                'Neighborhood',
                'Aqueduct',
                'Canal',
                'Dam',
                'Industrial_Zone',
                'Commercial_Hub',
                'Harbor',
                'Campus',
                'Theater_Square',
                'Entertainment_Complex',
                'Water_Park',
                'Holy_Site',
                'Encampment',
                'Preserve',
                'Aerodrome',
                'Spaceport'
            ];
            
            // Get all district names from availableItems
            const districtNames = Object.keys(availableItems).filter(name => {
                return placementData.districts.find(d => d.name === name);
            });
            
            // Sort districts according to the specified order
            districtNames.sort((a, b) => {
                const indexA = districtOrder.indexOf(a);
                const indexB = districtOrder.indexOf(b);
                // If not in the order list, put them at the end
                if (indexA === -1 && indexB === -1) return 0;
                if (indexA === -1) return 1;
                if (indexB === -1) return -1;
                return indexA - indexB;
            });
            
            districtNames.forEach(name => {
                const itemData = placementData.districts.find(d => d.name === name);
                if (itemData) {
                    const item = createAvailableItem(name, 'district', availableItems[name]);
                    districtsSection.appendChild(item);
                }
            });
            
            contentWrapper.appendChild(districtsSection);
            
            // Improvements
            const improvementsSection = document.createElement('div');
            let hasImprovements = false;
            
            Object.keys(availableItems).forEach(name => {
                const itemData = placementData.improvements.find(i => i.name === name);
                if (itemData) {
                    if (!hasImprovements) {
                        improvementsSection.innerHTML = '<h3 style="margin-top: 15px; margin-bottom: 10px; color: #4a90e2; font-size: 16px;">Improvements</h3>';
                        hasImprovements = true;
                    }
                    const item = createAvailableItem(name, 'improvement', availableItems[name]);
                    improvementsSection.appendChild(item);
                }
            });
            
            if (hasImprovements) {
            contentWrapper.appendChild(improvementsSection);
            }
            
            // Wonders
            const wondersSection = document.createElement('div');
            let hasWonders = false;
            
            Object.keys(availableItems).forEach(name => {
                const itemData = placementData.wonders.find(w => w.name === name);
                if (itemData) {
                    if (!hasWonders) {
                        wondersSection.innerHTML = '<h3 style="margin-top: 15px; margin-bottom: 10px; color: #4a90e2; font-size: 16px;">Wonders</h3>';
                        hasWonders = true;
                    }
                    const item = createAvailableItem(name, 'wonder', availableItems[name]);
                    wondersSection.appendChild(item);
                }
            });
            
            if (hasWonders) {
            contentWrapper.appendChild(wondersSection);
            }
            
            sidebarContent.appendChild(contentWrapper);
            sidebar.appendChild(sidebarContent);
            
            // Privacy Policy and Report Bug Links - fixed at bottom (not scrollable)
            const footerLinks = document.createElement('div');
            footerLinks.className = 'sidebar-footer';
            footerLinks.style.display = 'flex';
            footerLinks.style.justifyContent = 'space-between';
            footerLinks.style.alignItems = 'center';
            
            const privacyLink = document.createElement('a');
            privacyLink.href = 'https://maximilianising.github.io/Civle/privacy-policy.html';
            privacyLink.target = '_blank';
            privacyLink.rel = 'noopener noreferrer';
            privacyLink.textContent = 'Privacy Policy';
            privacyLink.style.color = '#818384';
            privacyLink.style.fontSize = '12px';
            privacyLink.style.textDecoration = 'none';
            privacyLink.style.transition = 'color 0.2s';
            privacyLink.onmouseover = function() { this.style.color = '#ffffff'; };
            privacyLink.onmouseout = function() { this.style.color = '#818384'; };
            
            const reportBugLink = document.createElement('a');
            reportBugLink.href = '#';
            reportBugLink.textContent = 'Report Bug';
            reportBugLink.style.color = '#818384';
            reportBugLink.style.fontSize = '12px';
            reportBugLink.style.textDecoration = 'none';
            reportBugLink.style.transition = 'color 0.2s';
            reportBugLink.style.cursor = 'pointer';
            reportBugLink.onmouseover = function() { this.style.color = '#ffffff'; };
            reportBugLink.onmouseout = function() { this.style.color = '#818384'; };
            reportBugLink.onclick = function(e) {
                e.preventDefault();
                showBugReportModal();
            };
            
            footerLinks.appendChild(privacyLink);
            footerLinks.appendChild(reportBugLink);
            sidebar.appendChild(footerLinks);
        }

        function formatPlacementRequirements(itemData, type) {
            if (!itemData) return '';
            
            let html = `<h4>${itemData.name.replace(/_/g, ' ')}</h4>`;
            
            // Only show description if available
            if (itemData.description) {
                // Convert markdown-style bold (**text**) to HTML
                let description = itemData.description
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>');
                html += `<div class="requirement-section"><span class="requirement-value">${description}</span></div>`;
            }
            
            // For districts, show adjacency bonuses
            if (type === 'district' && adjacencyData) {
                const districtBonus = adjacencyData.district_adjacency_bonuses.find(d => d.name === itemData.name);
                if (districtBonus && districtBonus.adjacency_bonuses) {
                    html += `<div class="requirement-section" style="margin-top: 12px;"><strong>Adjacency Bonuses:</strong><ul style="margin: 8px 0 0 0; padding-left: 20px; list-style-type: disc;">`;
                    Object.entries(districtBonus.adjacency_bonuses).forEach(([source, bonus]) => {
                        const yieldType = bonus.type;
                        const yieldIcon = `assets/yields/${yieldType}.webp`;
                        const perText = bonus.per > 1 ? ` (per ${bonus.per})` : '';
                        html += `<li style="margin-bottom: 4px;"><img src="${yieldIcon}" alt="${yieldType}" class="yield-icon" style="width: 16px; height: 16px; vertical-align: middle; margin-right: 4px;">+${bonus.bonus} ${yieldType} from ${source.replace(/_/g, ' ')}${perText}</li>`;
                    });
                    html += `</ul></div>`;
                }
            }
            
            // For improvements with only_buildable_on_resources: true, show resource images
            if (type === 'improvement' && itemData.only_buildable_on_resources && itemData.resources_its_built_on && itemData.resources_its_built_on.length > 0) {
                html += `<div class="requirement-section resource-images">`;
                itemData.resources_its_built_on.forEach(resource => {
                    html += `<img src="assets/recources/${resource}.webp" alt="${resource}" class="resource-tooltip-icon" title="${resource}">`;
                });
                html += `</div>`;
            }
            
            return html;
        }

        function createAvailableItem(name, type, count) {
            const item = document.createElement('div');
            item.className = 'available-item';
            item.draggable = count > 0;
            item.dataset.name = name;
            item.dataset.type = type;
            
            if (count === 0) {
                item.style.opacity = '0.5';
                item.style.cursor = 'not-allowed';
            }
            
            let imgPath = '';
            if (type === 'district') {
                imgPath = `assets/districts/${name}.webp`;
            } else if (type === 'improvement') {
                imgPath = `assets/improvements/${name}.webp`;
            } else if (type === 'wonder') {
                imgPath = `assets/wonders/${name}.webp`;
            }
            
            const img = document.createElement('img');
            img.src = imgPath;
            img.alt = name;
            img.draggable = false;
            img.onerror = () => { img.style.display = 'none'; };
            
            const span = document.createElement('span');
            span.textContent = name.replace(/_/g, ' ');
            
            const countSpan = document.createElement('span');
            countSpan.className = 'count' + (count === 0 ? ' zero' : '');
            countSpan.textContent = `x${count}`;
            
            item.appendChild(img);
            item.appendChild(span);
            item.appendChild(countSpan);
            
            // Add tooltip for placement requirements
            item.addEventListener('mouseenter', (e) => {
                if (!placementData) return;
                
                // Remove any existing sidebar tooltip before creating a new one
                if (activeSidebarTooltip) {
                    activeSidebarTooltip.remove();
                    activeSidebarTooltip = null;
                }
                
                let itemData = null;
                if (type === 'district') {
                    itemData = placementData.districts.find(d => d.name === name);
                } else if (type === 'improvement') {
                    itemData = placementData.improvements.find(i => i.name === name);
                } else if (type === 'wonder') {
                    itemData = placementData.wonders.find(w => w.name === name);
                }
                
                if (!itemData) return;
                
                const tooltip = document.createElement('div');
                tooltip.className = 'placement-tooltip';
                tooltip.innerHTML = formatPlacementRequirements(itemData, type);
                document.body.appendChild(tooltip);
                
                // Store as the active sidebar tooltip
                activeSidebarTooltip = tooltip;
                
                // Position tooltip
                const rect = item.getBoundingClientRect();
                tooltip.style.left = (rect.right + 10) + 'px';
                tooltip.style.top = (rect.top + window.scrollY) + 'px';
                
                // Adjust if tooltip goes off screen
                setTimeout(() => {
                    if (activeSidebarTooltip === tooltip) {
                        const tooltipRect = tooltip.getBoundingClientRect();
                        if (tooltipRect.right > window.innerWidth) {
                            tooltip.style.left = (rect.left - tooltipRect.width - 10) + 'px';
                        }
                        if (tooltipRect.bottom > window.innerHeight) {
                            tooltip.style.top = (window.innerHeight - tooltipRect.height - 10) + 'px';
                        }
                    }
                }, 0);
            });
            
            item.addEventListener('mouseleave', () => {
                // Only remove if this is still the active tooltip
                if (activeSidebarTooltip) {
                    activeSidebarTooltip.remove();
                    activeSidebarTooltip = null;
                }
            });
            
            item.addEventListener('dragstart', (e) => {
                // Hide tooltip when dragging starts
                if (activeSidebarTooltip) {
                    activeSidebarTooltip.remove();
                    activeSidebarTooltip = null;
                }
                
                if (count > 0) {
                    draggedItem = { type, name };
                    item.classList.add('dragging');
                    
                    // Create a custom drag image with the district/improvement icon
                    // Use the existing image from the sidebar item, but create a larger version
                    const dragImg = new Image();
                    dragImg.src = imgPath;
                    dragImg.style.width = '64px';
                    dragImg.style.height = '64px';
                    dragImg.style.opacity = '1';
                    dragImg.style.position = 'fixed';
                    dragImg.style.left = '-1000px';
                    dragImg.style.top = '-1000px';
                    dragImg.style.pointerEvents = 'none';
                    document.body.appendChild(dragImg);
                    
                    // Set drag image - use the center of the 64x64 image
                    if (dragImg.complete && dragImg.naturalWidth > 0) {
                        e.dataTransfer.setDragImage(dragImg, 32, 32);
                        setTimeout(() => {
                            if (dragImg.parentNode) {
                                document.body.removeChild(dragImg);
                            }
                        }, 0);
                    } else {
                        dragImg.onload = () => {
                            e.dataTransfer.setDragImage(dragImg, 32, 32);
                            setTimeout(() => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            }, 0);
                        };
                        dragImg.onerror = () => {
                            if (dragImg.parentNode) {
                                document.body.removeChild(dragImg);
                            }
                        };
                    }
                    
                    // Highlight all tiles based on placement validity
                    highlightAllTiles(type, name);
                } else {
                    e.preventDefault();
                }
            });
            
            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                draggedItem = null;
                
                // Remove all highlights
                clearAllHighlights();
            });
            
            // Touch support for drag and drop
            item.addEventListener('touchstart', (e) => {
                if (count > 0) {
                    const touch = e.touches[0];
                    
                    // Create a visual element that follows the touch (same approach as regular drag)
                    const dragElement = new Image();
                    dragElement.src = imgPath;
                    dragElement.style.width = '64px';
                    dragElement.style.height = '64px';
                    dragElement.style.opacity = '0.5';
                    dragElement.style.position = 'fixed';
                    dragElement.style.left = (touch.clientX - 32) + 'px';
                    dragElement.style.top = (touch.clientY - 32) + 'px';
                    dragElement.style.pointerEvents = 'none';
                    dragElement.style.zIndex = '99999';
                    document.body.appendChild(dragElement);
                    
                    touchDragState = {
                        type: type,
                        name: name,
                        startX: touch.clientX,
                        startY: touch.clientY,
                        element: item,
                        dragElement: dragElement
                    };
                    item.classList.add('dragging');
                    highlightAllTiles(type, name);
                    e.preventDefault(); // Prevent scrolling
                }
            }, { passive: false });
            
            item.addEventListener('touchmove', (e) => {
                if (touchDragState && touchDragState.element === item) {
                    const touch = e.touches[0];
                    // Update drag element position
                    if (touchDragState.dragElement) {
                        touchDragState.dragElement.style.left = (touch.clientX - 32) + 'px';
                        touchDragState.dragElement.style.top = (touch.clientY - 32) + 'px';
                    }
                    e.preventDefault(); // Prevent scrolling while dragging
                }
            }, { passive: false });
            
            item.addEventListener('touchend', (e) => {
                if (touchDragState && touchDragState.element === item) {
                    const touch = e.changedTouches[0];
                    const elementAtPoint = document.elementFromPoint(touch.clientX, touch.clientY);
                    
                    // Find the hex element (could be the hex itself or a child)
                    const hexElement = elementAtPoint?.closest('.hex');
                    if (hexElement) {
                        const row = parseInt(hexElement.dataset.row);
                        const col = parseInt(hexElement.dataset.col);
                        if (!isNaN(row) && !isNaN(col)) {
                            placeItem(row, col, touchDragState.type, touchDragState.name);
                        }
                    }
                    
                    // Remove drag element
                    if (touchDragState.dragElement && touchDragState.dragElement.parentNode) {
                        touchDragState.dragElement.parentNode.removeChild(touchDragState.dragElement);
                    }
                    
                    item.classList.remove('dragging');
                    touchDragState = null;
                    clearAllHighlights();
                    e.preventDefault();
                }
            }, { passive: false });
            
            item.addEventListener('touchcancel', () => {
                if (touchDragState && touchDragState.element === item) {
                    // Remove drag element
                    if (touchDragState.dragElement && touchDragState.dragElement.parentNode) {
                        touchDragState.dragElement.parentNode.removeChild(touchDragState.dragElement);
                    }
                    item.classList.remove('dragging');
                    touchDragState = null;
                    clearAllHighlights();
                }
            });
            
            return item;
        }

        function placeItem(row, col, type, name) {
            const key = `${row},${col}`;
            const tile = challengeData.tiles[key];
            
            // Check if placement is valid
            if (!isValidPlacement(row, col, type, name, tile)) {
                return;
            }
            
            // Check if item is available
            if (availableItems[name] <= 0) {
                return;
            }
            
            // Remove any existing item at this location
            if (placedItems[key]) {
                const oldItem = placedItems[key];
                availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
            }
            
            // Place new item
            placedItems[key] = { type, name };
            
            // Assign district to a City_Center if it's a district (except City_Center itself)
            // Uses ambiguous ownership if multiple city centers are valid
            if (type === 'district' && name !== 'City_Center') {
                assignDistrictOwnership(key, row, col, name);
            }
            
            availableItems[name] = (availableItems[name] || 0) - 1;
            
            // Update visuals for this hex and all neighbors (for adjacency indicators)
            updateHexVisual(row, col);
            const neighbors = getNeighbors(row, col);
            neighbors.forEach(neighbor => {
                updateHexVisual(neighbor.row, neighbor.col);
            });
            updateAllScores();
            populateSidebar();
            saveGameState();
            updateResetButton();
        }

        function validateAndDeleteInvalidWonders(checkRow, checkCol) {
            // Get all neighbors of the position
            const neighbors = getNeighbors(checkRow, checkCol);
            const wondersToCheck = new Set();
            
            // Check all neighbors for wonders
            for (const neighbor of neighbors) {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborPlaced = placedItems[neighborKey];
                if (neighborPlaced && neighborPlaced.type === 'wonder') {
                    wondersToCheck.add(neighborKey);
                }
            }
            
            // Validate each wonder and delete if invalid
            const wondersToDelete = [];
            for (const wonderKey of wondersToCheck) {
                const [wonderRow, wonderCol] = wonderKey.split(',').map(Number);
                const wonder = placedItems[wonderKey];
                if (wonder) {
                    const wonderTile = challengeData.tiles[wonderKey];
                    // Validate this wonder against placement rules
                    if (!isValidPlacement(wonderRow, wonderCol, 'wonder', wonder.name, wonderTile)) {
                        wondersToDelete.push(wonderKey);
                    }
                }
            }
            
            // Delete invalid wonders
            for (const wonderKey of wondersToDelete) {
                const wonder = placedItems[wonderKey];
                if (wonder) {
                    // Add back to available items
                    availableItems[wonder.name] = (availableItems[wonder.name] || 0) + 1;
                    // Delete the wonder
                    delete placedItems[wonderKey];
                    // Update visuals for the deleted wonder location
                    const [wonderRow, wonderCol] = wonderKey.split(',').map(Number);
                    updateHexVisual(wonderRow, wonderCol);
                    const wonderNeighbors = getNeighbors(wonderRow, wonderCol);
                    wonderNeighbors.forEach(neighbor => {
                        updateHexVisual(neighbor.row, neighbor.col);
                    });
                }
            }
        }

        function removeItem(row, col) {
            const key = `${row},${col}`;
            if (!placedItems[key]) return;
            
            const oldItem = placedItems[key];
            
            // If deleting a City_Center, delete all districts it owns and check all wonders
            if (oldItem.type === 'district' && oldItem.name === 'City_Center') {
                const districtsToDelete = [];
                
                // Find all districts that are owned by this City_Center
                // Handle both direct owners and ambiguous owners
                for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                    if (districtPlaced.type === 'district' && 
                        districtPlaced.name !== 'City_Center') {
                        // Check if this district is owned by (or could be owned by) this city center
                        if (Array.isArray(districtPlaced.owner)) {
                            if (districtPlaced.owner.includes(key)) {
                                districtsToDelete.push(districtKey);
                            }
                        } else if (districtPlaced.owner === key) {
                            districtsToDelete.push(districtKey);
                        }
                    }
                }
                
                // Delete all owned districts
                for (const districtKey of districtsToDelete) {
                    const [districtRow, districtCol] = districtKey.split(',').map(Number);
                    const district = placedItems[districtKey];
                    if (district) {
                        // Add back to available items
                        availableItems[district.name] = (availableItems[district.name] || 0) + 1;
                        // Delete the district
                        delete placedItems[districtKey];
                        // Update visuals for the deleted district location
                        updateHexVisual(districtRow, districtCol);
                        const districtNeighbors = getNeighbors(districtRow, districtCol);
                        districtNeighbors.forEach(neighbor => {
                            updateHexVisual(neighbor.row, neighbor.col);
                        });
                    }
                }
                
                // Check all Wonders to see if they're still within range of any city center
                const wondersToCheck = [];
                for (const [wonderKey, wonderPlaced] of Object.entries(placedItems)) {
                    if (wonderPlaced.type === 'wonder') {
                        wondersToCheck.push(wonderKey);
                    }
                }
                
                const wondersToDelete = [];
                for (const wonderKey of wondersToCheck) {
                    const [wonderRow, wonderCol] = wonderKey.split(',').map(Number);
                    const wonder = placedItems[wonderKey];
                    if (wonder) {
                        const wonderTile = challengeData.tiles[wonderKey];
                        // Validate this Wonder against placement rules
                        if (!isValidPlacement(wonderRow, wonderCol, 'wonder', wonder.name, wonderTile)) {
                            wondersToDelete.push(wonderKey);
                        }
                    }
                }
                
                // Delete Wonders that are no longer within range of any city center
                for (const wonderKey of wondersToDelete) {
                    const wonder = placedItems[wonderKey];
                    if (wonder) {
                        // Add back to available items
                        availableItems[wonder.name] = (availableItems[wonder.name] || 0) + 1;
                        // Delete the Wonder
                        delete placedItems[wonderKey];
                        // Update visuals for the deleted Wonder location
                        const [wonderRow, wonderCol] = wonderKey.split(',').map(Number);
                        updateHexVisual(wonderRow, wonderCol);
                        const wonderNeighbors = getNeighbors(wonderRow, wonderCol);
                        wonderNeighbors.forEach(neighbor => {
                            updateHexVisual(neighbor.row, neighbor.col);
                        });
                    }
                }
            }
            
            // Delete the item itself
            delete placedItems[key];
            availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
            
            // Validate and delete invalid adjacent wonders
            validateAndDeleteInvalidWonders(row, col);
            
            // Update visuals for this hex and all neighbors
            updateHexVisual(row, col);
            const neighbors = getNeighbors(row, col);
            neighbors.forEach(neighbor => {
                updateHexVisual(neighbor.row, neighbor.col);
            });
            updateAllScores();
            populateSidebar();
            saveGameState();
            updateResetButton();
        }

        function isValidPlacement(row, col, type, name, tile, excludeLocation = null) {
            if (!tile || !tile.terrain) return false;
            
            // No districts, improvements, or wonders can be placed on natural wonder tiles
            if (tile.terrain && NATURAL_WONDER_TERRAINS.has(tile.terrain)) {
                return false;
            }
            
            let itemData = null;
            if (type === 'district') {
                itemData = placementData.districts.find(d => d.name === name);
            } else if (type === 'improvement') {
                itemData = placementData.improvements.find(i => i.name === name);
            } else if (type === 'wonder') {
                itemData = placementData.wonders.find(w => w.name === name);
            }
            
            if (!itemData) return false;
            
            // Check terrain (for non-wonders, or wonders without allowed_features)
            // For wonders with both allowed_terrain and allowed_features, we check them together later
            if (type !== 'wonder' || !itemData.allowed_features || itemData.allowed_features.length === 0) {
            if (itemData.allowed_terrain && !itemData.allowed_terrain.includes(tile.terrain)) {
                return false;
                }
            }
            
            // Check city center adjacency rules for districts
            if (type === 'district') {
                // City centers must be at least 3 tiles apart
                if (name === 'City_Center') {
                    for (const [key, placed] of Object.entries(placedItems)) {
                        if (placed.type === 'district' && placed.name === 'City_Center') {
                            const [existingRow, existingCol] = key.split(',').map(Number);
                            // Skip if this is the same location or the excluded location (when moving)
                            if ((existingRow === row && existingCol === col) || 
                                (excludeLocation && existingRow === excludeLocation.row && existingCol === excludeLocation.col)) {
                                continue;
                            }
                            const distance = getHexDistance(row, col, existingRow, existingCol);
                            if (distance <= 3) {
                                return false;
                            }
                        }
                    }
                }
                
                // Special placement rules for Aqueduct
                if (name === 'Aqueduct') {
                    const neighbors = getNeighbors(row, col);
                    let hasAdjacentCityCenter = false;
                    let adjacentCityCenterKey = null;
                    let hasAdjacentMountainOrCoast = false;
                    
                    // Check neighbors for city center and mountain/coast
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborPlaced = placedItems[neighborKey];
                        const neighborTile = challengeData.tiles[neighborKey];
                        
                        // Skip if this is the excluded location (when moving)
                        if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                            continue;
                        }
                        
                        // Check for adjacent city center
                        if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'City_Center') {
                            hasAdjacentCityCenter = true;
                            adjacentCityCenterKey = neighborKey;
                        }
                        
                        // Check for adjacent mountain or coast
                        if (neighborTile) {
                            if (neighborTile.terrain && (neighborTile.terrain.includes('Mountain') || 
                                neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                                hasAdjacentMountainOrCoast = true;
                            }
                        }
                    }
                    
                    // Rule 1: Must have adjacent city center AND adjacent mountain/coast
                    if (hasAdjacentCityCenter && hasAdjacentMountainOrCoast) {
                        // Valid placement
                    } else if (hasAdjacentCityCenter) {
                        // Rule 2: Check if the aqueduct tile has any river edges
                        // (other than the river edge that would lead to the city center)
                        if (adjacentCityCenterKey && tile && tile.rivers) {
                            const [cityRow, cityCol] = adjacentCityCenterKey.split(',').map(Number);
                            
                            // Determine which edge of the aqueduct hex connects to the city center
                            // Based on map_maker.html getNeighborForEdge logic
                            // Edge mapping: 0=Top-right, 1=Right, 2=Bottom-right, 3=Bottom-left, 4=Left, 5=Top-left
                            const isOddRow = row % 2 === 1;
                            let cityCenterEdgeIndex = -1;
                            
                            // Determine edge based on relative position (reverse of getNeighborForEdge)
                            const dr = cityRow - row;
                            const dc = cityCol - col;
                            
                            if (isOddRow) {
                                // Odd row
                                if (dr === -1 && dc === 1) cityCenterEdgeIndex = 0; // Top-right -> connects to (row-1, col+1)
                                else if (dr === 0 && dc === 1) cityCenterEdgeIndex = 1; // Right -> connects to (row, col+1)
                                else if (dr === 1 && dc === 1) cityCenterEdgeIndex = 2; // Bottom-right -> connects to (row+1, col+1)
                                else if (dr === 1 && dc === 0) cityCenterEdgeIndex = 3; // Bottom-left -> connects to (row+1, col)
                                else if (dr === 0 && dc === -1) cityCenterEdgeIndex = 4; // Left -> connects to (row, col-1)
                                else if (dr === -1 && dc === 0) cityCenterEdgeIndex = 5; // Top-left -> connects to (row-1, col)
                            } else {
                                // Even row
                                if (dr === -1 && dc === 0) cityCenterEdgeIndex = 0; // Top-right -> connects to (row-1, col)
                                else if (dr === 0 && dc === 1) cityCenterEdgeIndex = 1; // Right -> connects to (row, col+1)
                                else if (dr === 1 && dc === 0) cityCenterEdgeIndex = 2; // Bottom-right -> connects to (row+1, col)
                                else if (dr === 1 && dc === -1) cityCenterEdgeIndex = 3; // Bottom-left -> connects to (row+1, col-1)
                                else if (dr === 0 && dc === -1) cityCenterEdgeIndex = 4; // Left -> connects to (row, col-1)
                                else if (dr === -1 && dc === -1) cityCenterEdgeIndex = 5; // Top-left -> connects to (row-1, col-1)
                            }
                            
                            // Check if aqueduct tile has any river edges other than the one connecting to city center
                            let hasOtherRiverEdge = false;
                            if (cityCenterEdgeIndex >= 0) {
                                for (let i = 0; i < 6; i++) {
                                    if (tile.rivers[i] && i !== cityCenterEdgeIndex) {
                                        hasOtherRiverEdge = true;
                                        break;
                                    }
                                }
                            } else {
                                // If we couldn't determine the edge, check if there are any river edges at all
                                for (let i = 0; i < 6; i++) {
                                    if (tile.rivers[i]) {
                                        hasOtherRiverEdge = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (!hasOtherRiverEdge) {
                                return false;
                            }
                            // Valid placement if hasOtherRiverEdge is true
                        } else {
                            return false;
                        }
                    } else {
                        // No adjacent city center - invalid
                        return false;
                    }
                }
                
                // Special placement rules for Canal
                if (name === 'Canal') {
                    const neighbors = getNeighbors(row, col);
                    let hasAdjacentWater = false;
                    let validPlacement = false;
                    let waterOrCityCount = 0;
                    
                    // First pass: Count all adjacent water tiles (Coast, Ocean, Reef) and city centers
                    // Canal can have AT MOST 2 adjacent water or city center tiles
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        const neighborPlaced = placedItems[neighborKey];
                        
                        // Skip if this is the excluded location (when moving)
                        if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                            continue;
                        }
                        
                        // Check if neighbor is water (Coast, Ocean, or Reef)
                        const isWater = neighborTile && neighborTile.terrain && 
                            (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef');
                        
                        // Check if neighbor is city center
                        const isCityCenter = neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'City_Center';
                        
                        if (isWater) {
                            waterOrCityCount++;
                            hasAdjacentWater = true;
                        }
                        
                        // Count city centers as well
                        if (isCityCenter) {
                            waterOrCityCount++;
                        }
                    }
                    
                    // Second pass: Check for valid opposite tile (only if we have adjacent water)
                    if (hasAdjacentWater) {
                        for (const neighbor of neighbors) {
                            const neighborKey = `${neighbor.row},${neighbor.col}`;
                            const neighborTile = challengeData.tiles[neighborKey];
                            
                            // Skip if this is the excluded location (when moving)
                            if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                                continue;
                            }
                            
                            // Check if neighbor is water (Coast, Ocean, or Reef)
                            const isWater = neighborTile && neighborTile.terrain && 
                                (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef');
                            
                            if (isWater) {
                                // Calculate the direction from canal to this water tile
                                const dr = neighbor.row - row;
                                const dc = neighbor.col - col;
                                const isOddRow = row % 2 === 1;
                                
                                // Determine direction index (0-5) based on relative position
                                // Directions: 0=Right, 1=Top-right, 2=Top-left, 3=Left, 4=Bottom-left, 5=Bottom-right
                                let directionIndex = -1;
                                
                                if (isOddRow) {
                                    if (dr === 0 && dc === 1) directionIndex = 0; // Right
                                    else if (dr === -1 && dc === 1) directionIndex = 1; // Top-right
                                    else if (dr === -1 && dc === 0) directionIndex = 2; // Top-left
                                    else if (dr === 0 && dc === -1) directionIndex = 3; // Left
                                    else if (dr === 1 && dc === 0) directionIndex = 4; // Bottom-left
                                    else if (dr === 1 && dc === 1) directionIndex = 5; // Bottom-right
                                } else {
                                    if (dr === 0 && dc === 1) directionIndex = 0; // Right
                                    else if (dr === -1 && dc === 0) directionIndex = 1; // Top-right
                                    else if (dr === -1 && dc === -1) directionIndex = 2; // Top-left
                                    else if (dr === 0 && dc === -1) directionIndex = 3; // Left
                                    else if (dr === 1 && dc === -1) directionIndex = 4; // Bottom-left
                                    else if (dr === 1 && dc === 0) directionIndex = 5; // Bottom-right
                                }
                                
                                // If we found the direction, check the opposite 3 tiles
                                if (directionIndex >= 0) {
                                    // Opposite 3 tiles are at directions (i+2) mod 6, (i+3) mod 6, (i+4) mod 6
                                    const oppositeDirections = [
                                        (directionIndex + 2) % 6,
                                        (directionIndex + 3) % 6,
                                        (directionIndex + 4) % 6
                                    ];
                                    
                                    // Check each opposite direction for water tile or city center
                                    for (const oppDir of oppositeDirections) {
                                        const oppNeighbor = getNeighborAtDirection(row, col, oppDir);
                                        if (oppNeighbor) {
                                            const oppKey = `${oppNeighbor.row},${oppNeighbor.col}`;
                                            const oppTile = challengeData.tiles[oppKey];
                                            const oppPlaced = placedItems[oppKey];
                                            
                                            // Skip if this is the excluded location (when moving)
                                            if (excludeLocation && oppNeighbor.row === excludeLocation.row && oppNeighbor.col === excludeLocation.col) {
                                                continue;
                                            }
                                            
                                            // Check if opposite tile has water or city center
                                            if (oppTile && oppTile.terrain && 
                                                (oppTile.terrain === 'Coast' || oppTile.terrain === 'Ocean' || oppTile.terrain === 'Reef')) {
                                                validPlacement = true;
                                                break;
                                            }
                                            if (oppPlaced && oppPlaced.type === 'district' && oppPlaced.name === 'City_Center') {
                                                validPlacement = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                // If we found a valid placement for this water tile, we can break
                                if (validPlacement) break;
                            }
                        }
                    }
                    
                    // Canal can have AT MOST 2 adjacent water or city center tiles
                    if (waterOrCityCount > 2) {
                        return false;
                    }
                    
                    // Canal must be adjacent to water AND have valid opposite tile
                    if (!hasAdjacentWater || !validPlacement) {
                        return false;
                    }
                }
                
                // Special placement rules for Dam: Only one dam per major floodplain
                // Two dams cannot be connected by floodplain tiles
                if (name === 'Dam') {
                    // Check if this tile is a floodplain
                    const isFloodplain = tile.terrain && (
                        tile.terrain === 'Desert_Floodplains' || 
                        tile.terrain === 'Grassland_Floodplains' || 
                        tile.terrain === 'Plains_Floodplains'
                    );
                    
                    if (isFloodplain) {
                        // Find all connected floodplain tiles
                        const connectedFloodplains = getConnectedFloodplains(row, col, excludeLocation);
                        
                        // Check if any connected floodplain tile already has a Dam
                        for (const floodplainKey of connectedFloodplains) {
                            const floodplainPlaced = placedItems[floodplainKey];
                            if (floodplainPlaced && floodplainPlaced.type === 'district' && floodplainPlaced.name === 'Dam') {
                                // Skip if this is the excluded location (when moving)
                                const [floodplainRow, floodplainCol] = floodplainKey.split(',').map(Number);
                                if (excludeLocation && floodplainRow === excludeLocation.row && floodplainCol === excludeLocation.col) {
                                    continue;
                                }
                                // Another dam exists in this floodplain - cannot place
                                return false;
                            }
                        }
                    }
                }
                
                if (itemData.must_be_adjacent_to_city_center && !hasCityCenterAdjacent(row, col)) {
                    return false;
                }
                if (itemData.cant_be_adjacent_to_city_center && hasCityCenterAdjacent(row, col)) {
                    return false;
                }
                
                // Districts cannot be built on strategic or luxury resources (except City_Center)
                if (name !== 'City_Center' && tile.resource && resourcesData) {
                    const isStrategic = resourcesData.strategic_resources.some(r => r.name === tile.resource);
                    const isLuxury = resourcesData.luxury_resources.some(r => r.name === tile.resource);
                    if (isStrategic || isLuxury) {
                        return false;
                    }
                }
                
                // Districts cannot be built on geothermal fissures, reefs, or resources (except City_Center)
                if (name !== 'City_Center') {
                    // Check for geothermal fissures
                if (tile.feature === 'Geothermal_Fissure') {
                    return false;
                    }
                    // Check for reef terrain
                    if (tile.terrain === 'Reef') {
                        return false;
                    }
                    // Check for strategic or luxury resources
                    if (tile.resource && resourcesData) {
                        const isStrategic = resourcesData.strategic_resources.some(r => r.name === tile.resource);
                        const isLuxury = resourcesData.luxury_resources.some(r => r.name === tile.resource);
                        if (isStrategic || isLuxury) {
                            return false;
                        }
                    }
                }
                
                // Hard check: No city center can have multiple districts of the same type in its first ring (adjacent tiles)
                if (name !== 'City_Center') {
                    // Check if this tile is adjacent to any City_Center
                    const neighbors = getNeighbors(row, col);
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborPlaced = placedItems[neighborKey];
                        
                        // Skip if this is the excluded location (when moving)
                        if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                            continue;
                        }
                        
                        // If neighbor is a City_Center, check its first ring for duplicate district types
                        if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'City_Center') {
                            const cityCenterNeighbors = getNeighbors(neighbor.row, neighbor.col);
                            for (const cityNeighbor of cityCenterNeighbors) {
                                const cityNeighborKey = `${cityNeighbor.row},${cityNeighbor.col}`;
                                const cityNeighborPlaced = placedItems[cityNeighborKey];
                                
                                // Skip the current location being checked
                                if (cityNeighbor.row === row && cityNeighbor.col === col) {
                                    continue;
                                }
                                
                                // Skip if this is the excluded location (when moving)
                                if (excludeLocation && cityNeighbor.row === excludeLocation.row && cityNeighbor.col === excludeLocation.col) {
                                    continue;
                                }
                                
                                // If there's already a district of the same type in the first ring, prevent placement
                                // Exception: Dam, Neighborhood, and Canal can have multiple instances per city
                                if (cityNeighborPlaced && 
                                    cityNeighborPlaced.type === 'district' && 
                                    cityNeighborPlaced.name === name &&
                                    name !== 'Dam' && name !== 'Neighborhood' && name !== 'Canal') {
                                    return false;
                                }
                            }
                        }
                    }
                }
                
                // Every district (except City_Center) must be owned by a City_Center within 3 tiles
                // Each City_Center can only own one of each district type
                // A City_Center cannot own a district that is in another City_Center's first ring
                if (name !== 'City_Center') {
                    let foundAvailableCityCenter = false;
                    
                    // First, check if this district is in any City_Center's first ring (adjacent)
                    const neighbors = getNeighbors(row, col);
                    let adjacentCityCenter = null;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborPlaced = placedItems[neighborKey];
                        
                        // Skip if this is the excluded location (when moving)
                        if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                            continue;
                        }
                        
                        if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'City_Center') {
                            adjacentCityCenter = neighborKey;
                            break;
                        }
                    }
                    
                    // If district is adjacent to a City_Center, it must be owned by that City_Center
                    if (adjacentCityCenter) {
                        // Check if that City_Center already owns a district of this type
                        // Exception: Dam, Neighborhood, and Canal can have multiple instances per city (no ownership restriction)
                        // Consider ambiguous owners - if a district has ambiguous owners, we can still place
                        let alreadyOwns = false;
                        if (name !== 'Dam' && name !== 'Neighborhood' && name !== 'Canal') {
                        for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                            if (districtPlaced.type !== 'district' || districtPlaced.name !== name) continue;
                            
                            // Skip if this is the district being moved (same location)
                            const [districtRow, districtCol] = districtKey.split(',').map(Number);
                            if (excludeLocation && 
                                districtRow === excludeLocation.row && 
                                districtCol === excludeLocation.col) {
                                continue;
                            }
                            
                            // Check if this district is owned by (or could be owned by) this city center
                            if (Array.isArray(districtPlaced.owner)) {
                                // Ambiguous owner - if this city is the only owner, it's taken
                                if (districtPlaced.owner.length === 1 && districtPlaced.owner[0] === adjacentCityCenter) {
                                    alreadyOwns = true;
                                    break;
                                }
                                // If ambiguous with multiple owners, we can still place (allows swapping)
                            } else if (districtPlaced.owner === adjacentCityCenter) {
                                // Direct owner - city center already owns this type
                                alreadyOwns = true;
                                break;
                            }
                            }
                        }
                        
                        if (!alreadyOwns) {
                            foundAvailableCityCenter = true;
                        }
                    } else {
                        // District is not adjacent to any City_Center, find any City_Center within 3 tiles
                        // But exclude City_Centers that have this district in their first ring
                        for (const [cityKey, cityPlaced] of Object.entries(placedItems)) {
                            if (cityPlaced.type === 'district' && cityPlaced.name === 'City_Center') {
                                const [cityRow, cityCol] = cityKey.split(',').map(Number);
                                // Skip if this is the same location or excluded location (when moving)
                                if ((cityRow === row && cityCol === col) ||
                                    (excludeLocation && cityRow === excludeLocation.row && cityCol === excludeLocation.col)) {
                                    continue;
                                }
                                
                                // Check if this district is in another City_Center's first ring
                                const cityNeighbors = getNeighbors(cityRow, cityCol);
                                let isInAnotherCityFirstRing = false;
                                for (const cityNeighbor of cityNeighbors) {
                                    if (cityNeighbor.row === row && cityNeighbor.col === col) {
                                        // This district is in this City_Center's first ring
                                        // But we're checking a different City_Center, so this is invalid
                                        isInAnotherCityFirstRing = true;
                                        break;
                                    }
                                }
                                
                                if (isInAnotherCityFirstRing) {
                                    continue; // Skip this City_Center - it can't own a district in another City_Center's first ring
                                }
                                
                                const distance = getHexDistance(row, col, cityRow, cityCol);
                                if (distance <= 3) {
                                    // Check if this City_Center already owns a district of this type
                                    // Exception: Dam, Neighborhood, and Canal can have multiple instances per city (no ownership restriction)
                                    // Consider ambiguous owners - if a district has ambiguous owners, we can still place
                                    let alreadyOwns = false;
                                    if (name !== 'Dam' && name !== 'Neighborhood' && name !== 'Canal') {
                                    for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                                        if (districtPlaced.type !== 'district' || districtPlaced.name !== name) continue;
                                        
                                        // Skip if this is the district being moved (same location)
                                        const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                        if (excludeLocation && 
                                            districtRow === excludeLocation.row && 
                                            districtCol === excludeLocation.col) {
                                            continue;
                                        }
                                        
                                        // Check if this district is owned by (or could be owned by) this city center
                                        if (Array.isArray(districtPlaced.owner)) {
                                            // Ambiguous owner - if this city is the only owner, it's taken
                                            if (districtPlaced.owner.length === 1 && districtPlaced.owner[0] === cityKey) {
                                                alreadyOwns = true;
                                                break;
                                            }
                                            // If ambiguous with multiple owners, we can still place (allows swapping)
                                        } else if (districtPlaced.owner === cityKey) {
                                            // Direct owner - city center already owns this type
                                            alreadyOwns = true;
                                            break;
                                        }
                                        }
                                    }
                                    
                                    if (!alreadyOwns) {
                                        foundAvailableCityCenter = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    if (!foundAvailableCityCenter) {
                        return false;
                    }
                }
            }
            
            // Check improvement requirements
            if (type === 'improvement') {
                // Check if must be on woods
                if (itemData.must_be_on_woods && tile.feature !== 'Woods') {
                    return false;
                }
                
                // Check if must be coastal
                if (itemData.must_be_coastal) {
                    const neighbors = getNeighbors(row, col);
                    let hasCoast = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        if (neighborTile && (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                            hasCoast = true;
                            break;
                        }
                    }
                    if (!hasCoast) return false;
                }
                
                // Check resource requirements
                if (itemData.only_buildable_on_resources) {
                    if (!tile.resource || !itemData.resources_its_built_on.includes(tile.resource)) {
                        return false;
                    }
                } else if (itemData.resources_its_built_on && itemData.resources_its_built_on.length > 0) {
                    // Can be built on resource or without
                    if (tile.resource && !itemData.resources_its_built_on.includes(tile.resource)) {
                        // If there's a resource on the tile that's not in the list, check if it's a bonus resource
                        // Bonus resources are allowed for improvements with only_buildable_on_resources: false
                        if (resourcesData) {
                            const isBonus = resourcesData.bonus_resources.some(r => r.name === tile.resource);
                            const isStrategic = resourcesData.strategic_resources.some(r => r.name === tile.resource);
                            const isLuxury = resourcesData.luxury_resources.some(r => r.name === tile.resource);
                            
                            // Allow placement if it's a bonus resource
                            // But still block strategic/luxury resources that aren't in the list
                            if (!isBonus && (isStrategic || isLuxury)) {
                                return false;
                            }
                            // If it's a bonus resource, allow placement (don't return false)
                        } else {
                            // If we don't have resources data, use the old behavior
                            return false;
                        }
                    }
                }
            }
            
            // Check wonder requirements
            if (type === 'wonder') {
                // Wonders must be within 3 tiles of a city center
                let withinRangeOfCityCenter = false;
                for (const [placedKey, placed] of Object.entries(placedItems)) {
                    if (placed.type === 'district' && placed.name === 'City_Center') {
                        const [cityRow, cityCol] = placedKey.split(',').map(Number);
                        const distance = getHexDistance(row, col, cityRow, cityCol);
                        if (distance <= 3) {
                            withinRangeOfCityCenter = true;
                            break;
                        }
                    }
                }
                if (!withinRangeOfCityCenter) return false;
                
                // Wonders cannot be built on geothermal fissures, reefs, or resources
                // Check for geothermal fissures
                if (tile.feature === 'Geothermal_Fissure') {
                    return false;
                }
                // Check for reef terrain
                if (tile.terrain === 'Reef') {
                    return false;
                }
                // Check for strategic or luxury resources
                if (tile.resource && resourcesData) {
                    const isStrategic = resourcesData.strategic_resources.some(r => r.name === tile.resource);
                    const isLuxury = resourcesData.luxury_resources.some(r => r.name === tile.resource);
                    if (isStrategic || isLuxury) {
                        return false;
                    }
                }
                
                // Check allowed terrain and/or features
                // If both exist, placement is valid if EITHER terrain OR feature matches
                const hasAllowedTerrain = itemData.allowed_terrain && itemData.allowed_terrain.length > 0;
                const hasAllowedFeatures = itemData.allowed_features && itemData.allowed_features.length > 0;
                
                if (hasAllowedTerrain || hasAllowedFeatures) {
                    let terrainMatches = false;
                    let featureMatches = false;
                    
                    if (hasAllowedTerrain) {
                        terrainMatches = itemData.allowed_terrain.includes(tile.terrain);
                    }
                    
                    if (hasAllowedFeatures) {
                        featureMatches = tile.feature && itemData.allowed_features.includes(tile.feature);
                    }
                    
                    // If both exist, either one can match. If only one exists, that one must match.
                    if (hasAllowedTerrain && hasAllowedFeatures) {
                        // Either terrain OR feature must match
                        if (!terrainMatches && !featureMatches) {
                            return false;
                        }
                    } else if (hasAllowedTerrain && !terrainMatches) {
                        return false;
                    } else if (hasAllowedFeatures && !featureMatches) {
                        return false;
                    }
                }
                
                // Check required feature adjacency
                // Note: This can be either a tile feature (like "Marsh", "Rainforest") or an improvement name (like "Camp")
                if (itemData.required_feature_adjacency && itemData.required_feature_adjacency.length > 0) {
                    const neighbors = getNeighbors(row, col);
                    let hasRequiredFeature = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        const neighborPlaced = placedItems[neighborKey];
                        
                        // Check if it's a tile feature
                        if (neighborTile && neighborTile.feature && itemData.required_feature_adjacency.includes(neighborTile.feature)) {
                            hasRequiredFeature = true;
                            break;
                        }
                        
                        // Check if it's a placed improvement with that name
                        if (neighborPlaced && neighborPlaced.type === 'improvement' && itemData.required_feature_adjacency.includes(neighborPlaced.name)) {
                            hasRequiredFeature = true;
                            break;
                        }
                    }
                    if (!hasRequiredFeature) return false;
                }
                
                // Check required resource adjacency
                if (itemData.required_resource_adjacency && itemData.required_resource_adjacency.length > 0) {
                    const neighbors = getNeighbors(row, col);
                    let hasRequiredResource = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        const neighborPlaced = placedItems[neighborKey];
                        
                        // Skip if this is the excluded location (when moving)
                        if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                            continue;
                        }
                        
                        // Resource only counts if there's no district/improvement/wonder on the tile
                        // Districts/improvements/wonders placed on bonus resources "cover" them
                        if (neighborTile && neighborTile.resource && 
                            itemData.required_resource_adjacency.includes(neighborTile.resource) &&
                            !neighborPlaced) {
                            hasRequiredResource = true;
                            break;
                        }
                    }
                    if (!hasRequiredResource) return false;
                }
                
                // Check required district adjacency
                if (itemData.required_district_adjacency && itemData.required_district_adjacency.length > 0) {
                    const neighbors = getNeighbors(row, col);
                    let hasRequiredDistrict = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const placed = placedItems[neighborKey];
                        if (placed && placed.type === 'district' && itemData.required_district_adjacency.includes(placed.name)) {
                            hasRequiredDistrict = true;
                            break;
                        }
                    }
                    if (!hasRequiredDistrict) return false;
                }
            }
            
            return true;
        }

        // Helper function to find all floodplain tiles connected to a given tile
        function getConnectedFloodplains(startRow, startCol, excludeLocation = null) {
            const connected = new Set();
            const visited = new Set();
            const queue = [{ row: startRow, col: startCol }];
            
            while (queue.length > 0) {
                const current = queue.shift();
                const currentKey = `${current.row},${current.col}`;
                
                // Skip if already visited
                if (visited.has(currentKey)) {
                    continue;
                }
                visited.add(currentKey);
                
                // Skip if this is the excluded location (when moving)
                if (excludeLocation && current.row === excludeLocation.row && current.col === excludeLocation.col) {
                    continue;
                }
                
                // Check if this tile is a floodplain
                const tile = challengeData.tiles[currentKey];
                if (tile && tile.terrain && (
                    tile.terrain === 'Desert_Floodplains' || 
                    tile.terrain === 'Grassland_Floodplains' || 
                    tile.terrain === 'Plains_Floodplains'
                )) {
                    connected.add(currentKey);
                    
                    // Add all neighbors to the queue
                    const neighbors = getNeighbors(current.row, current.col);
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        if (!visited.has(neighborKey)) {
                            queue.push(neighbor);
                        }
                    }
                }
            }
            
            return connected;
        }

        function hasCityCenterAdjacent(row, col) {
            const neighbors = getNeighbors(row, col);
            for (const neighbor of neighbors) {
                const key = `${neighbor.row},${neighbor.col}`;
                const placed = placedItems[key];
                if (placed && placed.type === 'district' && placed.name === 'City_Center') {
                    return true;
                }
            }
            return false;
        }

        function highlightAllTiles(type, name, skipAvailabilityCheck = false, excludeLocation = null) {
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const hexGrid = document.getElementById('hexGrid');
                    if (!hexGrid) continue;
                    const hex = hexGrid.querySelector(`.hex[data-row="${row}"][data-col="${col}"]`);
                    if (!hex) continue;
                    
                    // Remove any existing preview
                    const existingPreview = hex.querySelector('.adjacency-preview');
                    if (existingPreview) {
                        existingPreview.remove();
                    }
                    
                    const key = `${row},${col}`;
                    const tile = challengeData.tiles[key];
                    const existingPlaced = placedItems[key];
                    
                    // Check if placement is valid
                    const isValid = isValidPlacement(row, col, type, name, tile, excludeLocation);
                    const isAvailable = skipAvailabilityCheck || availableItems[name] > 0;
                    
                    // Don't show preview on tiles that already have a district (unless we're moving that same district)
                    const hasExistingDistrict = existingPlaced && existingPlaced.type === 'district';
                    const isMovingSameDistrict = excludeLocation && excludeLocation.row === row && excludeLocation.col === col;
                    const shouldShowPreview = !hasExistingDistrict || isMovingSameDistrict;
                    
                    if (isValid && isAvailable) {
                        hex.classList.add('valid-placement');
                        hex.classList.remove('invalid-placement');
                        
                        // If dragging a district, show adjacency preview (only if no existing district or moving the same one)
                        if (type === 'district' && shouldShowPreview) {
                            const preview = calculateAdjacencyPreview(row, col, name, excludeLocation);
                            if (preview && preview.total > 0) {
                                const previewIndicator = document.createElement('div');
                                previewIndicator.className = 'adjacency-preview';
                                
                                const yieldTypes = [
                                    { name: 'Science', value: preview.science, icon: 'assets/yields/Science.webp' },
                                    { name: 'Faith', value: preview.faith, icon: 'assets/yields/Faith.webp' },
                                    { name: 'Gold', value: preview.gold, icon: 'assets/yields/Gold.webp' },
                                    { name: 'Production', value: preview.production, icon: 'assets/yields/Production.webp' },
                                    { name: 'Culture', value: preview.culture, icon: 'assets/yields/Culture.webp' }
                                ];
                                
                                yieldTypes.forEach(yieldType => {
                                    if (yieldType.value > 0) {
                                        const badge = document.createElement('div');
                                        badge.className = 'yield-badge';
                                        
                                        const amount = document.createElement('span');
                                        amount.className = 'yield-amount';
                                        amount.textContent = `+${yieldType.value}`;
                                        
                                        const icon = document.createElement('img');
                                        icon.className = 'yield-icon';
                                        icon.src = yieldType.icon;
                                        icon.alt = yieldType.name;
                                        icon.draggable = false;
                                        
                                        badge.appendChild(amount);
                                        badge.appendChild(icon);
                                        previewIndicator.appendChild(badge);
                                    }
                                });
                                
                                hex.appendChild(previewIndicator);
                            }
                        }
                    } else {
                        hex.classList.add('invalid-placement');
                        hex.classList.remove('valid-placement');
                    }
                }
            }
        }

        function clearAllHighlights() {
            const hexGrid = document.getElementById('hexGrid');
            if (!hexGrid) return;
            
            const allHexes = hexGrid.querySelectorAll('.hex');
            allHexes.forEach(hex => {
                hex.classList.remove('valid-placement');
                hex.classList.remove('invalid-placement');
                // Remove any adjacency previews
                const preview = hex.querySelector('.adjacency-preview');
                if (preview) {
                    preview.remove();
                }
            });
        }

        function calculateAdjacencyPreview(row, col, districtName, excludeLocation = null) {
            // Calculate what adjacency would be if this district were placed here
            const districtBonus = adjacencyData.district_adjacency_bonuses.find(d => d.name === districtName);
            if (!districtBonus) return null;
            
            const key = `${row},${col}`;
            const tile = challengeData.tiles[key];
            const neighbors = getNeighbors(row, col);
            
            let science = 0;
            let faith = 0;
            let gold = 0;
            let production = 0;
            let culture = 0;
            
            const bonuses = districtBonus.adjacency_bonuses;
            
            // Check for river edges on this tile (River_Edge is about the tile itself having a river)
            if (tile && tile.rivers) {
                let hasRiver = false;
                for (let i = 0; i < 6; i++) {
                    if (tile.rivers[i]) {
                        hasRiver = true;
                        break;
                    }
                }
                if (hasRiver && bonuses.River_Edge) {
                    const bonus = bonuses.River_Edge;
                    if (bonus.type === 'Gold') gold += bonus.bonus;
                }
            }
            
            // Check neighbors for terrain, features, and resources
            let districtCount = 0;
            let cityCenterCount = 0;
            let harborCount = 0;
            let commercialHubCount = 0;
            let wonderCount = 0;
            let entertainmentComplexCount = 0;
            let waterParkCount = 0;
            let governmentPlazaCount = 0;
            let aqueductCount = 0;
            let damCount = 0;
            let canalCount = 0;
            let improvementCounts = {};
            let mountainCount = 0;
            let rainforestCount = 0;
            let woodsCount = 0;
            let geothermalFissureCount = 0;
            let reefCount = 0;
            let coastalResourceCount = 0;
            let naturalWonderCount = 0;
            
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborPlaced = placedItems[neighborKey];
                const neighborTile = challengeData.tiles[neighborKey];
                
                // Check if this is the excluded location (when moving a district)
                const isExcludedLocation = excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col;
                
                // Check neighbor terrain/features for adjacency bonuses
                // Only count terrain/features if the tile doesn't have a district or improvement on it
                // OR if it's the excluded location (the district is being moved, so check underlying tile)
                if (neighborTile && (!neighborPlaced || isExcludedLocation)) {
                    // Check for mountains
                    if (neighborTile.terrain && neighborTile.terrain.includes('Mountain')) {
                        mountainCount++;
                    }
                    // Check for natural wonders
                    if (neighborTile.terrain && NATURAL_WONDER_TERRAINS.has(neighborTile.terrain)) {
                        naturalWonderCount++;
                    }
                    // Check for features
                    if (neighborTile.feature === 'Rainforest') {
                        rainforestCount++;
                    }
                    if (neighborTile.feature === 'Woods') {
                        woodsCount++;
                    }
                    // Check for reef
                    if (neighborTile.terrain === 'Reef') {
                        reefCount++;
                    }
                    // Check for coastal resources (resources on coast/ocean/reef tiles)
                    // Coastal resources count even if there's a district on the tile (when moving)
                    if (neighborTile.resource && (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                        coastalResourceCount++;
                    }
                }
                
                // Special case: Geothermal Fissures count even if there's a City_Center on the tile
                // This is unique to geothermal fissures - other features don't count if there's a district
                if (neighborTile && neighborTile.feature === 'Geothermal_Fissure') {
                    if (!neighborPlaced || (neighborPlaced.type === 'district' && neighborPlaced.name === 'City_Center') || isExcludedLocation) {
                        geothermalFissureCount++;
                    }
                }
                
                // Skip excluded location for district/improvement counting
                if (isExcludedLocation) {
                    return;
                }
                
                if (neighborPlaced) {
                    if (neighborPlaced.type === 'district') {
                        districtCount++;
                        if (neighborPlaced.name === 'City_Center') cityCenterCount++;
                        if (neighborPlaced.name === 'Harbor') harborCount++;
                        if (neighborPlaced.name === 'Commercial_Hub') commercialHubCount++;
                        if (neighborPlaced.name === 'Government_Plaza') governmentPlazaCount++;
                        if (neighborPlaced.name === 'Entertainment_Complex') entertainmentComplexCount++;
                        if (neighborPlaced.name === 'Water_Park') waterParkCount++;
                        if (neighborPlaced.name === 'Aqueduct') aqueductCount++;
                        if (neighborPlaced.name === 'Dam') damCount++;
                        if (neighborPlaced.name === 'Canal') canalCount++;
                    } else if (neighborPlaced.type === 'wonder') {
                        wonderCount++;
                    } else if (neighborPlaced.type === 'improvement') {
                        improvementCounts[neighborPlaced.name] = (improvementCounts[neighborPlaced.name] || 0) + 1;
                    }
                }
            });
            
            // Apply terrain/feature bonuses from neighbors
            if (bonuses.Mountain && mountainCount > 0) {
                const bonus = bonuses.Mountain;
                const amount = mountainCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
            }
            
            if (bonuses.Rainforest && rainforestCount > 0) {
                const bonus = bonuses.Rainforest;
                const amount = Math.floor(rainforestCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Woods && woodsCount > 0) {
                const bonus = bonuses.Woods;
                const amount = Math.floor(woodsCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Faith') faith += amount;
            }
            
            if (bonuses.Geothermal_Fissure && geothermalFissureCount > 0) {
                const bonus = bonuses.Geothermal_Fissure;
                const amount = geothermalFissureCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Reef && reefCount > 0) {
                const bonus = bonuses.Reef;
                const amount = reefCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Natural_Wonder && naturalWonderCount > 0) {
                const bonus = bonuses.Natural_Wonder;
                const amount = naturalWonderCount * bonus.bonus;
                if (bonus.type === 'Faith') faith += amount;
            }
            
            if (bonuses.Coastal_Resources && coastalResourceCount > 0) {
                const bonus = bonuses.Coastal_Resources;
                const amount = coastalResourceCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            // Apply bonuses (same logic as calculateAdjacency)
            if (bonuses.all_districts && districtCount > 0) {
                const bonus = bonuses.all_districts;
                const amount = Math.floor(districtCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.City_Center && cityCenterCount > 0) {
                const bonus = bonuses.City_Center;
                const amount = cityCenterCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Harbor && harborCount > 0) {
                const bonus = bonuses.Harbor;
                const amount = harborCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Commercial_Hub && commercialHubCount > 0) {
                const bonus = bonuses.Commercial_Hub;
                const amount = commercialHubCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Government_Plaza && governmentPlazaCount > 0) {
                const bonus = bonuses.Government_Plaza;
                const amount = governmentPlazaCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Wonder && wonderCount > 0) {
                const bonus = bonuses.Wonder;
                const amount = wonderCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Entertainment_Complex && entertainmentComplexCount > 0) {
                const bonus = bonuses.Entertainment_Complex;
                const amount = entertainmentComplexCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Water_Park && waterParkCount > 0) {
                const bonus = bonuses.Water_Park;
                const amount = waterParkCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Mine && improvementCounts.Mine) {
                const bonus = bonuses.Mine;
                const amount = Math.floor(improvementCounts.Mine / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Lumber_Mill && improvementCounts.Lumber_Mill) {
                const bonus = bonuses.Lumber_Mill;
                const amount = Math.floor(improvementCounts.Lumber_Mill / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Quarry && improvementCounts.Quarry) {
                const bonus = bonuses.Quarry;
                const amount = improvementCounts.Quarry * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Aqueduct && aqueductCount > 0) {
                const bonus = bonuses.Aqueduct;
                const amount = aqueductCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Dam && damCount > 0) {
                const bonus = bonuses.Dam;
                const amount = damCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Canal && canalCount > 0) {
                const bonus = bonuses.Canal;
                const amount = canalCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            let strategicResourceCount = 0;
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborTile = challengeData.tiles[neighborKey];
                if (neighborTile && neighborTile.resource) {
                    const resourceInfo = resourcesData.strategic_resources.find(r => r.name === neighborTile.resource);
                    if (resourceInfo) {
                        strategicResourceCount++;
                    }
                }
            });
            
            if (bonuses.Strategic_Resource && strategicResourceCount > 0) {
                const bonus = bonuses.Strategic_Resource;
                const amount = strategicResourceCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            return {
                science,
                faith,
                gold,
                production,
                culture,
                total: science + faith + gold + production + culture
            };
        }

        function getHexDistance(row1, col1, row2, col2) {
            // Convert offset coordinates to cube coordinates for distance calculation
            // Using odd-r offset system
            const q1 = col1 - (row1 - (row1 & 1)) / 2;
            const r1 = row1;
            const s1 = -q1 - r1;
            
            const q2 = col2 - (row2 - (row2 & 1)) / 2;
            const r2 = row2;
            const s2 = -q2 - r2;
            
            // Hex distance formula
            return (Math.abs(q1 - q2) + Math.abs(r1 - r2) + Math.abs(s1 - s2)) / 2;
        }

        // Helper function to check if a city center owns (or could own via ambiguous ownership) a district of a type
        function cityCenterOwnsDistrictType(cityKey, districtName, excludeDistrictKey = null) {
            for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                if (districtKey === excludeDistrictKey) continue;
                if (districtPlaced.type !== 'district' || districtPlaced.name !== districtName) continue;
                
                // Check if this district is owned by (or could be owned by) this city center
                if (Array.isArray(districtPlaced.owner)) {
                    // Ambiguous owner - check if city center is in the array
                    if (districtPlaced.owner.includes(cityKey)) {
                        return true;
                    }
                } else if (districtPlaced.owner === cityKey) {
                    // Direct owner
                    return true;
                }
            }
            return false;
        }

        // Helper function to get all possible city center owners for a district at a location
        function getPossibleOwners(row, col, districtName, excludeLocation = null) {
            const possibleOwners = [];
            
            // Dam, Neighborhood, and Canal have no owners - return empty array
            if (districtName === 'Dam' || districtName === 'Neighborhood' || districtName === 'Canal') {
                return [];
            }
            
            // First, check if this district is adjacent to any City_Center (first ring)
            const neighbors = getNeighbors(row, col);
            let adjacentCityCenter = null;
            for (const neighbor of neighbors) {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborPlaced = placedItems[neighborKey];
                
                // Skip if this is the excluded location
                if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                    continue;
                }
                
                if (neighborPlaced && neighborPlaced.type === 'district' && neighborPlaced.name === 'City_Center') {
                    adjacentCityCenter = neighborKey;
                    break;
                }
            }
            
            if (adjacentCityCenter) {
                // District is in a City_Center's first ring - must be owned by that City_Center
                return [adjacentCityCenter];
            } else {
                // District is not adjacent to any City_Center, find all City_Centers within 3 tiles
                // But exclude City_Centers that have this district in their first ring
                for (const [cityKey, cityPlaced] of Object.entries(placedItems)) {
                    if (cityPlaced.type !== 'district' || cityPlaced.name !== 'City_Center') continue;
                    
                    const [cityRow, cityCol] = cityKey.split(',').map(Number);
                    
                    // Skip if this is the excluded location
                    if (excludeLocation && cityRow === excludeLocation.row && cityCol === excludeLocation.col) {
                        continue;
                    }
                    
                    // Check if this district is in another City_Center's first ring
                    const cityNeighbors = getNeighbors(cityRow, cityCol);
                    let isInAnotherCityFirstRing = false;
                    for (const cityNeighbor of cityNeighbors) {
                        if (cityNeighbor.row === row && cityNeighbor.col === col) {
                            isInAnotherCityFirstRing = true;
                            break;
                        }
                    }
                    
                    if (isInAnotherCityFirstRing) {
                        continue; // Skip this City_Center
                    }
                    
                    const distance = getHexDistance(row, col, cityRow, cityCol);
                    if (distance <= 3) {
                        // Check if this City_Center already owns a district of this type
                        // Exception: Dam, Neighborhood, and Canal can have multiple instances per city (no ownership restriction)
                        // But consider ambiguous owners - if a district has ambiguous owners including this city,
                        // we can still add this city as a possible owner (allows swapping)
                        let alreadyOwns = false;
                        
                        if (districtName !== 'Dam' && districtName !== 'Neighborhood' && districtName !== 'Canal') {
                        for (const [districtKey, districtPlaced] of Object.entries(placedItems)) {
                            if (districtPlaced.type !== 'district' || districtPlaced.name !== districtName) continue;
                            
                            // Skip if this is the excluded location (old location when moving)
                            if (excludeLocation) {
                                const [districtRow, districtCol] = districtKey.split(',').map(Number);
                                if (districtRow === excludeLocation.row && districtCol === excludeLocation.col) {
                                    continue;
                                }
                            }
                            
                            // Skip if this is the current location (new location when moving)
                            // The district being assigned ownership is already at this location
                            const [districtRow, districtCol] = districtKey.split(',').map(Number);
                            if (districtRow === row && districtCol === col) {
                                continue;
                            }
                            
                            // Check if this district is owned by this city center
                            if (Array.isArray(districtPlaced.owner)) {
                                // Ambiguous owner - check if this city is included
                                if (districtPlaced.owner.includes(cityKey)) {
                                    // If this city is the ONLY owner (array with 1 element), it's taken
                                    if (districtPlaced.owner.length === 1) {
                                        alreadyOwns = true;
                                        break;
                                    }
                                    // If this city is one of MULTIPLE owners, we can still add this city
                                    // The ambiguous ownership allows flexibility - the existing district could
                                    // belong to one of the other cities, freeing up this city for the new district
                                }
                            } else if (districtPlaced.owner === cityKey) {
                                // Direct owner (not ambiguous) - city center already owns this type
                                alreadyOwns = true;
                                break;
                            }
                            }
                        }
                        
                        // Add this city center as a possible owner if it doesn't already own this type
                        // (or if it owns it ambiguously, which allows swapping)
                        if (!alreadyOwns) {
                            possibleOwners.push(cityKey);
                        }
                    }
                }
            }
            
            return possibleOwners;
        }

        // Helper function to assign ownership to a district (supports ambiguous owners)
        function assignDistrictOwnership(districtKey, row, col, districtName, excludeLocation = null) {
            const district = placedItems[districtKey];
            if (!district || district.type !== 'district' || district.name !== districtName) {
                return;
            }
            
            const possibleOwners = getPossibleOwners(row, col, districtName, excludeLocation);
            
            if (possibleOwners.length === 0) {
                // No valid owner - remove ownership
                delete district.owner;
            } else if (possibleOwners.length === 1) {
                // Single owner - assign directly (not ambiguous)
                district.owner = possibleOwners[0];
            } else {
                // Multiple possible owners - assign as ambiguous (array)
                // This allows the district to belong to any of these city centers
                district.owner = possibleOwners;
            }
        }

        // Helper function to check if two districts of the same type can swap positions and owners
        function canDistrictsSwap(district1Key, district2Key) {
            const district1 = placedItems[district1Key];
            const district2 = placedItems[district2Key];
            
            // Both must be districts of the same type
            if (!district1 || !district2 || 
                district1.type !== 'district' || district2.type !== 'district' ||
                district1.name !== district2.name ||
                district1.name === 'City_Center') {
                return false;
            }
            
            // Get possible owners for both districts
            const [district1Row, district1Col] = district1Key.split(',').map(Number);
            const [district2Row, district2Col] = district2Key.split(',').map(Number);
            
            const district1Owners = getPossibleOwners(district1Row, district1Col, district1.name, { row: district2Row, col: district2Col });
            const district2Owners = getPossibleOwners(district2Row, district2Col, district2.name, { row: district1Row, col: district1Col });
            
            // They can swap if:
            // 1. Both have at least 2 possible owners (ambiguous)
            // 2. The possible owners overlap (they share at least 2 city centers)
            if (district1Owners.length >= 2 && district2Owners.length >= 2) {
                // Check if they share at least 2 city centers
                const sharedOwners = district1Owners.filter(owner => district2Owners.includes(owner));
                return sharedOwners.length >= 2;
            }
            
            return false;
        }

        // Helper function to reassign district ownership to the best available city center
        // This allows districts to swap owners when city centers move
        function reassignDistrictOwnership(districtKey) {
            const district = placedItems[districtKey];
            if (!district || district.type !== 'district' || district.name === 'City_Center') {
                return;
            }
            
            const [districtRow, districtCol] = districtKey.split(',').map(Number);
            assignDistrictOwnership(districtKey, districtRow, districtCol, district.name);
        }

        function getNeighbors(row, col) {
            const neighbors = [];
            const isOddRow = row % 2 === 1;
            
            // For flat-top hexagons:
            // Even rows: neighbors are at same col, col-1, col+1
            // Odd rows: neighbors are at same col, col+1, col+1
            
            // Right neighbor
            if (col < GRID_WIDTH - 1) {
                neighbors.push({ row, col: col + 1 });
            }
            
            // Left neighbor
            if (col > 0) {
                neighbors.push({ row, col: col - 1 });
            }
            
            // Top and bottom neighbors depend on row parity
            if (isOddRow) {
                // Odd row: top neighbors are at row-1, same col and col+1
                if (row > 0) {
                    neighbors.push({ row: row - 1, col });
                    if (col < GRID_WIDTH - 1) {
                        neighbors.push({ row: row - 1, col: col + 1 });
                    }
                }
                // Odd row: bottom neighbors are at row+1, same col and col+1
                if (row < GRID_HEIGHT - 1) {
                    neighbors.push({ row: row + 1, col });
                    if (col < GRID_WIDTH - 1) {
                        neighbors.push({ row: row + 1, col: col + 1 });
                    }
                }
            } else {
                // Even row: top neighbors are at row-1, same col and col-1
                if (row > 0) {
                    neighbors.push({ row: row - 1, col });
                    if (col > 0) {
                        neighbors.push({ row: row - 1, col: col - 1 });
                    }
                }
                // Even row: bottom neighbors are at row+1, same col and col-1
                if (row < GRID_HEIGHT - 1) {
                    neighbors.push({ row: row + 1, col });
                    if (col > 0) {
                        neighbors.push({ row: row + 1, col: col - 1 });
                    }
                }
            }
            
            return neighbors;
        }
        
        function getNeighborAtDirection(row, col, direction) {
            // Directions: 0=Right, 1=Top-right, 2=Top-left, 3=Left, 4=Bottom-left, 5=Bottom-right
            const isOddRow = row % 2 === 1;
            
            switch (direction) {
                case 0: // Right
                    if (col < GRID_WIDTH - 1) {
                        return { row, col: col + 1 };
                    }
                    break;
                case 1: // Top-right
                    if (row > 0) {
                        if (isOddRow) {
                            if (col < GRID_WIDTH - 1) {
                                return { row: row - 1, col: col + 1 };
                            }
                        } else {
                            return { row: row - 1, col };
                        }
                    }
                    break;
                case 2: // Top-left
                    if (row > 0) {
                        if (isOddRow) {
                            return { row: row - 1, col };
                        } else {
                            if (col > 0) {
                                return { row: row - 1, col: col - 1 };
                            }
                        }
                    }
                    break;
                case 3: // Left
                    if (col > 0) {
                        return { row, col: col - 1 };
                    }
                    break;
                case 4: // Bottom-left
                    if (row < GRID_HEIGHT - 1) {
                        if (isOddRow) {
                            return { row: row + 1, col };
                        } else {
                            if (col > 0) {
                                return { row: row + 1, col: col - 1 };
                            }
                        }
                    }
                    break;
                case 5: // Bottom-right
                    if (row < GRID_HEIGHT - 1) {
                        if (isOddRow) {
                            if (col < GRID_WIDTH - 1) {
                                return { row: row + 1, col: col + 1 };
                            }
                        } else {
                            return { row: row + 1, col };
                        }
                    }
                    break;
            }
            return null;
        }

        function calculateAdjacency(row, col) {
            const key = `${row},${col}`;
            const placed = placedItems[key];
            if (!placed || placed.type !== 'district') return null;
            
            const districtName = placed.name;
            const districtBonus = adjacencyData.district_adjacency_bonuses.find(d => d.name === districtName);
            if (!districtBonus) return null;
            
            const tile = challengeData.tiles[key];
            const neighbors = getNeighbors(row, col);
            
            let science = 0;
            let faith = 0;
            let gold = 0;
            let production = 0;
            let culture = 0;
            
            const bonuses = districtBonus.adjacency_bonuses;
            
            // Check for river edges on this tile (River_Edge is about the tile itself having a river)
            if (tile && tile.rivers) {
                    let hasRiver = false;
                    for (let i = 0; i < 6; i++) {
                        if (tile.rivers[i]) {
                            hasRiver = true;
                            break;
                        }
                    }
                    if (hasRiver && bonuses.River_Edge) {
                        const bonus = bonuses.River_Edge;
                        if (bonus.type === 'Gold') gold += bonus.bonus;
                }
            }
            
            // Check neighbors for terrain, features, and resources
            let districtCount = 0;
            let cityCenterCount = 0;
            let harborCount = 0;
            let commercialHubCount = 0;
            let wonderCount = 0;
            let entertainmentComplexCount = 0;
            let waterParkCount = 0;
            let governmentPlazaCount = 0;
            let aqueductCount = 0;
            let damCount = 0;
            let canalCount = 0;
            let improvementCounts = {};
            let mountainCount = 0;
            let rainforestCount = 0;
            let woodsCount = 0;
            let geothermalFissureCount = 0;
            let reefCount = 0;
            let coastalResourceCount = 0;
            let naturalWonderCount = 0;
            
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborPlaced = placedItems[neighborKey];
                const neighborTile = challengeData.tiles[neighborKey];
                
                // Check neighbor terrain/features for adjacency bonuses
                // Only count terrain/features if the tile doesn't have a district or improvement on it
                if (neighborTile && !neighborPlaced) {
                    // Check for mountains
                    if (neighborTile.terrain && neighborTile.terrain.includes('Mountain')) {
                        mountainCount++;
                    }
                    // Check for natural wonders
                    if (neighborTile.terrain && NATURAL_WONDER_TERRAINS.has(neighborTile.terrain)) {
                        naturalWonderCount++;
                    }
                    // Check for features
                    if (neighborTile.feature === 'Rainforest') {
                        rainforestCount++;
                    }
                    if (neighborTile.feature === 'Woods') {
                        woodsCount++;
                    }
                    // Check for reef
                    if (neighborTile.terrain === 'Reef') {
                        reefCount++;
                    }
                    // Check for coastal resources (resources on coast/ocean/reef tiles)
                    if (neighborTile.resource && (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                        coastalResourceCount++;
                    }
                }
                
                // Special case: Geothermal Fissures count even if there's a City_Center on the tile
                // This is unique to geothermal fissures - other features don't count if there's a district
                if (neighborTile && neighborTile.feature === 'Geothermal_Fissure') {
                    if (!neighborPlaced || (neighborPlaced.type === 'district' && neighborPlaced.name === 'City_Center')) {
                        geothermalFissureCount++;
                    }
                }
                
                if (neighborPlaced) {
                    if (neighborPlaced.type === 'district') {
                        districtCount++;
                        if (neighborPlaced.name === 'City_Center') cityCenterCount++;
                        if (neighborPlaced.name === 'Harbor') harborCount++;
                        if (neighborPlaced.name === 'Commercial_Hub') commercialHubCount++;
                        if (neighborPlaced.name === 'Government_Plaza') governmentPlazaCount++;
                        if (neighborPlaced.name === 'Entertainment_Complex') entertainmentComplexCount++;
                        if (neighborPlaced.name === 'Water_Park') waterParkCount++;
                        if (neighborPlaced.name === 'Aqueduct') aqueductCount++;
                        if (neighborPlaced.name === 'Dam') damCount++;
                        if (neighborPlaced.name === 'Canal') canalCount++;
                    } else if (neighborPlaced.type === 'wonder') {
                        wonderCount++;
                    } else if (neighborPlaced.type === 'improvement') {
                        improvementCounts[neighborPlaced.name] = (improvementCounts[neighborPlaced.name] || 0) + 1;
                    }
                }
            });
            
            // Apply terrain/feature bonuses from neighbors
            if (bonuses.Mountain && mountainCount > 0) {
                const bonus = bonuses.Mountain;
                const amount = mountainCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
            }
            
            if (bonuses.Rainforest && rainforestCount > 0) {
                const bonus = bonuses.Rainforest;
                const amount = Math.floor(rainforestCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Woods && woodsCount > 0) {
                const bonus = bonuses.Woods;
                const amount = Math.floor(woodsCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Faith') faith += amount;
            }
            
            if (bonuses.Geothermal_Fissure && geothermalFissureCount > 0) {
                const bonus = bonuses.Geothermal_Fissure;
                const amount = geothermalFissureCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Reef && reefCount > 0) {
                const bonus = bonuses.Reef;
                const amount = reefCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Natural_Wonder && naturalWonderCount > 0) {
                const bonus = bonuses.Natural_Wonder;
                const amount = naturalWonderCount * bonus.bonus;
                if (bonus.type === 'Faith') faith += amount;
            }
            
            if (bonuses.Coastal_Resources && coastalResourceCount > 0) {
                const bonus = bonuses.Coastal_Resources;
                const amount = coastalResourceCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            // Apply bonuses
            if (bonuses.all_districts && districtCount > 0) {
                const bonus = bonuses.all_districts;
                const amount = Math.floor(districtCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.City_Center && cityCenterCount > 0) {
                const bonus = bonuses.City_Center;
                const amount = cityCenterCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Harbor && harborCount > 0) {
                const bonus = bonuses.Harbor;
                const amount = harborCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Commercial_Hub && commercialHubCount > 0) {
                const bonus = bonuses.Commercial_Hub;
                const amount = commercialHubCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Government_Plaza && governmentPlazaCount > 0) {
                const bonus = bonuses.Government_Plaza;
                const amount = governmentPlazaCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Wonder && wonderCount > 0) {
                const bonus = bonuses.Wonder;
                const amount = wonderCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Entertainment_Complex && entertainmentComplexCount > 0) {
                const bonus = bonuses.Entertainment_Complex;
                const amount = entertainmentComplexCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Water_Park && waterParkCount > 0) {
                const bonus = bonuses.Water_Park;
                const amount = waterParkCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            // Check improvements
            if (bonuses.Mine && improvementCounts.Mine) {
                const bonus = bonuses.Mine;
                const amount = Math.floor(improvementCounts.Mine / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Lumber_Mill && improvementCounts.Lumber_Mill) {
                const bonus = bonuses.Lumber_Mill;
                const amount = Math.floor(improvementCounts.Lumber_Mill / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Quarry && improvementCounts.Quarry) {
                const bonus = bonuses.Quarry;
                const amount = improvementCounts.Quarry * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Aqueduct && aqueductCount > 0) {
                const bonus = bonuses.Aqueduct;
                const amount = aqueductCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Dam && damCount > 0) {
                const bonus = bonuses.Dam;
                const amount = damCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Canal && canalCount > 0) {
                const bonus = bonuses.Canal;
                const amount = canalCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            // Check for strategic resources
            let strategicResourceCount = 0;
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborTile = challengeData.tiles[neighborKey];
                if (neighborTile && neighborTile.resource) {
                    const resourceInfo = resourcesData.strategic_resources.find(r => r.name === neighborTile.resource);
                    if (resourceInfo) {
                        strategicResourceCount++;
                    }
                }
            });
            
            if (bonuses.Strategic_Resource && strategicResourceCount > 0) {
                const bonus = bonuses.Strategic_Resource;
                const amount = strategicResourceCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            return {
                science,
                faith,
                gold,
                production,
                culture,
                total: science + faith + gold + production + culture
            };
        }

        function getAdjacencySources(row, col) {
            const key = `${row},${col}`;
            const placed = placedItems[key];
            if (!placed || placed.type !== 'district') return [];
            
            const districtName = placed.name;
            const districtBonus = adjacencyData.district_adjacency_bonuses.find(d => d.name === districtName);
            if (!districtBonus) return [];
            
            const tile = challengeData.tiles[key];
            const neighbors = getNeighbors(row, col);
            const sources = [];
            const bonuses = districtBonus.adjacency_bonuses;
            
            // Check for river edges on this tile
            if (tile && tile.rivers) {
                let hasRiver = false;
                for (let i = 0; i < 6; i++) {
                    if (tile.rivers[i]) {
                        hasRiver = true;
                        break;
                    }
                }
                if (hasRiver && bonuses.River_Edge) {
                    sources.push({ type: 'River_Edge', count: 1, bonus: bonuses.River_Edge });
                }
            }
            
            // Count neighbors
            let districtCount = 0;
            let cityCenterCount = 0;
            let harborCount = 0;
            let commercialHubCount = 0;
            let wonderCount = 0;
            const wonderNames = [];
            let entertainmentComplexCount = 0;
            let waterParkCount = 0;
            let governmentPlazaCount = 0;
            let aqueductCount = 0;
            let damCount = 0;
            let canalCount = 0;
            let improvementCounts = {};
            let mountainCount = 0;
            let rainforestCount = 0;
            let geothermalFissureCount = 0;
            let reefCount = 0;
            let coastalResourceCount = 0;
            let naturalWonderCount = 0;
            
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborPlaced = placedItems[neighborKey];
                const neighborTile = challengeData.tiles[neighborKey];
                
                // Check neighbor terrain/features for adjacency bonuses
                if (neighborTile && !neighborPlaced) {
                    if (neighborTile.terrain && neighborTile.terrain.includes('Mountain')) {
                        mountainCount++;
                    }
                    if (neighborTile.terrain && NATURAL_WONDER_TERRAINS.has(neighborTile.terrain)) {
                        naturalWonderCount++;
                    }
                    if (neighborTile.feature === 'Rainforest') {
                        rainforestCount++;
                    }
                    if (neighborTile.terrain === 'Reef') {
                        reefCount++;
                    }
                }
                
                // Coastal resources count even if there's a district on the tile
                if (neighborTile && neighborTile.resource && (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                    coastalResourceCount++;
                }
                
                // Special case: Geothermal Fissures count even if there's a City_Center on the tile
                if (neighborTile && neighborTile.feature === 'Geothermal_Fissure') {
                    if (!neighborPlaced || (neighborPlaced.type === 'district' && neighborPlaced.name === 'City_Center')) {
                        geothermalFissureCount++;
                    }
                }
                
                if (neighborPlaced) {
                    if (neighborPlaced.type === 'district') {
                        districtCount++;
                        if (neighborPlaced.name === 'City_Center') cityCenterCount++;
                        if (neighborPlaced.name === 'Harbor') harborCount++;
                        if (neighborPlaced.name === 'Commercial_Hub') commercialHubCount++;
                        if (neighborPlaced.name === 'Government_Plaza') governmentPlazaCount++;
                        if (neighborPlaced.name === 'Entertainment_Complex') entertainmentComplexCount++;
                        if (neighborPlaced.name === 'Water_Park') waterParkCount++;
                        if (neighborPlaced.name === 'Aqueduct') aqueductCount++;
                        if (neighborPlaced.name === 'Dam') damCount++;
                        if (neighborPlaced.name === 'Canal') canalCount++;
                    } else if (neighborPlaced.type === 'improvement') {
                        improvementCounts[neighborPlaced.name] = (improvementCounts[neighborPlaced.name] || 0) + 1;
                    } else if (neighborPlaced.type === 'wonder') {
                        wonderCount++;
                        if (!wonderNames.includes(neighborPlaced.name)) {
                            wonderNames.push(neighborPlaced.name);
                        }
                    }
                }
            });
            
            // Add sources based on what bonuses exist
            // Check for all_districts bonus (per 2 districts)
            if (bonuses.all_districts && districtCount > 0) {
                sources.push({ type: 'District', count: districtCount, bonus: bonuses.all_districts, isAllDistricts: true });
            } else if (bonuses.District && districtCount > 0) {
                sources.push({ type: 'District', count: districtCount, bonus: bonuses.District });
            }
            if (bonuses.City_Center && cityCenterCount > 0) {
                sources.push({ type: 'City_Center', count: cityCenterCount, bonus: bonuses.City_Center });
            }
            if (bonuses.Harbor && harborCount > 0) {
                sources.push({ type: 'Harbor', count: harborCount, bonus: bonuses.Harbor });
            }
            if (bonuses.Commercial_Hub && commercialHubCount > 0) {
                sources.push({ type: 'Commercial_Hub', count: commercialHubCount, bonus: bonuses.Commercial_Hub });
            }
            if (bonuses.Wonder && wonderCount > 0) {
                sources.push({ type: 'Wonder', count: wonderCount, bonus: bonuses.Wonder, wonderNames: wonderNames });
            }
            if (bonuses.Entertainment_Complex && entertainmentComplexCount > 0) {
                sources.push({ type: 'Entertainment_Complex', count: entertainmentComplexCount, bonus: bonuses.Entertainment_Complex });
            }
            if (bonuses.Water_Park && waterParkCount > 0) {
                sources.push({ type: 'Water_Park', count: waterParkCount, bonus: bonuses.Water_Park });
            }
            if (bonuses.Government_Plaza && governmentPlazaCount > 0) {
                sources.push({ type: 'Government_Plaza', count: governmentPlazaCount, bonus: bonuses.Government_Plaza });
            }
            if (bonuses.Aqueduct && aqueductCount > 0) {
                sources.push({ type: 'Aqueduct', count: aqueductCount, bonus: bonuses.Aqueduct });
            }
            if (bonuses.Dam && damCount > 0) {
                sources.push({ type: 'Dam', count: damCount, bonus: bonuses.Dam });
            }
            if (bonuses.Canal && canalCount > 0) {
                sources.push({ type: 'Canal', count: canalCount, bonus: bonuses.Canal });
            }
            if (bonuses.Mountain && mountainCount > 0) {
                sources.push({ type: 'Mountain', count: mountainCount, bonus: bonuses.Mountain });
            }
            if (bonuses.Rainforest && rainforestCount > 0) {
                sources.push({ type: 'Rainforest', count: rainforestCount, bonus: bonuses.Rainforest });
            }
            if (bonuses.Geothermal_Fissure && geothermalFissureCount > 0) {
                sources.push({ type: 'Geothermal_Fissure', count: geothermalFissureCount, bonus: bonuses.Geothermal_Fissure });
            }
            if (bonuses.Reef && reefCount > 0) {
                sources.push({ type: 'Reef', count: reefCount, bonus: bonuses.Reef });
            }
            if (bonuses.Natural_Wonder && naturalWonderCount > 0) {
                sources.push({ type: 'Natural_Wonder', count: naturalWonderCount, bonus: bonuses.Natural_Wonder });
            }
            if (bonuses.Coastal_Resources && coastalResourceCount > 0) {
                // Get actual coastal resources for display
                const coastalResources = [];
                neighbors.forEach(neighbor => {
                    const neighborKey = `${neighbor.row},${neighbor.col}`;
                    const neighborTile = challengeData.tiles[neighborKey];
                    if (neighborTile && neighborTile.resource && (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                        if (!coastalResources.includes(neighborTile.resource)) {
                            coastalResources.push(neighborTile.resource);
                        }
                    }
                });
                sources.push({ type: 'Coastal_Resources', count: coastalResourceCount, bonus: bonuses.Coastal_Resources, resourceNames: coastalResources });
            }
            if (bonuses.Mine && improvementCounts.Mine) {
                sources.push({ type: 'Mine', count: improvementCounts.Mine, bonus: bonuses.Mine });
            }
            if (bonuses.Lumber_Mill && improvementCounts.Lumber_Mill) {
                sources.push({ type: 'Lumber_Mill', count: improvementCounts.Lumber_Mill, bonus: bonuses.Lumber_Mill });
            }
            if (bonuses.Quarry && improvementCounts.Quarry) {
                sources.push({ type: 'Quarry', count: improvementCounts.Quarry, bonus: bonuses.Quarry });
            }
            
            // Check for strategic resources
            let strategicResourceCount = 0;
            const strategicResources = [];
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborTile = challengeData.tiles[neighborKey];
                if (neighborTile && neighborTile.resource) {
                    const resourceInfo = resourcesData.strategic_resources.find(r => r.name === neighborTile.resource);
                    if (resourceInfo) {
                        strategicResourceCount++;
                        if (!strategicResources.includes(neighborTile.resource)) {
                            strategicResources.push(neighborTile.resource);
                        }
                    }
                }
            });
            
            if (bonuses.Strategic_Resource && strategicResourceCount > 0) {
                sources.push({ type: 'Strategic_Resource', count: strategicResourceCount, bonus: bonuses.Strategic_Resource, resourceNames: strategicResources });
            }
            
            return sources;
        }

        function getSourceIconPath(sourceType) {
            // Districts - try to find if it's a district by checking if the file exists pattern
            // Common districts: Campus, Theater_Square, Holy_Site, Encampment, Industrial_Zone, 
            // Commercial_Hub, Harbor, Entertainment_Complex, Water_Park, Government_Plaza,
            // Aqueduct, Dam, Canal, City_Center
            const districtNames = ['Campus', 'Theater_Square', 'Holy_Site', 'Encampment', 'Industrial_Zone',
                'Commercial_Hub', 'Harbor', 'Entertainment_Complex', 'Water_Park', 'Government_Plaza',
                'Aqueduct', 'Dam', 'Canal', 'City_Center'];
            if (districtNames.includes(sourceType)) {
                return `assets/districts/${sourceType}.webp`;
            }
            // Generic "District" - no specific icon
            if (sourceType === 'District') {
                return null;
            }
            // Improvements
            if (sourceType === 'Mine' || sourceType === 'Lumber_Mill' || sourceType === 'Quarry') {
                return `assets/improvements/${sourceType}.webp`;
            }
            // Features
            const feature = features.find(f => f.name === sourceType);
            if (feature) {
                return feature.path;
            }
            // Terrain (Mountain, Reef)
            if (sourceType === 'Mountain') {
                // Use a generic mountain icon - check if we have one
                const mountainTerrain = terrainBases.find(t => t.name.includes('Mountain'));
                if (mountainTerrain) {
                    return mountainTerrain.path;
                }
            }
            if (sourceType === 'Reef') {
                const reefTerrain = terrainBases.find(t => t.name === 'Reef');
                if (reefTerrain) {
                    return reefTerrain.path;
                }
            }
            // Special cases - no icon available
            if (sourceType === 'River_Edge' || sourceType === 'Strategic_Resource' || sourceType === 'Coastal_Resource' || sourceType === 'Wonder') {
                return null; // No icon for these
            }
            return null;
        }

        function formatTooltipContent(row, col) {
            const key = `${row},${col}`;
            const tile = challengeData.tiles[key];
            const placed = placedItems[key];
            
            if (placed && placed.type === 'district') {
                // District tooltip
                const districtName = placed.name;
                const adjacencySources = getAdjacencySources(row, col);
                const districtIconPath = `assets/districts/${districtName}.webp`;
                
                let html = '<div class="tooltip-label">District:</div>';
                html += `<div class="tooltip-value">${districtName.replace(/_/g, ' ')}</div>`;
                
                // Show district icon
                html += '<div class="tooltip-section">';
                html += `<img src="${districtIconPath}" alt="${districtName.replace(/_/g, ' ')}" class="tooltip-icon">`;
                html += '</div>';
                
                // Show adjacency sources (only complete bonuses)
                const completeSources = adjacencySources.filter(source => {
                    // If bonus has a "per" requirement, only show if count meets the threshold
                    if (source.bonus.per && source.bonus.per > 1) {
                        return source.count >= source.bonus.per;
                    }
                    // Otherwise, show if count is at least 1
                    return source.count >= 1;
                });
                
                // Only show adjacency sources section if there are any
                if (completeSources.length > 0) {
                    html += '<div class="tooltip-section">';
                    html += '<div class="tooltip-label">Adjacency Sources:</div>';
                    
                    // Always use bulleted list
                    const listTag = 'ul';
                    const itemTag = 'li';
                    const listStyle = 'list-style-type: disc; padding-left: 20px; margin: 8px 0 0 0;';
                    const itemStyle = 'margin: 4px 0;';
                    const contentStyle = 'display: flex; align-items: center; gap: 6px;';
                    
                    html += `<${listTag} style="${listStyle}">`;
                    completeSources.forEach(source => {
                        const yieldType = source.bonus.type;
                        const yieldIcon = `assets/yields/${yieldType}.webp`;
                        const bonusAmount = source.bonus.per && source.bonus.per > 1 
                            ? Math.floor(source.count / source.bonus.per) * source.bonus.bonus
                            : source.count * source.bonus.bonus;
                        
                        html += `<${itemTag} style="${itemStyle}">`;
                        html += `<span style="${contentStyle}">`;
                        html += `<span>+${bonusAmount}</span>`;
                        html += `<img src="${yieldIcon}" alt="${yieldType}" style="width: 16px; height: 16px; object-fit: contain; margin: 0;">`;
                        
                        // For "all_districts" type, show icons of all adjacent districts
                        if (source.isAllDistricts || (source.type === 'District' && source.bonus.per && source.bonus.per > 1)) {
                            // Get actual adjacent districts (including City_Center)
                            const neighbors = getNeighbors(row, col);
                            const adjacentDistricts = [];
                            neighbors.forEach(neighbor => {
                                const neighborKey = `${neighbor.row},${neighbor.col}`;
                                const neighborPlaced = placedItems[neighborKey];
                                if (neighborPlaced && neighborPlaced.type === 'district') {
                                    adjacentDistricts.push(neighborPlaced.name);
                                }
                            });
                            
                            if (adjacentDistricts.length > 0) {
                                html += `<span style="margin-right: -2px;">(</span>`;
                                adjacentDistricts.forEach((districtName, idx) => {
                                    const districtIconPath = `assets/districts/${districtName}.webp`;
                                    html += `<img src="${districtIconPath}" alt="${districtName.replace(/_/g, ' ')}" style="width: 16px; height: 16px; object-fit: contain; margin: 0;">`;
                                    if (idx < adjacentDistricts.length - 1) {
                                        html += `<span style="margin: -5px;">,</span>`;
                                    }
                                });
                                html += `<span style="margin-left: -2px;">)</span>`;
                            }
                        } else if (source.type === 'Coastal_Resources' && source.resourceNames && source.resourceNames.length > 0) {
                            // Show actual resource icons for coastal resources
                            html += `<span style="margin-right: -2px;">(</span>`;
                            source.resourceNames.forEach((resourceName, idx) => {
                                const resourceIconPath = `assets/recources/${resourceName}.webp`;
                                html += `<img src="${resourceIconPath}" alt="${resourceName.replace(/_/g, ' ')}" style="width: 16px; height: 16px; object-fit: contain; margin: 0;">`;
                                if (idx < source.resourceNames.length - 1) {
                                    html += `<span style="margin: -5px;">,</span>`;
                                }
                            });
                            html += `<span style="margin-left: -2px;">)</span>`;
                        } else if (source.type === 'Strategic_Resource' && source.resourceNames && source.resourceNames.length > 0) {
                            // Show actual resource icons for strategic resources
                            html += `<span style="margin-right: -2px;">(</span>`;
                            source.resourceNames.forEach((resourceName, idx) => {
                                const resourceIconPath = `assets/recources/${resourceName}.webp`;
                                html += `<img src="${resourceIconPath}" alt="${resourceName.replace(/_/g, ' ')}" style="width: 16px; height: 16px; object-fit: contain; margin: 0;">`;
                                if (idx < source.resourceNames.length - 1) {
                                    html += `<span style="margin: -5px;">,</span>`;
                                }
                            });
                            html += `<span style="margin-left: -2px;">)</span>`;
                        } else if (source.type === 'Wonder' && source.wonderNames && source.wonderNames.length > 0) {
                            // Show actual wonder icons for wonders
                            html += `<span style="margin-right: -2px;">(</span>`;
                            source.wonderNames.forEach((wonderName, idx) => {
                                const wonderIconPath = `assets/wonders/${wonderName}.webp`;
                                html += `<img src="${wonderIconPath}" alt="${wonderName.replace(/_/g, ' ')}" style="width: 16px; height: 16px; object-fit: contain; margin: 0;">`;
                                if (idx < source.wonderNames.length - 1) {
                                    html += `<span style="margin: -5px;">,</span>`;
                                }
                            });
                            html += `<span style="margin-left: -2px;">)</span>`;
                        } else {
                            // Regular source icon
                            const sourceIconPath = getSourceIconPath(source.type);
                            if (sourceIconPath) {
                                html += `<span style="margin-right: -2px;">(</span>`;
                                html += `<img src="${sourceIconPath}" alt="${source.type.replace(/_/g, ' ')}" style="width: 16px; height: 16px; object-fit: contain; margin: 0;">`;
                                html += `<span style="margin-left: -2px;">)</span>`;
                            }
                        }
                        html += `</span></${itemTag}>`;
                    });
                    html += `</${listTag}>`;
                    html += '</div>';
                }
                
                // Show underlying tile (same format as terrain tile tooltip)
                if (tile) {
                    html += '<div class="tooltip-section">';
                    html += '<div class="tooltip-label">Terrain Type & Features:</div>';
                    
                    // Show icons and text for terrain, feature, and resource
                    const parts = [];
                    if (tile.terrain) parts.push(tile.terrain.replace(/_/g, ' '));
                    if (tile.feature) parts.push(tile.feature.replace(/_/g, ' '));
                    if (tile.resource) parts.push(tile.resource.replace(/_/g, ' '));
                    
                    if (parts.length > 0) {
                        // Show text first
                        html += `<div class="tooltip-value">${parts.join(', ')}</div>`;
                        // Show icons below text
                        const hasIcons = tile.terrainPath || tile.featurePath || tile.resourcePath;
                        if (hasIcons) {
                            html += '<div class="tooltip-icons">';
                            if (tile.terrainPath) {
                                html += `<img src="${tile.terrainPath}" alt="${tile.terrain || 'Terrain'}" class="tooltip-icon" title="${tile.terrain ? tile.terrain.replace(/_/g, ' ') : 'Terrain'}">`;
                            }
                            if (tile.featurePath) {
                                html += `<img src="${tile.featurePath}" alt="${tile.feature || 'Feature'}" class="tooltip-icon" title="${tile.feature ? tile.feature.replace(/_/g, ' ') : 'Feature'}">`;
                            }
                            if (tile.resourcePath) {
                                html += `<img src="${tile.resourcePath}" alt="${tile.resource || 'Resource'}" class="tooltip-icon" title="${tile.resource ? tile.resource.replace(/_/g, ' ') : 'Resource'}">`;
                            }
                            html += '</div>';
                        }
                    } else {
                        html += '<div class="tooltip-value">None</div>';
                    }
                    html += '</div>';
                }
                
                return html;
            } else if (placed && placed.type === 'improvement') {
                // Improvement tooltip
                const improvementName = placed.name;
                const improvementIconPath = `assets/improvements/${improvementName}.webp`;
                
                let html = '<div class="tooltip-label">Improvement:</div>';
                html += `<div class="tooltip-value">${improvementName.replace(/_/g, ' ')}</div>`;
                
                // Show improvement icon
                html += '<div class="tooltip-section">';
                html += `<img src="${improvementIconPath}" alt="${improvementName.replace(/_/g, ' ')}" class="tooltip-icon">`;
                html += '</div>';
                
                // Show underlying tile (same format as terrain tile tooltip)
                if (tile) {
                    html += '<div class="tooltip-section">';
                    html += '<div class="tooltip-label">Terrain Type & Features:</div>';
                    
                    // Show icons and text for terrain, feature, and resource
                    const parts = [];
                    if (tile.terrain) parts.push(tile.terrain.replace(/_/g, ' '));
                    if (tile.feature) parts.push(tile.feature.replace(/_/g, ' '));
                    if (tile.resource) parts.push(tile.resource.replace(/_/g, ' '));
                    
                    if (parts.length > 0) {
                        // Show text first
                        html += `<div class="tooltip-value">${parts.join(', ')}</div>`;
                        // Show icons below text
                        const hasIcons = tile.terrainPath || tile.featurePath || tile.resourcePath;
                        if (hasIcons) {
                            html += '<div class="tooltip-icons">';
                            if (tile.terrainPath) {
                                html += `<img src="${tile.terrainPath}" alt="${tile.terrain || 'Terrain'}" class="tooltip-icon" title="${tile.terrain ? tile.terrain.replace(/_/g, ' ') : 'Terrain'}">`;
                            }
                            if (tile.featurePath) {
                                html += `<img src="${tile.featurePath}" alt="${tile.feature || 'Feature'}" class="tooltip-icon" title="${tile.feature ? tile.feature.replace(/_/g, ' ') : 'Feature'}">`;
                            }
                            if (tile.resourcePath) {
                                html += `<img src="${tile.resourcePath}" alt="${tile.resource || 'Resource'}" class="tooltip-icon" title="${tile.resource ? tile.resource.replace(/_/g, ' ') : 'Resource'}">`;
                            }
                            html += '</div>';
                        }
                    } else {
                        html += '<div class="tooltip-value">None</div>';
                    }
                    html += '</div>';
                }
                
                return html;
            } else if (placed && placed.type === 'wonder') {
                // Wonder tooltip
                const wonderName = placed.name;
                const wonderIconPath = `assets/wonders/${wonderName}.webp`;
                
                let html = '<div class="tooltip-label">Wonder:</div>';
                html += `<div class="tooltip-value">${wonderName.replace(/_/g, ' ')}</div>`;
                
                // Show wonder icon
                html += '<div class="tooltip-section">';
                html += `<img src="${wonderIconPath}" alt="${wonderName.replace(/_/g, ' ')}" class="tooltip-icon">`;
                html += '</div>';
                
                // Show underlying tile
                if (tile) {
                    html += '<div class="tooltip-section">';
                    html += '<div class="tooltip-label">Terrain Type & Features:</div>';
                    
                    const parts = [];
                    if (tile.terrain) parts.push(tile.terrain.replace(/_/g, ' '));
                    if (tile.feature) parts.push(tile.feature.replace(/_/g, ' '));
                    if (tile.resource) parts.push(tile.resource.replace(/_/g, ' '));
                    
                    if (parts.length > 0) {
                        html += `<div class="tooltip-value">${parts.join(', ')}</div>`;
                        const hasIcons = tile.terrainPath || tile.featurePath || tile.resourcePath;
                        if (hasIcons) {
                            html += '<div class="tooltip-icons">';
                            if (tile.terrainPath) {
                                html += `<img src="${tile.terrainPath}" alt="${tile.terrain || 'Terrain'}" class="tooltip-icon" title="${tile.terrain ? tile.terrain.replace(/_/g, ' ') : 'Terrain'}">`;
                            }
                            if (tile.featurePath) {
                                html += `<img src="${tile.featurePath}" alt="${tile.feature || 'Feature'}" class="tooltip-icon" title="${tile.feature ? tile.feature.replace(/_/g, ' ') : 'Feature'}">`;
                            }
                            if (tile.resourcePath) {
                                html += `<img src="${tile.resourcePath}" alt="${tile.resource || 'Resource'}" class="tooltip-icon" title="${tile.resource ? tile.resource.replace(/_/g, ' ') : 'Resource'}">`;
                            }
                            html += '</div>';
                        }
                    } else {
                        html += '<div class="tooltip-value">None</div>';
                    }
                    html += '</div>';
                }
                
                return html;
            } else {
                // Terrain tile tooltip
                if (!tile) return '';
                
                let html = '<div class="tooltip-section">';
                html += '<div class="tooltip-label"> Terrain Type & Features:</div>';
                
                // Show icons and text for terrain, feature, and resource
                const parts = [];
                if (tile.terrain) parts.push(tile.terrain.replace(/_/g, ' '));
                if (tile.feature) parts.push(tile.feature.replace(/_/g, ' '));
                if (tile.resource) parts.push(tile.resource.replace(/_/g, ' '));
                
                if (parts.length > 0) {
                    // Show text first
                    html += `<div class="tooltip-value">${parts.join(', ')}</div>`;
                    // Show icons below text
                    const hasIcons = tile.terrainPath || tile.featurePath || tile.resourcePath;
                    if (hasIcons) {
                        html += '<div class="tooltip-icons">';
                        if (tile.terrainPath) {
                            html += `<img src="${tile.terrainPath}" alt="${tile.terrain || 'Terrain'}" class="tooltip-icon" title="${tile.terrain ? tile.terrain.replace(/_/g, ' ') : 'Terrain'}">`;
                        }
                        if (tile.featurePath) {
                            html += `<img src="${tile.featurePath}" alt="${tile.feature || 'Feature'}" class="tooltip-icon" title="${tile.feature ? tile.feature.replace(/_/g, ' ') : 'Feature'}">`;
                        }
                        if (tile.resourcePath) {
                            html += `<img src="${tile.resourcePath}" alt="${tile.resource || 'Resource'}" class="tooltip-icon" title="${tile.resource ? tile.resource.replace(/_/g, ' ') : 'Resource'}">`;
                        }
                        html += '</div>';
                    }
                } else {
                    html += '<div class="tooltip-value">None</div>';
                }
                html += '</div>';
                
                return html;
            }
        }

        function updateAllScores() {
            let totalScience = 0;
            let totalFaith = 0;
            let totalGold = 0;
            let totalProduction = 0;
            let totalCulture = 0;
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const adjacency = calculateAdjacency(row, col);
                    if (adjacency) {
                        totalScience += adjacency.science;
                        totalFaith += adjacency.faith;
                        totalGold += adjacency.gold;
                        totalProduction += adjacency.production;
                        totalCulture += adjacency.culture;
                    }
                }
            }
            
            const scorePanel = document.getElementById('scorePanel');
            if (scorePanel) {
                scorePanel.innerHTML = `
                    <h3>Adjacency Bonuses</h3>
                    <div class="score-item">
                        <span class="yield-label">
                            <img src="assets/yields/Science.webp" alt="Science" class="yield-icon">
                        <span>Science:</span>
                        </span>
                        <span>+${totalScience}</span>
                    </div>
                    <div class="score-item">
                        <span class="yield-label">
                            <img src="assets/yields/Culture.webp" alt="Culture" class="yield-icon">
                            <span>Culture:</span>
                        </span>
                        <span>+${totalCulture}</span>
                    </div>
                    <div class="score-item">
                        <span class="yield-label">
                            <img src="assets/yields/Production.webp" alt="Production" class="yield-icon">
                            <span>Production:</span>
                        </span>
                        <span>+${totalProduction}</span>
                    </div>
                    <div class="score-item">
                        <span class="yield-label">
                            <img src="assets/yields/Faith.webp" alt="Faith" class="yield-icon">
                            <span>Faith:</span>
                        </span>
                        <span>+${totalFaith}</span>
                    </div>
                    <div class="score-item">
                        <span class="yield-label">
                            <img src="assets/yields/Gold.webp" alt="Gold" class="yield-icon">
                            <span>Gold:</span>
                        </span>
                        <span>+${totalGold}</span>
                    </div>
                    <div class="score-formula">
                        <div class="score-item" style="justify-content: center; gap: 4px;">
                            <img src="assets/yields/Score.webp" alt="Score" class="yield-icon">
                            <span>=</span>
                            <img src="assets/yields/Science.webp" alt="Science" class="yield-icon">
                            <span>+</span>
                            <img src="assets/yields/Culture.webp" alt="Culture" class="yield-icon">
                            <span>+</span>
                            <img src="assets/yields/Production.webp" alt="Production" class="yield-icon">
                            <span>+</span>
                            <img src="assets/yields/Faith.webp" alt="Faith" class="yield-icon">
                            <span>+</span>
                            <span>0.5</span>
                            <img src="assets/yields/Gold.webp" alt="Gold" class="yield-icon">
                        </div>
                    </div>
                    <div class="score-total">
                        <div class="score-item">
                            <span class="yield-label">
                                <img src="assets/yields/Score.webp" alt="Score" class="yield-icon">
                            <span>Total Score:</span>
                            </span>
                            <span>${totalScience + totalCulture + totalProduction + totalFaith + (totalGold * 0.5)}</span>
                        </div>
                    </div>
                    ${window.isCustomMode ? '' : '<button id="submitScoreBtn" class="submit-score-btn">Submit Score</button>'}
                `;
                
                // Check if user has already submitted today (only in normal mode)
                if (!window.isCustomMode) {
                    checkSubmissionStatus();
                    
                    // Add event listener for submit button
                    const submitBtn = document.getElementById('submitScoreBtn');
                    if (submitBtn) {
                        submitBtn.onclick = handleScoreButtonClick;
                    }
                }
            }
        }
        
        function getTodayKey() {
            // Get current date in EST timezone (same as server)
            const now = new Date();
            const estDate = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
            const month = String(estDate.getMonth() + 1).padStart(2, '0');
            const day = String(estDate.getDate()).padStart(2, '0');
            return `submitted_${estDate.getFullYear()}-${month}-${day}`;
        }
        
        function checkSubmissionStatus() {
            const submitBtn = document.getElementById('submitScoreBtn');
            if (!submitBtn) return;
            
            const todayKey = getTodayKey();
            const hasSubmitted = localStorage.getItem(todayKey) === 'true';
            
            if (hasSubmitted) {
                submitBtn.textContent = 'View Leaderboard';
            } else {
                submitBtn.textContent = 'Submit Score';
            }
        }
        
        async function handleScoreButtonClick() {
            const submitBtn = document.getElementById('submitScoreBtn');
            if (!submitBtn) return;
            
            const todayKey = getTodayKey();
            const hasSubmitted = localStorage.getItem(todayKey) === 'true';
            
            if (hasSubmitted) {
                // Just show leaderboard
                await showLeaderboard(null, false, null, true);
            } else {
                // Submit score
                await submitScore();
            }
        }
        
        async function submitScore() {
            const submitBtn = document.getElementById('submitScoreBtn');
            if (!submitBtn) return;
            
            // Calculate total score
            let totalScience = 0;
            let totalFaith = 0;
            let totalGold = 0;
            let totalProduction = 0;
            let totalCulture = 0;
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const adjacency = calculateAdjacency(row, col);
                    if (adjacency) {
                        totalScience += adjacency.science;
                        totalFaith += adjacency.faith;
                        totalGold += adjacency.gold;
                        totalProduction += adjacency.production;
                        totalCulture += adjacency.culture;
                    }
                }
            }
            
            const totalScore = totalScience + totalCulture + totalProduction + totalFaith + (totalGold * 0.5);
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Submitting...';
            
            try {
                // Capture screenshot before submitting (server will determine if it should be saved)
                let screenshotData = null;
                try {
                    screenshotData = await captureScreenshot();
                } catch (error) {
                    console.error('Error capturing screenshot:', error);
                    // Continue with submission even if screenshot fails
                }
                
                // Send score and screenshot together (server determines if screenshot should be saved)
                const requestBody = {
                    score: totalScore,
                    screenshot: screenshotData
                };
                
                const scoreResponse = await fetch('/submit-score', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await scoreResponse.json();
                
                if (data.success) {
                    // Mark as submitted for today
                    const todayKey = getTodayKey();
                    localStorage.setItem(todayKey, 'true');
                    
                    // Update button text
                    submitBtn.textContent = 'View Leaderboard';
                    submitBtn.disabled = false;
                    
                    // Show leaderboard
                    await showLeaderboard(data.rank, data.inTop10, totalScore);
                } else {
                    alert('Failed to submit score: ' + (data.error || 'Unknown error'));
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Submit Score';
                }
            } catch (error) {
                console.error('Error submitting score:', error);
                alert('Failed to submit score. Please try again.');
                submitBtn.disabled = false;
                submitBtn.textContent = 'Submit Score';
            }
        }
        
        async function showLeaderboard(rank, inTop10, totalScore, viewOnly = false) {
            const modal = document.getElementById('leaderboardModal');
            const rankInfo = document.getElementById('rankInfo');
            const nameInputSection = document.getElementById('nameInputSection');
            const nameInput = document.getElementById('playerName');
            const charCount = document.getElementById('charCount');
            const leaderboardList = document.getElementById('leaderboardList');
            
            // Update rank info
            if (rank !== null) {
                rankInfo.textContent = `Your rank: #${rank}`;
            } else {
                rankInfo.textContent = '';
            }
            
            // Show name input if in top 10 and not view-only
            if (inTop10 && !viewOnly) {
                nameInputSection.style.display = 'block';
                nameInput.value = '';
                charCount.textContent = '0';
                
                // Character count update
                nameInput.addEventListener('input', () => {
                    charCount.textContent = nameInput.value.length;
                });
            } else {
                nameInputSection.style.display = 'none';
            }
            
            // Fetch and display leaderboard
            try {
                const response = await fetch('/leaderboard');
                const data = await response.json();
                
                if (data.success) {
                    leaderboardList.innerHTML = '';
                    data.leaderboard.forEach((entry, index) => {
                        const li = document.createElement('li');
                        li.className = `leaderboard-item rank-${index + 1}`;
                        li.innerHTML = `
                            <span class="rank">#${index + 1}</span>
                            <span class="name">${entry.name || 'Anonymous'}</span>
                            <span class="score">
                                <img src="assets/yields/Score.webp" alt="Score" class="score-icon">
                                ${entry.score}
                            </span>
                        `;
                        leaderboardList.appendChild(li);
                    });
                } else {
                    leaderboardList.innerHTML = '<li>Failed to load leaderboard</li>';
                }
            } catch (error) {
                console.error('Error loading leaderboard:', error);
                leaderboardList.innerHTML = '<li>Failed to load leaderboard</li>';
            }
            
            modal.classList.add('active');
            
            // Show countdown if name input is not shown (view-only or not in top 10)
            if (nameInputSection.style.display === 'none') {
                showCountdown();
            }
            
            // If in top 10, wait for name submission
            if (inTop10 && !viewOnly) {
                const submitName = async () => {
                    const name = nameInput.value.trim();
                    if (name.length === 0) {
                        return;
                    }
                    
                    try {
                        const response = await fetch('/submit-score', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ 
                                score: totalScore,
                                name: name 
                            })
                        });
                        
                        const data = await response.json();
                        if (data.success) {
                            // Reload leaderboard
                            const leaderboardResponse = await fetch('/leaderboard');
                            const leaderboardData = await leaderboardResponse.json();
                            if (leaderboardData.success) {
                                leaderboardList.innerHTML = '';
                                leaderboardData.leaderboard.forEach((entry, index) => {
                                    const li = document.createElement('li');
                                    li.className = `leaderboard-item rank-${index + 1}`;
                                    li.innerHTML = `
                                        <span class="rank">#${index + 1}</span>
                                        <span class="name">${entry.name || 'Anonymous'}</span>
                                        <span class="score">
                                            <img src="assets/yields/Score.webp" alt="Score" class="score-icon">
                                            ${entry.score}
                                        </span>
                                    `;
                                    leaderboardList.appendChild(li);
                                });
                            }
                            nameInputSection.style.display = 'none';
                            // Show countdown after name submission
                            showCountdown();
                        } else {
                            if (data.error === 'Name already taken') {
                                alert('This name is already taken. Please choose a different name.');
                            } else if (data.error === 'Name contains inappropriate content') {
                                alert('This name contains inappropriate content. Please choose a different name.');
                            } else {
                                alert('Failed to submit name: ' + (data.error || 'Unknown error'));
                            }
                        }
                    } catch (error) {
                        console.error('Error submitting name:', error);
                        alert('Failed to submit name. Please try again.');
                    }
                };
                
                nameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        submitName();
                    }
                });
                
                // Add submit button for name
                const existingSubmitBtn = nameInputSection.querySelector('.name-submit-btn');
                if (existingSubmitBtn) {
                    existingSubmitBtn.remove();
                }
                const submitNameBtn = document.createElement('button');
                submitNameBtn.className = 'submit-score-btn name-submit-btn';
                submitNameBtn.textContent = 'Submit Name';
                submitNameBtn.style.marginTop = '8px';
                submitNameBtn.onclick = submitName;
                nameInputSection.appendChild(submitNameBtn);
            }
        }
        
        function getNextMidnightEST() {
            // Get current time
            const now = new Date();
            
            // Get current date components in EST
            const estFormatter = new Intl.DateTimeFormat('en-US', {
                timeZone: 'America/New_York',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            
            const parts = estFormatter.formatToParts(now);
            const estYear = parseInt(parts.find(p => p.type === 'year').value);
            const estMonth = parseInt(parts.find(p => p.type === 'month').value) - 1; // 0-indexed
            const estDay = parseInt(parts.find(p => p.type === 'day').value);
            const estHour = parseInt(parts.find(p => p.type === 'hour').value);
            const estMinute = parseInt(parts.find(p => p.type === 'minute').value);
            const estSecond = parseInt(parts.find(p => p.type === 'second').value);
            
            // Calculate milliseconds until next midnight EST
            const hoursRemaining = 24 - estHour;
            const minutesRemaining = 60 - estMinute;
            const secondsRemaining = 60 - estSecond;
            const msUntilMidnight = (hoursRemaining * 3600000) + ((minutesRemaining - 1) * 60000) + ((secondsRemaining - 1) * 1000) + 1000;
            
            // Now we need to find what JavaScript Date corresponds to "now + msUntilMidnight" in EST
            // The challenge is that JavaScript Date uses local time, but we calculated in EST
            // We'll use a binary search approach: try different dates until we find one that formats to midnight EST
            
            // Start with current time + calculated offset
            let candidate = new Date(now.getTime() + msUntilMidnight);
            
            // Refine: check what time this candidate is in EST
            let candidateParts = estFormatter.formatToParts(candidate);
            let candidateHour = parseInt(candidateParts.find(p => p.type === 'hour').value);
            let candidateMinute = parseInt(candidateParts.find(p => p.type === 'minute').value);
            let candidateSecond = parseInt(candidateParts.find(p => p.type === 'second').value);
            
            // Adjust until we're at midnight EST (00:00:00)
            while (candidateHour !== 0 || candidateMinute !== 0 || candidateSecond !== 0) {
                if (candidateHour > 0 || candidateMinute > 0 || candidateSecond > 0) {
                    // Too late, go back
                    candidate = new Date(candidate.getTime() - 60000); // Go back 1 minute
                } else {
                    // Too early, go forward (shouldn't happen, but just in case)
                    candidate = new Date(candidate.getTime() + 60000); // Go forward 1 minute
                }
                candidateParts = estFormatter.formatToParts(candidate);
                candidateHour = parseInt(candidateParts.find(p => p.type === 'hour').value);
                candidateMinute = parseInt(candidateParts.find(p => p.type === 'minute').value);
                candidateSecond = parseInt(candidateParts.find(p => p.type === 'second').value);
                
                // Safety check to avoid infinite loop
                if (Math.abs(candidate.getTime() - now.getTime()) > 48 * 3600000) {
                    break;
                }
            }
            
            return candidate;
        }
        
        function updateCountdown() {
            const countdownSection = document.getElementById('countdownSection');
            const countdownTime = document.getElementById('countdownTime');
            
            if (!countdownSection || !countdownTime) return;
            
            const now = new Date();
            const nextMidnight = getNextMidnightEST();
            const diff = nextMidnight - now;
            
            if (diff <= 0) {
                countdownTime.textContent = '00:00:00';
                // Refresh page after a short delay to get new challenge
                setTimeout(() => {
                    window.location.reload();
                }, 1000);
                return;
            }
            
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);
            
            countdownTime.textContent = 
                `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        
        function showCountdown() {
            const countdownSection = document.getElementById('countdownSection');
            if (countdownSection) {
                countdownSection.classList.add('visible');
                updateCountdown();
                // Update countdown every second
                if (window.countdownInterval) {
                    clearInterval(window.countdownInterval);
                }
                window.countdownInterval = setInterval(updateCountdown, 1000);
            }
        }
        
        function hideCountdown() {
            const countdownSection = document.getElementById('countdownSection');
            if (countdownSection) {
                countdownSection.classList.remove('visible');
            }
            if (window.countdownInterval) {
                clearInterval(window.countdownInterval);
                window.countdownInterval = null;
            }
        }
        
        function showBugReportModal() {
            const modal = document.getElementById('bugReportModal');
            const textarea = document.getElementById('bugReportText');
            const message = document.getElementById('bugReportMessage');
            const submitBtn = document.querySelector('.bug-report-btn.submit');
            if (modal) {
                modal.classList.add('active');
                if (textarea) textarea.value = '';
                if (message) {
                    message.className = 'bug-report-message';
                    message.textContent = '';
                }
                if (submitBtn) {
                    submitBtn.disabled = false;
                }
            }
        }
        
        function closeBugReportModal() {
            const modal = document.getElementById('bugReportModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }
        
        async function submitBugReport() {
            const textarea = document.getElementById('bugReportText');
            const message = document.getElementById('bugReportMessage');
            const submitBtn = document.querySelector('.bug-report-btn.submit');
            
            if (!textarea || !message) return;
            
            const bugDescription = textarea.value.trim();
            
            if (bugDescription.length === 0) {
                message.className = 'bug-report-message error';
                message.textContent = 'Please describe the bug before submitting.';
                return;
            }
            
            if (submitBtn) submitBtn.disabled = true;
            
            try {
                const response = await fetch('/report-bug', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        description: bugDescription
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    message.className = 'bug-report-message success';
                    message.textContent = 'Bug report submitted successfully. Thank you!';
                    textarea.value = '';
                    // Keep button disabled after successful submission
                    if (submitBtn) submitBtn.disabled = true;
                    setTimeout(() => {
                        closeBugReportModal();
                    }, 2000);
                } else {
                    message.className = 'bug-report-message error';
                    message.textContent = 'Failed to submit bug report: ' + (data.error || 'Unknown error');
                    // Re-enable button on error so user can try again
                    if (submitBtn) submitBtn.disabled = false;
                }
            } catch (error) {
                console.error('Error submitting bug report:', error);
                message.className = 'bug-report-message error';
                message.textContent = 'Failed to submit bug report. Please try again.';
                // Re-enable button on error so user can try again
                if (submitBtn) submitBtn.disabled = false;
            }
        }
        
        function closeLeaderboard() {
            const modal = document.getElementById('leaderboardModal');
            modal.classList.remove('active');
            hideCountdown();
            
            // Update button text based on submission status
            checkSubmissionStatus();
            
            const submitBtn = document.getElementById('submitScoreBtn');
            if (submitBtn) {
                submitBtn.disabled = false;
            }
        }

        async function captureScreenshot() {
            try {
                const mapTransformWrapper = document.getElementById('mapTransformWrapper');
                if (!mapTransformWrapper) {
                    console.error('Map container not found');
                    return null;
                }

                // Capture using onclone to fix all transforms and dimensions
                const canvas = await html2canvas(mapTransformWrapper, {
                    scale: 2,
                    backgroundColor: '#1a1a1b',
                    useCORS: true,
                    logging: false,
                    allowTaint: false,
                    onclone: (clonedDoc, element) => {
                        // Reset transform on the wrapper
                        const clonedWrapper = clonedDoc.getElementById('mapTransformWrapper');
                        if (clonedWrapper) {
                            clonedWrapper.style.transform = 'none';
                            clonedWrapper.style.position = 'relative';
                        }
                        
                        // Fix all district images - ensure they fit properly within their hex containers
                        const districtImages = clonedDoc.querySelectorAll('.hex-district');
                        districtImages.forEach(img => {
                            // Get the parent container (district-shape)
                            const parent = img.parentElement;
                            if (parent) {
                                // Make districts 15% wider and 5% taller, moved left a bit
                                img.style.width = '100%'; // 85% + 15% = 100%
                                img.style.height = '90%'; // 85% + 5% = 90%
                                img.style.objectFit = 'contain'; // Fit within bounds without cropping
                                img.style.top = '5%';
                                img.style.left = '-2%'; // Moved left (reduced from 7.5%)
                                img.style.position = 'absolute';
                                img.style.margin = '0';
                                img.style.padding = '0';
                            }
                        });
                        
                        // Ensure district-shape containers have proper dimensions
                        const districtShapes = clonedDoc.querySelectorAll('#districtsLayer .hex-shape');
                        districtShapes.forEach(shape => {
                            const hex = shape.closest('.hex');
                            if (hex) {
                                shape.style.width = '100%';
                                shape.style.height = '100%';
                            }
                        });
                        
                        // Fix all hex shapes to ensure proper dimensions
                        const hexShapes = clonedDoc.querySelectorAll('.hex-shape');
                        hexShapes.forEach(shape => {
                            const hex = shape.closest('.hex');
                            if (hex) {
                                const computedStyle = window.getComputedStyle(hex);
                                shape.style.width = computedStyle.width;
                                shape.style.height = computedStyle.height;
                            }
                        });
                    }
                });

                // Convert canvas to base64 and return
                return canvas.toDataURL('image/png');
            } catch (error) {
                console.error('Error capturing screenshot:', error);
                return null;
            }
        }

        async function showYesterdayBest() {
            const modal = document.getElementById('yesterdayBestModal');
            const imageContainer = document.getElementById('yesterdayBestImage');
            const titleElement = modal.querySelector('h2');
            
            modal.classList.add('active');
            imageContainer.innerHTML = '<p>Loading...</p>';

            try {
                // Calculate yesterday's date in EST
                const now = new Date();
                const estDate = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
                const yesterday = new Date(estDate);
                yesterday.setDate(yesterday.getDate() - 1);
                const month = String(yesterday.getMonth() + 1).padStart(2, '0');
                const day = String(yesterday.getDate()).padStart(2, '0');
                const dateString = `${month}/${day}`;
                
                const response = await fetch('/yesterday-best-setup');
                const data = await response.json();
                
                if (data.success && data.screenshot) {
                    // Update title with date, player name, and score
                    if (data.playerName) {
                        let titleHTML = `<span>Yesterday's Best Setup (${dateString}) - By: ${data.playerName}</span>`;
                        if (data.playerScore !== null && data.playerScore !== undefined) {
                            titleHTML += `<span style="font-size: 0.65em; color: #b0b0b0; margin-left: 6px;">(<img src="assets/yields/Score.webp" alt="Score" style="width: 14px; height: 14px; vertical-align: middle; margin-left: 0px; margin-right: 0px; display: inline-block; border: none; outline: none; background: transparent;"><span>${data.playerScore}</span>)</span>`;
                        }
                        titleElement.innerHTML = titleHTML;
                    } else {
                        titleElement.textContent = `Yesterday's Best Setup (${dateString})`;
                    }
                    
                    // Show screenshot
                    imageContainer.innerHTML = `<img src="${data.screenshot}" alt="Yesterday's Best Setup">`;
                } else {
                    titleElement.textContent = `Yesterday (${dateString})`;
                    imageContainer.innerHTML = '<p>No setup available for yesterday.</p>';
                }
            } catch (error) {
                console.error('Error loading yesterday\'s best setup:', error);
                titleElement.textContent = "Yesterday's Best Setup";
                imageContainer.innerHTML = '<p>Error loading yesterday\'s best setup.</p>';
            }
        }

        function closeYesterdayBest() {
            const modal = document.getElementById('yesterdayBestModal');
            modal.classList.remove('active');
        }
        
        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('leaderboardModal');
            if (e.target === modal) {
                closeLeaderboard();
            }
            
            const yesterdayModal = document.getElementById('yesterdayBestModal');
            if (e.target === yesterdayModal) {
                closeYesterdayBest();
            }
        });

        // Event listener for yesterday's best button
        const yesterdayBtn = document.getElementById('yesterdayBestBtn');
        if (yesterdayBtn) {
            yesterdayBtn.addEventListener('click', showYesterdayBest);
        }

        function initMapZoomPan() {
            const mapContainer = document.getElementById('mapContainer');
            const mapTransformWrapper = document.getElementById('mapTransformWrapper');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const resetZoomBtn = document.getElementById('resetZoomBtn');

            function updateTransform() {
                mapTransformWrapper.style.transform = `translate(${mapPanX}px, ${mapPanY}px) scale(${mapZoom})`;
            }

            zoomInBtn.onclick = (e) => {
                e.stopPropagation();
                mapZoom = Math.min(mapZoom * 1.2, 3.0);
                updateTransform();
            };

            zoomOutBtn.onclick = (e) => {
                e.stopPropagation();
                mapZoom = Math.max(mapZoom / 1.2, 0.5);
                updateTransform();
            };

            resetZoomBtn.onclick = (e) => {
                e.stopPropagation();
                mapZoom = 1.5; // Increased from 1.0 to zoom in more by default
                mapPanX = 0;
                mapPanY = 0;
                updateTransform();
            };

            mapContainer.addEventListener('wheel', (e) => {
                if (!e.ctrlKey && !e.shiftKey && !e.altKey) {
                    e.preventDefault();
                    const rect = mapContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const containerCenterX = rect.width / 2;
                    const containerCenterY = rect.height / 2;
                    
                    const deltaX = mouseX - containerCenterX;
                    const deltaY = mouseY - containerCenterY;
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.5, Math.min(3.0, mapZoom * zoomFactor));
                    
                    const zoomChange = newZoom / mapZoom;
                    mapPanX = mapPanX * zoomChange + (deltaX * (1 - zoomChange));
                    mapPanY = mapPanY * zoomChange + (deltaY * (1 - zoomChange));
                    mapZoom = newZoom;
                    
                    updateTransform();
                }
            }, { passive: false });

            // Prevent map panning when dragging items
            const isDraggingItem = () => {
                return draggedItem || draggedDistrict || draggedImprovement || draggedWonder || 
                       touchDragState || touchDragDistrict || touchDragImprovement || touchDragWonder;
            };

            mapContainer.addEventListener('mousedown', (e) => {
                // Don't start panning if we're dragging an item
                if (isDraggingItem()) {
                    return;
                }
                
                const isButtonClick = e.target.closest('button');
                const isScorePanel = e.target.closest('.score-panel');
                const isDistrict = e.target.closest('.hex-district');
                const isImprovement = e.target.closest('.hex-improvement');
                const isWonder = e.target.closest('.hex-wonder');
                
                // Allow panning on background or terrain tiles, but not on districts, improvements, wonders, or buttons
                if (e.button === 0 && !isButtonClick && !isScorePanel && !isDistrict && !isImprovement && !isWonder) {
                    // Allow panning on background, hex grid, or any hex (terrain)
                    if (e.target === mapContainer || e.target === mapTransformWrapper || e.target.id === 'hexGrid' || e.target.closest('.hex')) {
                        isDragging = true;
                        mapContainer.classList.add('dragging');
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        dragStartPanX = mapPanX;
                        dragStartPanY = mapPanY;
                        e.preventDefault();
                    }
                }
            });
            
            // Touch support for map panning (only when not dragging items)
            let touchPanStart = null;
            mapContainer.addEventListener('touchstart', (e) => {
                // Don't start panning if we're dragging an item
                if (isDraggingItem()) {
                    return;
                }
                
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    const isButtonClick = touch.target.closest('button');
                    const isScorePanel = touch.target.closest('.score-panel');
                    const isDistrict = touch.target.closest('.hex-district');
                    const isImprovement = touch.target.closest('.hex-improvement');
                    const isWonder = touch.target.closest('.hex-wonder');
                    
                    if (!isButtonClick && !isScorePanel && !isDistrict && !isImprovement && !isWonder) {
                        if (touch.target === mapContainer || touch.target === mapTransformWrapper || touch.target.id === 'hexGrid' || touch.target.closest('.hex')) {
                            touchPanStart = {
                                x: touch.clientX,
                                y: touch.clientY,
                                panX: mapPanX,
                                panY: mapPanY
                            };
                        }
                    }
                }
            }, { passive: true });
            
            mapContainer.addEventListener('touchmove', (e) => {
                // Don't pan if we're dragging an item
                if (isDraggingItem()) {
                    return;
                }
                
                if (touchPanStart && e.touches.length === 1) {
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - touchPanStart.x;
                    const deltaY = touch.clientY - touchPanStart.y;
                    mapPanX = touchPanStart.panX + deltaX;
                    mapPanY = touchPanStart.panY + deltaY;
                    updateTransform();
                }
            }, { passive: true });
            
            mapContainer.addEventListener('touchend', () => {
                touchPanStart = null;
            }, { passive: true });
            
            mapContainer.addEventListener('touchcancel', () => {
                touchPanStart = null;
            }, { passive: true });

            mapContainer.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    mapPanX = dragStartPanX + deltaX;
                    mapPanY = dragStartPanY + deltaY;
                    updateTransform();
                }
            });

            mapContainer.addEventListener('mouseup', (e) => {
                if (isDragging && e.button === 0) {
                    isDragging = false;
                    mapContainer.classList.remove('dragging');
                }
            });

            mapContainer.addEventListener('mouseleave', (e) => {
                if (isDragging) {
                    isDragging = false;
                    mapContainer.classList.remove('dragging');
                }
                // Instantly hide tooltip when leaving map area
                if (hexTooltip) {
                    hexTooltip.classList.add('instant-hide');
                    hexTooltip.classList.remove('visible');
                    currentTooltipRow = null;
                    currentTooltipCol = null;
                    // Remove instant-hide class after a brief moment to restore transition for next show
                    setTimeout(() => {
                        if (hexTooltip) {
                            hexTooltip.classList.remove('instant-hide');
                        }
                    }, 50);
                }
                // Clear any pending tooltip timeout
                if (tooltipTimeout) {
                    clearTimeout(tooltipTimeout);
                    tooltipTimeout = null;
                }
            });

            // Allow dropping districts and improvements in the void to delete them
            mapContainer.addEventListener('dragover', (e) => {
                if (draggedDistrict || draggedImprovement || draggedWonder) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                }
            });

            mapContainer.addEventListener('drop', (e) => {
                // Only delete if dropping on the map container itself (not on a hex)
                // Check if the drop target is actually the map container, not a hex
                const dropTarget = e.target;
                const isDroppingOnHex = dropTarget.closest('.hex') !== null;
                
                // If dropping on a hex, the hex handler should have already handled it
                // Only delete if we're actually dropping on the map container background
                if (!isDroppingOnHex) {
                    if (draggedDistrict) {
                        e.preventDefault();
                        // Delete the district by removing it
                        removeItem(draggedDistrict.row, draggedDistrict.col);
                        draggedDistrict = null;
                    } else if (draggedImprovement) {
                        e.preventDefault();
                        // Delete the improvement by removing it
                        removeItem(draggedImprovement.row, draggedImprovement.col);
                        draggedImprovement = null;
                    } else if (draggedWonder) {
                        e.preventDefault();
                        // Delete the wonder by removing it
                        removeItem(draggedWonder.row, draggedWonder.col);
                        draggedWonder = null;
                    }
                }
            });

            updateTransform();
        }
        
        function showTutorial() {
            // Check if user has seen tutorial before
            const hasSeenTutorial = localStorage.getItem('civle_tutorial_seen');
            if (!hasSeenTutorial) {
                const modal = document.getElementById('tutorialModal');
                if (modal) {
                    modal.classList.add('active');
                }
            }
        }

        function showTutorialAlways() {
            // Show tutorial without checking localStorage (for help button)
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.classList.add('active');
            }
        }

        // Event listener for help button will be set up in initialization

        function closeTutorial() {
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.classList.remove('active');
                // Mark tutorial as seen
                localStorage.setItem('civle_tutorial_seen', 'true');
            }
        }

        // Close tutorial when clicking outside
        document.addEventListener('click', (e) => {
            const tutorialModal = document.getElementById('tutorialModal');
            if (e.target === tutorialModal) {
                closeTutorial();
            }
        });

        // Update header date
        function updateHeaderDate() {
            const now = new Date();
            const estDate = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
            const month = estDate.getMonth() + 1;
            const day = estDate.getDate();
            const dateString = `${month}/${day}`;
            const dateElement = document.getElementById('headerDate');
            if (dateElement) {
                dateElement.textContent = `(${dateString})`;
            }
        }

        // Detect mobile devices
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (window.innerWidth <= 768 && window.innerHeight <= 1024);
        }

        // Show mobile message if on mobile
        if (isMobileDevice()) {
            document.body.classList.add('mobile');
            const mobileMessage = document.getElementById('mobileMessage');
            if (mobileMessage) {
                mobileMessage.classList.add('active');
            }
        } else {
        // Initialize on load
            // Check if we're in custom mode (from URL parameter)
            const urlParams = new URLSearchParams(window.location.search);
            const isCustomMode = urlParams.get('mode') === 'custom';
            
            // Hide leaderboard and yesterday's best button in custom mode
            if (isCustomMode) {
                const yesterdayBestBtn = document.getElementById('yesterdayBestBtn');
                if (yesterdayBestBtn) {
                    yesterdayBestBtn.style.display = 'none';
                }
            }
            
            // Store isCustomMode globally for use in other functions
            window.isCustomMode = isCustomMode;
            
            // Load game data, then load daily challenge or show upload button
            loadGameData().then(() => {
                if (isCustomMode) {
                    // Custom mode: show upload button instead of loading daily challenge
                    const sidebar = document.getElementById('sidebar');
                    if (sidebar) {
                        sidebar.innerHTML = `
                            <div class="empty-state">
                                <h2>Upload Challenge</h2>
                                <p>Please upload a challenge file to begin playing.</p>
                                <input type="file" id="challengeFileInput" accept=".civle" style="display: none;" onchange="loadChallenge(event)">
                                <button class="submit-score-btn" onclick="document.getElementById('challengeFileInput').click()" style="margin-top: 20px; width: 100%;">Upload Challenge File</button>
                            </div>
                        `;
                    }
                } else {
                    // Normal mode: load daily challenge
                    loadDailyChallenge();
                }
                // Show tutorial on first visit
                showTutorial();
                // Update header date
                updateHeaderDate();
                // Ensure help button event listener is set up
                const helpBtn = document.getElementById('helpButton');
                if (helpBtn && !helpBtn.hasAttribute('data-listener-attached')) {
                    helpBtn.addEventListener('click', showTutorialAlways);
                    helpBtn.setAttribute('data-listener-attached', 'true');
                }
            });
        }
    </script>
    
    <!-- Leaderboard Modal -->
    <div id="leaderboardModal" class="leaderboard-modal">
        <div class="leaderboard-content">
            <h2>Leaderboard</h2>
            <div id="rankInfo" class="rank-info"></div>
            <ul id="leaderboardList" class="leaderboard-list"></ul>
            <div id="nameInputSection" class="name-input-section" style="display: none;">
                <label for="playerName">Enter your name:</label>
                <input type="text" id="playerName" maxlength="20" placeholder="Your name">
                <div class="char-count"><span id="charCount">0</span>/20</div>
            </div>
            <div id="countdownSection" class="countdown-section">
                <div class="countdown-label">Next Civle in:</div>
                <div id="countdownTime" class="countdown-time">--:--:--</div>
            </div>
            <button class="leaderboard-close-btn" onclick="closeLeaderboard()">Close</button>
        </div>
    </div>

    <!-- Bug Report Modal -->
    <div id="bugReportModal" class="bug-report-modal">
        <div class="bug-report-content">
            <h2>Report a Bug</h2>
            <textarea id="bugReportText" placeholder="Please describe the bug you encountered..."></textarea>
            <div id="bugReportMessage" class="bug-report-message"></div>
            <div class="bug-report-buttons">
                <button class="bug-report-btn" onclick="closeBugReportModal()">Cancel</button>
                <button class="bug-report-btn submit" onclick="submitBugReport()">Submit</button>
            </div>
        </div>
    </div>

    <!-- Yesterday's Best Setup Modal -->
    <div id="yesterdayBestModal" class="yesterday-best-modal">
        <div class="yesterday-best-content">
            <h2>Yesterday's Best Setup</h2>
            <div id="yesterdayBestImage"></div>
            <button class="close-btn" onclick="closeYesterdayBest()">Close</button>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div id="tutorialModal" class="tutorial-modal">
        <div class="tutorial-content">
            <h2>Welcome to Civle!</h2>
            <p><strong>How to Play:</strong></p>
            <ul>
                <li>Drag districts, improvements, and wonders from the sidebar onto the map</li>
                <li>Place them strategically to maximize your adjacency bonuses</li>
                <li>Each district gets bonuses from adjacent tiles (mountains, rainforests, other districts, etc.)</li>
                <li>Your score is calculated from all adjacency bonuses across all placed districts</li>
                <li>City Centers must be at least 3 tiles apart</li>
                <li>Districts must be within 3 tiles of a City Center to be valid</li>
                <li>City's cannot contain duplicates of the same district type</li>
                <li>A new daily challenge is available every day at 12:00 AM EST</li>
            </ul>
            <p><strong>Tips:</strong></p>
            <ul>
                <li>Hover over items in the sidebar to see their placement requirements and adjacency bonuses</li>
                <li>Drag placed districts to move or delete them</li>
                <li>Right click on a district to delete it</li>
                <li>Use the zoom controls to get a better view of the map</li>
                <li>Submit your score to compete on the daily leaderboard!</li>
            </ul>
            <button class="close-btn" onclick="closeTutorial()">Got it!</button>
        </div>
    </div>

    <!-- Help Button -->
    <button id="helpButton" class="help-button" title="Show Tutorial">?</button>
</body>
</html>


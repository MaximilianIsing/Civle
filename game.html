<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Civle Game</title>
    <style>
        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-Medium.ttf') format('truetype');
            font-weight: 500;
            font-style: normal;
        }

        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-Bold.ttf') format('truetype');
            font-weight: 700;
            font-style: normal;
        }

        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-ExtraBold.ttf') format('truetype');
            font-weight: 800;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: #2d2d2d;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #444;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-logo {
            width: 48px;
            height: 48px;
            object-fit: contain;
        }

        .header h1 {
            font-size: 24px;
            margin: 0;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            padding: 8px 16px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #357abd;
        }

        button:active {
            background: #2968a3;
        }

        .file-label {
            display: inline-block;
            padding: 8px 16px;
            background: #4a90e2;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .file-label:hover {
            background: #357abd;
        }

        input[type="file"] {
            display: none;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background: #2d2d2d;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #444;
        }

        .sidebar::-webkit-scrollbar {
            width: 10px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #4a4a4a;
            border-radius: 5px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #5a5a5a;
        }

        .sidebar h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #4a90e2;
        }

        .available-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            margin: 5px 0;
            background: #3a3a3a;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: grab;
            user-select: none;
        }

        .available-item:active {
            cursor: grabbing;
        }

        .available-item.dragging {
            opacity: 0.5;
        }

        .available-item img {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .available-item .count {
            margin-left: auto;
            font-weight: bold;
            color: #4a90e2;
        }

        .available-item .count.zero {
            color: #888;
        }

        .map-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
            position: relative;
        }

        .map-transform-wrapper {
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            will-change: transform;
        }

        .map-container.dragging .map-transform-wrapper {
            transition: none;
        }

        .hex-grid {
            display: grid;
            gap: 0;
            line-height: 0;
        }

        .hex-row {
            display: flex;
            gap: 0;
            margin-bottom: -26px;
        }

        .hex-row.offset {
            margin-left: 36px;
        }

        .hex {
            width: 80px;
            height: 92.376px;
            position: relative;
            cursor: pointer;
            margin: 0;
            margin-right: -8px;
        }

        .hex.not-rightmost-column {
            clip-path: polygon(0% 0%, calc(100% - 5px) 0%, calc(100% - 5px) 100%, 0% 100%);
        }

        .hex.drag-over {
            outline: 2px solid #4a90e2;
            outline-offset: -2px;
        }

        .hex.valid-placement::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            background-image: url('assets/game_ui/Green_Hex.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.4;
            z-index: 100;
            pointer-events: none;
        }

        .hex.invalid-placement::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            background-image: url('assets/game_ui/Red_Hex.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.4;
            z-index: 100;
            pointer-events: none;
        }

        .hex-shape {
            width: 100%;
            height: 100%;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background: transparent;
            border: none;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 15;
        }

        .hex-base {
            width: 100%;
            height: 100%;
            object-fit: cover;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .hex-feature {
            width: 70%;
            height: 70%;
            object-fit: contain;
            position: absolute;
            top: 15%;
            left: 15%;
            z-index: 2;
        }

        .hex-resource {
            height: 40px;
            object-fit: contain;
            position: absolute;
            bottom: 8px;
            right: 20px;
            z-index: 3;
            filter: drop-shadow(0 0 3px rgba(0,0,0,0.8));
        }

        .hex-district {
            width: 90%;
            height: 90%;
            object-fit: cover;
            position: absolute;
            top: 5%;
            left: calc(5% - 1px);
            z-index: 25000000;
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.9));
            cursor: grab;
        }
        
        .hex-district:active {
            cursor: grabbing;
        }

        .hex-improvement {
            width: 50%;
            height: 50%;
            object-fit: contain;
            position: absolute;
            bottom: calc(15% + 12px);
            left: calc(15% + 7px);
            z-index: 5;
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.9));
            cursor: grab;
        }
        
        .hex-improvement:active {
            cursor: grabbing;
        }

        .hex-improvement.has-resource {
            bottom: calc(15% + 25px);
        }

        .hex-wonder {
            width: 80%;
            height: 80%;
            object-fit: contain;
            position: absolute;
            top: 10%;
            left: 10%;
            z-index: 6;
            filter: drop-shadow(0 0 8px rgba(255,215,0,0.8));
        }

        .hex-rivers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            overflow: visible;
        }

        .river-edge-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
            z-index: 21;
        }

        .adjacency-indicator {
            position: absolute;
            top: 70%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 1px 3px;
            border-radius: 2px;
            font-size: 8px;
            font-weight: bold;
            z-index: 25000001;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 1px;
        }

        .yield-badge {
            display: flex;
            align-items: center;
            gap: 1px;
        }

        .yield-icon {
            width: 12px;
            height: 12px;
            object-fit: contain;
        }

        .yield-amount {
            color: #fff;
            font-size: 8px;
            line-height: 1;
        }

        .adjacency-preview {
            position: absolute;
            top: 70%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 1px 3px;
            border-radius: 2px;
            font-size: 8px;
            font-weight: bold;
            z-index: 25000001;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 1px;
        }

        .score-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #2d2d2d;
            border: 2px solid #555;
            border-radius: 8px;
            padding: 15px;
            min-width: 200px;
            z-index: 1001;
        }

        .score-panel h3 {
            margin-bottom: 10px;
            color: #4a90e2;
            font-size: 16px;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 14px;
        }

        .score-total {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 2px solid #555;
            font-weight: bold;
            font-size: 16px;
            color: #4a90e2;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1001;
        }

        .zoom-controls button {
            width: 40px;
            height: 40px;
            padding: 0;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #2d2d2d;
            border: 2px solid #555;
        }

        .zoom-controls button:hover {
            background: #3a3a3a;
            border-color: #4a90e2;
        }

        .hex-row:last-child {
            margin-bottom: 0;
        }

        .empty-state {
            text-align: center;
            color: #888;
            padding: 40px;
        }

        .empty-state h2 {
            margin-bottom: 20px;
            color: #4a90e2;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <img src="assets/logo/Logo128x128.png" alt="Civle Logo" class="header-logo">
            <h1>Civle Game</h1>
        </div>
        <div class="controls">
            <label for="loadChallenge" class="file-label">Load Challenge</label>
            <input type="file" id="loadChallenge" accept=".civle,.json" onchange="loadChallenge(event)">
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div class="empty-state">
                <h2>Load a Challenge</h2>
                <p>Upload a .civle challenge file to begin playing</p>
            </div>
        </div>

        <div class="map-container" id="mapContainer">
            <div class="empty-state">
                <h2>No Challenge Loaded</h2>
                <p>Load a challenge file to see the map</p>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let challengeData = null;
        let GRID_WIDTH = 0;
        let GRID_HEIGHT = 0;
        let placedItems = {}; // { "row,col": { type: "district"|"improvement"|"wonder", name: "..." } }
        let availableItems = {}; // { "District_Name": count, "Improvement_Name": count }
        let adjacencyData = null;
        let placementData = null;
        let resourcesData = null;

        // Zoom and pan state
        let mapZoom = 1.0;
        let mapPanX = 0;
        let mapPanY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartPanX = 0;
        let dragStartPanY = 0;
        let draggedItem = null;
        let draggedDistrict = null; // { row, col, name }
        let draggedImprovement = null; // { row, col, name }

        // Load game data from JSON files
        async function loadGameData() {
            try {
                const [adjacencyResponse, placementResponse, resourcesResponse] = await Promise.all([
                    fetch('adjacency_database.json'),
                    fetch('placement_database.json'),
                    fetch('resources_database.json')
                ]);
                
                if (!adjacencyResponse.ok || !placementResponse.ok || !resourcesResponse.ok) {
                    throw new Error('One or more files could not be loaded');
                }
                
                adjacencyData = await adjacencyResponse.json();
                placementData = await placementResponse.json();
                resourcesData = await resourcesResponse.json();
            } catch (error) {
                console.error('Error loading game data:', error);
                const isCorsError = error.message.includes('Failed to fetch') || 
                                   error.message.includes('CORS') ||
                                   error.name === 'TypeError' ||
                                   window.location.protocol === 'file:';
                
                if (isCorsError || window.location.protocol === 'file:') {
                    alert('CORS Error: Cannot load files when opening HTML directly.\n\n' +
                          'Please run a local web server:\n\n' +
                          'Python 3: python -m http.server 8000\n' +
                          'Python 2: python -m SimpleHTTPServer 8000\n' +
                          'Node.js: npx http-server\n\n' +
                          'Then open http://localhost:8000/game.html in your browser.');
                } else {
                    alert('Failed to load game data files. Make sure adjacency_database.json, placement_database.json, and resources_database.json are in the same directory.\n\nError: ' + error.message);
                }
            }
        }

        // Base36 encoding/decoding (same as map maker)
        function toBase36(num) {
            if (num === 0) return '0';
            let result = '';
            while (num > 0) {
                result = (num % 36).toString(36) + result;
                num = Math.floor(num / 36);
            }
            return result;
        }

        function fromBase36(str) {
            return parseInt(str, 36);
        }

        // Terrain, features, and resources data (same as map maker)
        const terrainBases = [
            { name: 'Desert', path: 'assets/terrain/base/flat/Desert.webp' },
            { name: 'Grassland', path: 'assets/terrain/base/flat/Grassland.webp' },
            { name: 'Plains', path: 'assets/terrain/base/flat/Plains.webp' },
            { name: 'Snow', path: 'assets/terrain/base/flat/Snow.webp' },
            { name: 'Tundra', path: 'assets/terrain/base/flat/Tundra.webp' },
            { name: 'Desert_Hill', path: 'assets/terrain/base/hills/Desert_Hill.webp' },
            { name: 'Grassland_Hill', path: 'assets/terrain/base/hills/Grassland_Hill.webp' },
            { name: 'Plains_Hill', path: 'assets/terrain/base/hills/Plains_Hill.webp' },
            { name: 'Snow_Hill', path: 'assets/terrain/base/hills/Snow_Hill.webp' },
            { name: 'Tundra_Hills', path: 'assets/terrain/base/hills/Tundra_Hills.webp' },
            { name: 'Desert_Floodplains', path: 'assets/terrain/base/floodplains/Desert_Floodplains.webp' },
            { name: 'Grassland_Floodplains', path: 'assets/terrain/base/floodplains/Grassland_Floodplains.webp' },
            { name: 'Plains_Floodplains', path: 'assets/terrain/base/floodplains/Plains_Floodplains.webp' },
            { name: 'Mountain_Desert', path: 'assets/terrain/base/mountain/Mountain_Desert.webp' },
            { name: 'Mountain_Plains', path: 'assets/terrain/base/mountain/Mountain_Plains.webp' },
            { name: 'Mountain_Snow', path: 'assets/terrain/base/mountain/Mountain_Snow.webp' },
            { name: 'Mountain_Tundra', path: 'assets/terrain/base/mountain/Mountain_Tundra.webp' },
            { name: 'Mountains_Grassland', path: 'assets/terrain/base/mountain/Mountains_Grassland.webp' },
            { name: 'Coast', path: 'assets/terrain/base/water/Coast.webp' },
            { name: 'Ocean', path: 'assets/terrain/base/water/Ocean.webp' },
            { name: 'Reef', path: 'assets/terrain/base/water/Reef.webp' }
        ];

        const features = [
            { name: 'Woods', path: 'assets/terrain/features/Woods.webp' },
            { name: 'Rainforest', path: 'assets/terrain/features/Rainforest.webp' },
            { name: 'Marsh', path: 'assets/terrain/features/Marsh.webp' },
            { name: 'Geothermal_Fissure', path: 'assets/terrain/features/Geothermal_Fissure.webp' }
        ];

        const resources = [
            'Aluminum', 'Amber', 'Bananas', 'Cattle', 'Citrus', 'Coal', 'Cocoa', 'Coffee',
            'Copper', 'Cotton', 'Crabs', 'Deer', 'Diamonds', 'Dyes', 'Fish', 'Furs',
            'Gypsum', 'Honey', 'Horses', 'Incense', 'Ivory', 'Jade', 'Maize', 'Marble',
            'Mercury', 'Niter', 'Oil', 'Olives', 'Pearls', 'Rice', 'Salt', 'Sheep',
            'Silk', 'Silver', 'Spices', 'Stone', 'Sugar', 'Tea', 'Tobacco', 'Truffles',
            'Turtles', 'Uranium', 'Whales', 'Wheat', 'Wine'
        ];

        // Create lookup maps
        const terrainIndexMap = new Map();
        terrainBases.forEach((t, i) => terrainIndexMap.set(t.name, i));
        const terrainNameMap = new Map();
        terrainBases.forEach((t, i) => terrainNameMap.set(i, t));

        const featureIndexMap = new Map();
        features.forEach((f, i) => featureIndexMap.set(f.name, i));
        const featureNameMap = new Map();
        features.forEach((f, i) => featureNameMap.set(i, f));

        const resourceIndexMap = new Map();
        resources.forEach((r, i) => resourceIndexMap.set(r, i));
        const resourceNameMap = new Map();
        resources.forEach((r, i) => resourceNameMap.set(i, r));

        // River edge images
        const riverEdgeImages = {
            0: 'Top_Right',
            1: 'Right',
            2: 'Bottom_Right',
            3: 'Bottom_Left',
            4: 'Left',
            5: 'Top_Left'
        };

        function loadChallenge(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = e.target.result;
                    
                    if (data.startsWith('CIV1')) {
                        // New optimized format
                        const width = data.charCodeAt(4) - 48;
                        const height = data.charCodeAt(5) - 48;
                        
                        GRID_WIDTH = width;
                        GRID_HEIGHT = height;
                        
                        challengeData = {
                            width: width,
                            height: height,
                            tiles: {},
                            allocations: {
                                districts: {},
                                improvements: {},
                                wonders: {}
                            }
                        };
                        
                        const tilesData = data.substring(7);
                        const parts = tilesData.split('||');
                        const tilesStr = parts[0];
                        
                        if (tilesStr) {
                            const tiles = tilesStr.split('|');
                            tiles.forEach(tileStr => {
                                if (!tileStr) return;
                                const [pos, data] = tileStr.split(':');
                                if (!pos || !data) return;
                                
                                const [rowStr, colStr] = pos.split(',');
                                const row = parseInt(rowStr);
                                const col = parseInt(colStr);
                                
                                const dataParts = data.split(';');
                                let mainData = dataParts[0];
                                
                                let tStr = '';
                                let fStr = '';
                                let rStr = '';
                                
                                if (mainData.includes(',') && mainData.split(',').length >= 3) {
                                    const fields = mainData.split(',');
                                    tStr = fields[0] || '.';
                                    fStr = fields[1] || '.';
                                    rStr = fields[2] || '.';
                                } else {
                                    tStr = mainData[0] || '.';
                                    fStr = mainData[1] || '.';
                                    rStr = mainData[2] || '.';
                                }
                                
                                const key = `${row},${col}`;
                                challengeData.tiles[key] = {};
                                
                                if (tStr && tStr !== '.') {
                                    const tIdx = fromBase36(tStr) - 1;
                                    const terrain = terrainNameMap.get(tIdx);
                                    if (terrain) {
                                        challengeData.tiles[key].terrain = terrain.name;
                                        challengeData.tiles[key].terrainPath = terrain.path;
                                    }
                                }
                                
                                if (fStr && fStr !== '.') {
                                    const fIdx = fromBase36(fStr) - 1;
                                    const feature = featureNameMap.get(fIdx);
                                    if (feature) {
                                        challengeData.tiles[key].feature = feature.name;
                                        challengeData.tiles[key].featurePath = feature.path;
                                    }
                                }
                                
                                if (rStr && rStr !== '.') {
                                    const rIdx = fromBase36(rStr) - 1;
                                    const resource = resourceNameMap.get(rIdx);
                                    if (resource) {
                                        challengeData.tiles[key].resource = resource;
                                        challengeData.tiles[key].resourcePath = `assets/recources/${resource}.webp`;
                                    }
                                }
                                
                                if (dataParts.length > 1 && dataParts[1]) {
                                    const riversBin = parseInt(dataParts[1], 36).toString(2).padStart(6, '0');
                                    challengeData.tiles[key].rivers = [];
                                    for (let i = 0; i < 6; i++) {
                                        challengeData.tiles[key].rivers[i] = riversBin[i] === '1';
                                    }
                                }
                            });
                        }
                        
                        // Load allocations
                        const allocationsStr = parts.length > 1 ? parts[1] : null;
                        if (allocationsStr) {
                            const allocations = allocationsStr.split(',');
                            allocations.forEach(allocStr => {
                                if (!allocStr) return;
                                const parts = allocStr.split(':');
                                const type = parts[0];
                                const name = parts[1];
                                
                                if (type === 'd') {
                                    if (parts[2] === 'c') {
                                        challengeData.allocations.districts[name] = true;
                                    } else {
                                        challengeData.allocations.districts[name] = parseInt(parts[2]) || 0;
                                    }
                                } else if (type === 'i') {
                                    challengeData.allocations.improvements[name] = parseInt(parts[2]) || 0;
                                } else if (type === 'w') {
                                    challengeData.allocations.wonders[name] = true;
                                }
                            });
                        }
                    } else {
                        // Old JSON format
                        const loadedData = JSON.parse(data);
                        challengeData = loadedData;
                        GRID_WIDTH = loadedData.width;
                        GRID_HEIGHT = loadedData.height;
                    }
                    
                    // Initialize game
                    placedItems = {};
                    availableItems = {};
                    
                    // Copy allocations to available items
                    Object.keys(challengeData.allocations.districts).forEach(name => {
                        const count = challengeData.allocations.districts[name];
                        if (count === true) {
                            availableItems[name] = 1;
                        } else if (count > 0) {
                            availableItems[name] = count;
                        }
                    });
                    
                    Object.keys(challengeData.allocations.improvements).forEach(name => {
                        const count = challengeData.allocations.improvements[name];
                        if (count > 0) {
                            availableItems[name] = count;
                        }
                    });
                    
                    Object.keys(challengeData.allocations.wonders).forEach(name => {
                        if (challengeData.allocations.wonders[name]) {
                            availableItems[name] = 1;
                        }
                    });
                    
                    initializeGame();
                } catch (error) {
                    console.error('Error loading challenge:', error);
                    alert('Failed to load challenge file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function initializeGame() {
            createHexGrid();
            populateSidebar();
            initMapZoomPan();
            updateAllScores();
        }

        function createHexGrid() {
            const mapContainer = document.getElementById('mapContainer');
            mapContainer.innerHTML = '';
            
            const mapTransformWrapper = document.createElement('div');
            mapTransformWrapper.className = 'map-transform-wrapper';
            mapTransformWrapper.id = 'mapTransformWrapper';
            
            const grid = document.createElement('div');
            grid.className = 'hex-grid';
            grid.id = 'hexGrid';
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                const hexRow = document.createElement('div');
                hexRow.className = 'hex-row';
                if (row % 2 === 1) {
                    hexRow.classList.add('offset');
                }

                for (let col = 0; col < GRID_WIDTH; col++) {
                    const hex = createHex(row, col);
                    hexRow.appendChild(hex);
                }

                grid.appendChild(hexRow);
            }
            
            mapTransformWrapper.appendChild(grid);
            
            // Create a separate districts layer on top of everything
            const districtsLayer = document.createElement('div');
            districtsLayer.className = 'hex-grid';
            districtsLayer.id = 'districtsLayer';
            districtsLayer.style.position = 'absolute';
            districtsLayer.style.top = '0';
            districtsLayer.style.left = '0';
            districtsLayer.style.pointerEvents = 'none';
            districtsLayer.style.zIndex = '1000';
            
            // Create districts grid structure
            for (let row = 0; row < GRID_HEIGHT; row++) {
                const hexRow = document.createElement('div');
                hexRow.className = 'hex-row';
                if (row % 2 === 1) {
                    hexRow.classList.add('offset');
                }

                for (let col = 0; col < GRID_WIDTH; col++) {
                    const districtHex = document.createElement('div');
                    districtHex.className = 'hex';
                    districtHex.dataset.row = row;
                    districtHex.dataset.col = col;
                    districtHex.style.pointerEvents = 'none';
                    
                    const districtShape = document.createElement('div');
                    districtShape.className = 'hex-shape';
                    districtShape.id = `district-shape-${row}-${col}`;
                    
                    districtHex.appendChild(districtShape);
                    hexRow.appendChild(districtHex);
                }
                
                districtsLayer.appendChild(hexRow);
            }
            
            mapTransformWrapper.appendChild(districtsLayer);
            mapTransformWrapper.style.position = 'relative';
            mapContainer.appendChild(mapTransformWrapper);
            
            // Update visuals for all hexes after they're in the DOM
            // First pass: render everything EXCEPT districts
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    updateHexVisualBase(row, col);
                }
            }
            // Second pass: render districts in separate layer
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    updateHexVisualDistricts(row, col);
                }
            }
            
            // Add score panel
            const scorePanel = document.createElement('div');
            scorePanel.className = 'score-panel';
            scorePanel.id = 'scorePanel';
            mapContainer.appendChild(scorePanel);
            
            // Add zoom controls
            const zoomControls = document.createElement('div');
            zoomControls.className = 'zoom-controls';
            zoomControls.innerHTML = `
                <button id="zoomInBtn" title="Zoom In">+</button>
                <button id="zoomOutBtn" title="Zoom Out">−</button>
                <button id="resetZoomBtn" title="Reset Zoom">⌂</button>
            `;
            mapContainer.appendChild(zoomControls);
        }

        function createHex(row, col) {
            const hex = document.createElement('div');
            hex.className = 'hex';
            // Add class if not in rightmost column
            if (col < GRID_WIDTH - 1) {
                hex.classList.add('not-rightmost-column');
            } else {
                hex.classList.add('rightmost-column');
            }
            hex.dataset.row = row;
            hex.dataset.col = col;

            const hexShape = document.createElement('div');
            hexShape.className = 'hex-shape';

            const riversContainer = document.createElement('div');
            riversContainer.className = 'hex-rivers';

            hex.appendChild(hexShape);
            hex.appendChild(riversContainer);

            // Drag and drop handlers
            hex.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                // Don't show blue box when dragging districts - we have red/green highlights instead
            });

            hex.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (draggedItem) {
                    // Dragging from sidebar
                    placeItem(row, col, draggedItem.type, draggedItem.name);
                    draggedItem = null;
                } else if (draggedDistrict) {
                    // Dragging a district to move it
                    const sourceKey = `${draggedDistrict.row},${draggedDistrict.col}`;
                    const targetKey = `${row},${col}`;
                    
                    // If dropping on the same hex, do nothing
                    if (sourceKey !== targetKey) {
                        const tile = challengeData.tiles[targetKey];
                        const districtName = draggedDistrict.name;
                        
                        // Check if valid placement (exclude old location when moving)
                        if (isValidPlacement(row, col, 'district', districtName, tile, { row: draggedDistrict.row, col: draggedDistrict.col })) {
                            // Remove from old location (this adds it back to availableItems)
                            const oldKey = `${draggedDistrict.row},${draggedDistrict.col}`;
                            delete placedItems[oldKey];
                            availableItems[districtName] = (availableItems[districtName] || 0) + 1;
                            
                            // Place at new location (subtract from availableItems to keep count correct)
                            const key = `${row},${col}`;
                            // Remove any existing item at this location
                            if (placedItems[key]) {
                                const oldItem = placedItems[key];
                                availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
                            }
                            placedItems[key] = { type: 'district', name: districtName };
                            availableItems[districtName] = (availableItems[districtName] || 0) - 1;
                            
                            // Update visuals for old location and its neighbors
                            updateHexVisual(draggedDistrict.row, draggedDistrict.col);
                            const oldNeighbors = getNeighbors(draggedDistrict.row, draggedDistrict.col);
                            oldNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            // Update visuals for new location and its neighbors
                            updateHexVisual(row, col);
                            const newNeighbors = getNeighbors(row, col);
                            newNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            updateAllScores();
                            populateSidebar();
                            // Clear draggedDistrict on successful move
                            draggedDistrict = null;
                        } else {
                            // Invalid placement - district stays in original location
                            // draggedDistrict will be cleared in dragend
                        }
                    } else {
                        // Dropped on same hex - do nothing
                        draggedDistrict = null;
                    }
                } else if (draggedImprovement) {
                    // Dragging an improvement to move it
                    const sourceKey = `${draggedImprovement.row},${draggedImprovement.col}`;
                    const targetKey = `${row},${col}`;
                    
                    // If dropping on the same hex, do nothing
                    if (sourceKey !== targetKey) {
                        const tile = challengeData.tiles[targetKey];
                        const improvementName = draggedImprovement.name;
                        
                        // Check if valid placement
                        if (isValidPlacement(row, col, 'improvement', improvementName, tile)) {
                            // Remove from old location (this adds it back to availableItems)
                            const oldKey = `${draggedImprovement.row},${draggedImprovement.col}`;
                            delete placedItems[oldKey];
                            availableItems[improvementName] = (availableItems[improvementName] || 0) + 1;
                            
                            // Place at new location (subtract from availableItems to keep count correct)
                            const key = `${row},${col}`;
                            // Remove any existing item at this location
                            if (placedItems[key]) {
                                const oldItem = placedItems[key];
                                availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
                            }
                            placedItems[key] = { type: 'improvement', name: improvementName };
                            availableItems[improvementName] = (availableItems[improvementName] || 0) - 1;
                            
                            // Update visuals for old location and its neighbors (to update adjacent district adjacencies)
                            updateHexVisual(draggedImprovement.row, draggedImprovement.col);
                            const oldNeighbors = getNeighbors(draggedImprovement.row, draggedImprovement.col);
                            oldNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            // Update visuals for new location and its neighbors (to update adjacent district adjacencies)
                            updateHexVisual(row, col);
                            const newNeighbors = getNeighbors(row, col);
                            newNeighbors.forEach(neighbor => {
                                updateHexVisual(neighbor.row, neighbor.col);
                            });
                            
                            updateAllScores();
                            populateSidebar();
                            // Clear draggedImprovement on successful move
                            draggedImprovement = null;
                        } else {
                            // Invalid placement - improvement stays in original location
                            // draggedImprovement will be cleared in dragend
                        }
                    } else {
                        // Dropped on same hex - do nothing
                        draggedImprovement = null;
                    }
                }
            });

            // Right-click to remove item
            hex.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                removeItem(row, col);
            });

            return hex;
        }

        function updateHexVisualBase(row, col) {
            const hexGrid = document.getElementById('hexGrid');
            if (!hexGrid) return;
            const hex = hexGrid.querySelector(`.hex[data-row="${row}"][data-col="${col}"]`);
            if (!hex) return;

            const hexShape = hex.querySelector('.hex-shape');
            if (!hexShape) return;

            // Remove existing images
            hexShape.querySelectorAll('img').forEach(el => el.remove());
            hexShape.querySelectorAll('.adjacency-indicator').forEach(el => el.remove());

            const key = `${row},${col}`;
            const tile = challengeData.tiles[key];
            const placed = placedItems[key];

            // Always add Blank.webp as base
            const blankImg = document.createElement('img');
            blankImg.className = 'hex-base';
            blankImg.src = 'assets/terrain/base/other/Blank.webp';
            blankImg.alt = 'Blank';
            blankImg.draggable = false;
            hexShape.appendChild(blankImg);

            if (tile) {
                if (tile.terrainPath) {
                    blankImg.src = tile.terrainPath;
                    blankImg.alt = tile.terrain;
                }
                if (tile.featurePath) {
                    const img = document.createElement('img');
                    img.className = 'hex-feature';
                    img.src = tile.featurePath;
                    img.alt = tile.feature;
                    img.draggable = false;
                    hexShape.appendChild(img);
                }
                if (tile.resourcePath) {
                    const img = document.createElement('img');
                    img.className = 'hex-resource';
                    img.src = tile.resourcePath;
                    img.alt = tile.resource;
                    img.draggable = false;
                    hexShape.appendChild(img);
                }
                
                // Draw river edges
                if (tile.rivers) {
                    const riversContainer = hex.querySelector('.hex-rivers');
                    if (riversContainer) {
                        riversContainer.innerHTML = '';
                        for (let edge = 0; edge < 6; edge++) {
                            if (tile.rivers[edge] === true) {
                                const imageName = riverEdgeImages[edge];
                                if (imageName) {
                                    const img = document.createElement('img');
                                    img.className = 'river-edge-image';
                                    img.src = `assets/terrain/river_edges/${imageName}.png`;
                                    img.alt = `River edge ${edge}`;
                                    img.style.zIndex = (21 + edge);
                                    img.draggable = false;
                                    riversContainer.appendChild(img);
                                }
                            }
                        }
                    }
                }
            }

            // Add placed items (but NOT districts yet - they go last)
            if (placed) {
                if (placed.type === 'improvement') {
                    const img = document.createElement('img');
                    img.className = 'hex-improvement';
                    // If tile has a resource, add class to position improvement higher
                    if (tile && tile.resource) {
                        img.classList.add('has-resource');
                    }
                    img.src = `assets/improvements/${placed.name}.webp`;
                    img.alt = placed.name;
                    img.draggable = true;
                    img.dataset.row = row;
                    img.dataset.col = col;
                    img.style.pointerEvents = 'auto';
                    img.style.cursor = 'grab';
                    
                    img.addEventListener('dragstart', (e) => {
                        e.stopPropagation();
                        draggedImprovement = { row, col, name: placed.name };
                        
                        // Make the image semi-transparent while dragging
                        img.style.opacity = '0.5';
                        img.style.cursor = 'grabbing';
                        
                        // Create a custom drag image (opaque version)
                        const dragImg = document.createElement('img');
                        dragImg.src = img.src;
                        dragImg.style.width = '64px';
                        dragImg.style.height = '64px';
                        dragImg.style.position = 'absolute';
                        dragImg.style.top = '-1000px';
                        dragImg.style.opacity = '1';
                        document.body.appendChild(dragImg);
                        
                        // Set drag image - use the center of the 64x64 image
                        if (dragImg.complete && dragImg.naturalWidth > 0) {
                            e.dataTransfer.setDragImage(dragImg, 32, 32);
                            setTimeout(() => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            }, 0);
                        } else {
                            dragImg.onload = () => {
                                e.dataTransfer.setDragImage(dragImg, 32, 32);
                                setTimeout(() => {
                                    if (dragImg.parentNode) {
                                        document.body.removeChild(dragImg);
                                    }
                                }, 0);
                            };
                            dragImg.onerror = () => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            };
                        }
                        
                        e.dataTransfer.effectAllowed = 'move';
                        // Show red/green highlights just like dragging from sidebar
                        // Skip availability check since we're moving an already-placed improvement
                        highlightAllTiles('improvement', placed.name, true);
                    });
                    
                    img.addEventListener('dragend', (e) => {
                        e.stopPropagation();
                        
                        // Clear all highlights
                        clearAllHighlights();
                        
                        // Restore opacity if improvement wasn't moved (drop failed or cancelled)
                        if (draggedImprovement) {
                            const draggedImg = document.querySelector(`.hex-improvement[data-row="${draggedImprovement.row}"][data-col="${draggedImprovement.col}"]`);
                            if (draggedImg) {
                                draggedImg.style.opacity = '1';
                                draggedImg.style.cursor = 'grab';
                            }
                            // Clear if not already cleared by successful drop
                            setTimeout(() => {
                                if (draggedImprovement) {
                                    draggedImprovement = null;
                                }
                            }, 100);
                        }
                    });
                    
                    hexShape.appendChild(img);
                } else if (placed.type === 'wonder') {
                    const img = document.createElement('img');
                    img.className = 'hex-wonder';
                    img.src = `assets/wonders/${placed.name}.webp`;
                    img.alt = placed.name;
                    img.draggable = false;
                    hexShape.appendChild(img);
                }
            }
        }

        function updateHexVisualDistricts(row, col) {
            // Render districts in the separate districts layer
            const districtShape = document.getElementById(`district-shape-${row}-${col}`);
            if (!districtShape) return;

            // Clear existing content
            districtShape.innerHTML = '';

            const key = `${row},${col}`;
            const placed = placedItems[key];

            // Add districts LAST so they appear on top of everything
            if (placed && placed.type === 'district') {
                const img = document.createElement('img');
                img.className = 'hex-district';
                img.src = `assets/districts/${placed.name}.webp`;
                img.alt = placed.name;
                img.draggable = true;
                img.dataset.row = row;
                img.dataset.col = col;
                img.style.pointerEvents = 'auto'; // Allow drag events
                
                // Add drag handlers for districts
                img.addEventListener('dragstart', (e) => {
                    draggedDistrict = { row, col, name: placed.name };
                    img.style.opacity = '0.5';
                    img.style.cursor = 'grabbing';
                    e.stopPropagation(); // Prevent event from bubbling
                    
                    // Create a custom drag image with an opaque version of the district
                    const dragImg = new Image();
                    dragImg.src = `assets/districts/${placed.name}.webp`;
                    dragImg.style.width = '64px';
                    dragImg.style.height = '64px';
                    dragImg.style.opacity = '1';
                    dragImg.style.position = 'fixed';
                    dragImg.style.left = '-1000px';
                    dragImg.style.top = '-1000px';
                    dragImg.style.pointerEvents = 'none';
                    document.body.appendChild(dragImg);
                    
                    // Set drag image - use the center of the 64x64 image
                    if (dragImg.complete && dragImg.naturalWidth > 0) {
                        e.dataTransfer.setDragImage(dragImg, 32, 32);
                        setTimeout(() => {
                            if (dragImg.parentNode) {
                                document.body.removeChild(dragImg);
                            }
                        }, 0);
                    } else {
                        dragImg.onload = () => {
                            e.dataTransfer.setDragImage(dragImg, 32, 32);
                            setTimeout(() => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            }, 0);
                        };
                        dragImg.onerror = () => {
                            if (dragImg.parentNode) {
                                document.body.removeChild(dragImg);
                            }
                        };
                    }
                    
                    e.dataTransfer.effectAllowed = 'move';
                    // Show red/green highlights just like dragging from sidebar
                    // Skip availability check since we're moving an already-placed district
                    // Exclude the old location from adjacency calculations
                    highlightAllTiles('district', placed.name, true, { row, col });
                });
                
                img.addEventListener('dragend', (e) => {
                    e.stopPropagation();
                    
                    // Clear all highlights
                    clearAllHighlights();
                    
                    // Restore opacity if district wasn't moved (drop failed or cancelled)
                    if (draggedDistrict) {
                        const draggedImg = document.querySelector(`.hex-district[data-row="${draggedDistrict.row}"][data-col="${draggedDistrict.col}"]`);
                        if (draggedImg) {
                            draggedImg.style.opacity = '1';
                            draggedImg.style.cursor = 'grab';
                        }
                        // Clear if not already cleared by successful drop
                        setTimeout(() => {
                            if (draggedDistrict) {
                                draggedDistrict = null;
                            }
                        }, 100);
                    }
                });
                
                districtShape.appendChild(img);
                
                // Add adjacency indicator for districts with yield icons
                const adjacency = calculateAdjacency(row, col);
                if (adjacency && adjacency.total > 0) {
                    const indicator = document.createElement('div');
                    indicator.className = 'adjacency-indicator';
                    
                    // Add yield badges for each yield type that has a bonus
                    const yieldTypes = [
                        { name: 'Science', value: adjacency.science, icon: 'assets/yields/Science.webp' },
                        { name: 'Faith', value: adjacency.faith, icon: 'assets/yields/Faith.webp' },
                        { name: 'Gold', value: adjacency.gold, icon: 'assets/yields/Gold.webp' },
                        { name: 'Production', value: adjacency.production, icon: 'assets/yields/Production.webp' },
                        { name: 'Culture', value: adjacency.culture, icon: 'assets/yields/Culture.webp' }
                    ];
                    
                    yieldTypes.forEach(yieldType => {
                        if (yieldType.value > 0) {
                            const badge = document.createElement('div');
                            badge.className = 'yield-badge';
                            
                            const amount = document.createElement('span');
                            amount.className = 'yield-amount';
                            amount.textContent = `+${yieldType.value}`;
                            
                            const icon = document.createElement('img');
                            icon.className = 'yield-icon';
                            icon.src = yieldType.icon;
                            icon.alt = yieldType.name;
                            icon.draggable = false;
                            
                            badge.appendChild(amount);
                            badge.appendChild(icon);
                            indicator.appendChild(badge);
                        }
                    });
                    
                    districtShape.appendChild(indicator);
                }
            }
        }

        function updateHexVisual(row, col) {
            updateHexVisualBase(row, col);
            updateHexVisualDistricts(row, col);
        }

        function populateSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.innerHTML = '';
            
            sidebar.innerHTML = '<h2>Available Items</h2>';
            
            // Districts
            const districtsSection = document.createElement('div');
            districtsSection.innerHTML = '<h3 style="margin-top: 15px; margin-bottom: 10px; color: #4a90e2; font-size: 16px;">Districts</h3>';
            
            Object.keys(availableItems).forEach(name => {
                const itemData = placementData.districts.find(d => d.name === name);
                if (itemData) {
                    const item = createAvailableItem(name, 'district', availableItems[name]);
                    districtsSection.appendChild(item);
                }
            });
            
            sidebar.appendChild(districtsSection);
            
            // Improvements
            const improvementsSection = document.createElement('div');
            let hasImprovements = false;
            
            Object.keys(availableItems).forEach(name => {
                const itemData = placementData.improvements.find(i => i.name === name);
                if (itemData) {
                    if (!hasImprovements) {
                        improvementsSection.innerHTML = '<h3 style="margin-top: 15px; margin-bottom: 10px; color: #4a90e2; font-size: 16px;">Improvements</h3>';
                        hasImprovements = true;
                    }
                    const item = createAvailableItem(name, 'improvement', availableItems[name]);
                    improvementsSection.appendChild(item);
                }
            });
            
            if (hasImprovements) {
                sidebar.appendChild(improvementsSection);
            }
            
            // Wonders
            const wondersSection = document.createElement('div');
            let hasWonders = false;
            
            Object.keys(availableItems).forEach(name => {
                const itemData = placementData.wonders.find(w => w.name === name);
                if (itemData) {
                    if (!hasWonders) {
                        wondersSection.innerHTML = '<h3 style="margin-top: 15px; margin-bottom: 10px; color: #4a90e2; font-size: 16px;">Wonders</h3>';
                        hasWonders = true;
                    }
                    const item = createAvailableItem(name, 'wonder', availableItems[name]);
                    wondersSection.appendChild(item);
                }
            });
            
            if (hasWonders) {
                sidebar.appendChild(wondersSection);
            }
        }

        function createAvailableItem(name, type, count) {
            const item = document.createElement('div');
            item.className = 'available-item';
            item.draggable = count > 0;
            item.dataset.name = name;
            item.dataset.type = type;
            
            if (count === 0) {
                item.style.opacity = '0.5';
                item.style.cursor = 'not-allowed';
            }
            
            let imgPath = '';
            if (type === 'district') {
                imgPath = `assets/districts/${name}.webp`;
            } else if (type === 'improvement') {
                imgPath = `assets/improvements/${name}.webp`;
            } else if (type === 'wonder') {
                imgPath = `assets/wonders/${name}.webp`;
            }
            
            const img = document.createElement('img');
            img.src = imgPath;
            img.alt = name;
            img.draggable = false;
            img.onerror = () => { img.style.display = 'none'; };
            
            const span = document.createElement('span');
            span.textContent = name.replace(/_/g, ' ');
            
            const countSpan = document.createElement('span');
            countSpan.className = 'count' + (count === 0 ? ' zero' : '');
            countSpan.textContent = `x${count}`;
            
            item.appendChild(img);
            item.appendChild(span);
            item.appendChild(countSpan);
            
            item.addEventListener('dragstart', (e) => {
                if (count > 0) {
                    draggedItem = { type, name };
                    item.classList.add('dragging');
                    
                    // Create a custom drag image with the district/improvement icon
                    // Use the existing image from the sidebar item, but create a larger version
                    const dragImg = new Image();
                    dragImg.src = imgPath;
                    dragImg.style.width = '64px';
                    dragImg.style.height = '64px';
                    dragImg.style.opacity = '1';
                    dragImg.style.position = 'fixed';
                    dragImg.style.left = '-1000px';
                    dragImg.style.top = '-1000px';
                    dragImg.style.pointerEvents = 'none';
                    document.body.appendChild(dragImg);
                    
                    // Set drag image - use the center of the 64x64 image
                    if (dragImg.complete && dragImg.naturalWidth > 0) {
                        e.dataTransfer.setDragImage(dragImg, 32, 32);
                        setTimeout(() => {
                            if (dragImg.parentNode) {
                                document.body.removeChild(dragImg);
                            }
                        }, 0);
                    } else {
                        dragImg.onload = () => {
                            e.dataTransfer.setDragImage(dragImg, 32, 32);
                            setTimeout(() => {
                                if (dragImg.parentNode) {
                                    document.body.removeChild(dragImg);
                                }
                            }, 0);
                        };
                        dragImg.onerror = () => {
                            if (dragImg.parentNode) {
                                document.body.removeChild(dragImg);
                            }
                        };
                    }
                    
                    // Highlight all tiles based on placement validity
                    highlightAllTiles(type, name);
                } else {
                    e.preventDefault();
                }
            });
            
            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                draggedItem = null;
                
                // Remove all highlights
                clearAllHighlights();
            });
            
            return item;
        }

        function placeItem(row, col, type, name) {
            const key = `${row},${col}`;
            const tile = challengeData.tiles[key];
            
            // Check if placement is valid
            if (!isValidPlacement(row, col, type, name, tile)) {
                return;
            }
            
            // Check if item is available
            if (availableItems[name] <= 0) {
                return;
            }
            
            // Remove any existing item at this location
            if (placedItems[key]) {
                const oldItem = placedItems[key];
                availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
            }
            
            // Place new item
            placedItems[key] = { type, name };
            availableItems[name] = (availableItems[name] || 0) - 1;
            
            // Update visuals for this hex and all neighbors (for adjacency indicators)
            updateHexVisual(row, col);
            const neighbors = getNeighbors(row, col);
            neighbors.forEach(neighbor => {
                updateHexVisual(neighbor.row, neighbor.col);
            });
            updateAllScores();
            populateSidebar();
        }

        function removeItem(row, col) {
            const key = `${row},${col}`;
            if (!placedItems[key]) return;
            
            const oldItem = placedItems[key];
            delete placedItems[key];
            availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
            
            // Update visuals for this hex and all neighbors
            updateHexVisual(row, col);
            const neighbors = getNeighbors(row, col);
            neighbors.forEach(neighbor => {
                updateHexVisual(neighbor.row, neighbor.col);
            });
            updateAllScores();
            populateSidebar();
        }

        function isValidPlacement(row, col, type, name, tile, excludeLocation = null) {
            if (!tile || !tile.terrain) return false;
            
            let itemData = null;
            if (type === 'district') {
                itemData = placementData.districts.find(d => d.name === name);
            } else if (type === 'improvement') {
                itemData = placementData.improvements.find(i => i.name === name);
            } else if (type === 'wonder') {
                itemData = placementData.wonders.find(w => w.name === name);
            }
            
            if (!itemData) return false;
            
            // Check terrain
            if (itemData.allowed_terrain && !itemData.allowed_terrain.includes(tile.terrain)) {
                return false;
            }
            
            // Check city center adjacency rules for districts
            if (type === 'district') {
                // City centers must be at least 3 tiles apart
                if (name === 'City_Center') {
                    for (const [key, placed] of Object.entries(placedItems)) {
                        if (placed.type === 'district' && placed.name === 'City_Center') {
                            const [existingRow, existingCol] = key.split(',').map(Number);
                            // Skip if this is the same location or the excluded location (when moving)
                            if ((existingRow === row && existingCol === col) || 
                                (excludeLocation && existingRow === excludeLocation.row && existingCol === excludeLocation.col)) {
                                continue;
                            }
                            const distance = getHexDistance(row, col, existingRow, existingCol);
                            if (distance <= 3) {
                                return false;
                            }
                        }
                    }
                }
                
                if (itemData.must_be_adjacent_to_city_center && !hasCityCenterAdjacent(row, col)) {
                    return false;
                }
                if (itemData.cant_be_adjacent_to_city_center && hasCityCenterAdjacent(row, col)) {
                    return false;
                }
                
                // Districts cannot be built on strategic or luxury resources
                if (tile.resource && resourcesData) {
                    const isStrategic = resourcesData.strategic_resources.some(r => r.name === tile.resource);
                    const isLuxury = resourcesData.luxury_resources.some(r => r.name === tile.resource);
                    if (isStrategic || isLuxury) {
                        return false;
                    }
                }
                
                // Districts cannot be built on geothermal fissures
                if (tile.feature === 'Geothermal_Fissure') {
                    return false;
                }
            }
            
            // Check improvement requirements
            if (type === 'improvement') {
                // Check if must be on woods
                if (itemData.must_be_on_woods && tile.feature !== 'Woods') {
                    return false;
                }
                
                // Check if must be coastal
                if (itemData.must_be_coastal) {
                    const neighbors = getNeighbors(row, col);
                    let hasCoast = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        if (neighborTile && (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                            hasCoast = true;
                            break;
                        }
                    }
                    if (!hasCoast) return false;
                }
                
                // Check resource requirements
                if (itemData.only_buildable_on_resources) {
                    if (!tile.resource || !itemData.resources_its_built_on.includes(tile.resource)) {
                        return false;
                    }
                } else if (itemData.resources_its_built_on && itemData.resources_its_built_on.length > 0) {
                    // Can be built on resource or without
                    if (tile.resource && !itemData.resources_its_built_on.includes(tile.resource)) {
                        return false;
                    }
                }
            }
            
            // Check wonder requirements
            if (type === 'wonder') {
                // Check allowed features
                if (itemData.allowed_features && itemData.allowed_features.length > 0) {
                    if (!tile.feature || !itemData.allowed_features.includes(tile.feature)) {
                        return false;
                    }
                }
                
                // Check required feature adjacency
                if (itemData.required_feature_adjacency && itemData.required_feature_adjacency.length > 0) {
                    const neighbors = getNeighbors(row, col);
                    let hasRequiredFeature = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        if (neighborTile && itemData.required_feature_adjacency.includes(neighborTile.feature)) {
                            hasRequiredFeature = true;
                            break;
                        }
                    }
                    if (!hasRequiredFeature) return false;
                }
                
                // Check required resource adjacency
                if (itemData.required_resource_adjacency && itemData.required_resource_adjacency.length > 0) {
                    const neighbors = getNeighbors(row, col);
                    let hasRequiredResource = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        if (neighborTile && neighborTile.resource && itemData.required_resource_adjacency.includes(neighborTile.resource)) {
                            hasRequiredResource = true;
                            break;
                        }
                    }
                    if (!hasRequiredResource) return false;
                }
                
                // Check required district adjacency
                if (itemData.required_district_adjacency && itemData.required_district_adjacency.length > 0) {
                    const neighbors = getNeighbors(row, col);
                    let hasRequiredDistrict = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const placed = placedItems[neighborKey];
                        if (placed && placed.type === 'district' && itemData.required_district_adjacency.includes(placed.name)) {
                            hasRequiredDistrict = true;
                            break;
                        }
                    }
                    if (!hasRequiredDistrict) return false;
                }
            }
            
            return true;
        }

        function hasCityCenterAdjacent(row, col) {
            const neighbors = getNeighbors(row, col);
            for (const neighbor of neighbors) {
                const key = `${neighbor.row},${neighbor.col}`;
                const placed = placedItems[key];
                if (placed && placed.type === 'district' && placed.name === 'City_Center') {
                    return true;
                }
            }
            return false;
        }

        function highlightAllTiles(type, name, skipAvailabilityCheck = false, excludeLocation = null) {
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const hexGrid = document.getElementById('hexGrid');
                    if (!hexGrid) continue;
                    const hex = hexGrid.querySelector(`.hex[data-row="${row}"][data-col="${col}"]`);
                    if (!hex) continue;
                    
                    // Remove any existing preview
                    const existingPreview = hex.querySelector('.adjacency-preview');
                    if (existingPreview) {
                        existingPreview.remove();
                    }
                    
                    const key = `${row},${col}`;
                    const tile = challengeData.tiles[key];
                    
                    // Check if placement is valid
                    const isValid = isValidPlacement(row, col, type, name, tile, excludeLocation);
                    const isAvailable = skipAvailabilityCheck || availableItems[name] > 0;
                    
                    if (isValid && isAvailable) {
                        hex.classList.add('valid-placement');
                        hex.classList.remove('invalid-placement');
                        
                        // If dragging a district, show adjacency preview
                        if (type === 'district') {
                            const preview = calculateAdjacencyPreview(row, col, name, excludeLocation);
                            if (preview && preview.total > 0) {
                                const previewIndicator = document.createElement('div');
                                previewIndicator.className = 'adjacency-preview';
                                
                                const yieldTypes = [
                                    { name: 'Science', value: preview.science, icon: 'assets/yields/Science.webp' },
                                    { name: 'Faith', value: preview.faith, icon: 'assets/yields/Faith.webp' },
                                    { name: 'Gold', value: preview.gold, icon: 'assets/yields/Gold.webp' },
                                    { name: 'Production', value: preview.production, icon: 'assets/yields/Production.webp' },
                                    { name: 'Culture', value: preview.culture, icon: 'assets/yields/Culture.webp' }
                                ];
                                
                                yieldTypes.forEach(yieldType => {
                                    if (yieldType.value > 0) {
                                        const badge = document.createElement('div');
                                        badge.className = 'yield-badge';
                                        
                                        const amount = document.createElement('span');
                                        amount.className = 'yield-amount';
                                        amount.textContent = `+${yieldType.value}`;
                                        
                                        const icon = document.createElement('img');
                                        icon.className = 'yield-icon';
                                        icon.src = yieldType.icon;
                                        icon.alt = yieldType.name;
                                        icon.draggable = false;
                                        
                                        badge.appendChild(amount);
                                        badge.appendChild(icon);
                                        previewIndicator.appendChild(badge);
                                    }
                                });
                                
                                hex.appendChild(previewIndicator);
                            }
                        }
                    } else {
                        hex.classList.add('invalid-placement');
                        hex.classList.remove('valid-placement');
                    }
                }
            }
        }

        function clearAllHighlights() {
            const hexGrid = document.getElementById('hexGrid');
            if (!hexGrid) return;
            
            const allHexes = hexGrid.querySelectorAll('.hex');
            allHexes.forEach(hex => {
                hex.classList.remove('valid-placement');
                hex.classList.remove('invalid-placement');
                // Remove any adjacency previews
                const preview = hex.querySelector('.adjacency-preview');
                if (preview) {
                    preview.remove();
                }
            });
        }

        function calculateAdjacencyPreview(row, col, districtName, excludeLocation = null) {
            // Calculate what adjacency would be if this district were placed here
            const districtBonus = adjacencyData.district_adjacency_bonuses.find(d => d.name === districtName);
            if (!districtBonus) return null;
            
            const key = `${row},${col}`;
            const tile = challengeData.tiles[key];
            const neighbors = getNeighbors(row, col);
            
            let science = 0;
            let faith = 0;
            let gold = 0;
            let production = 0;
            let culture = 0;
            
            const bonuses = districtBonus.adjacency_bonuses;
            
            // Check for river edges on this tile (River_Edge is about the tile itself having a river)
            if (tile && tile.rivers) {
                let hasRiver = false;
                for (let i = 0; i < 6; i++) {
                    if (tile.rivers[i]) {
                        hasRiver = true;
                        break;
                    }
                }
                if (hasRiver && bonuses.River_Edge) {
                    const bonus = bonuses.River_Edge;
                    if (bonus.type === 'Gold') gold += bonus.bonus;
                }
            }
            
            // Check neighbors for terrain, features, and resources
            let districtCount = 0;
            let cityCenterCount = 0;
            let harborCount = 0;
            let commercialHubCount = 0;
            let wonderCount = 0;
            let entertainmentComplexCount = 0;
            let waterParkCount = 0;
            let governmentPlazaCount = 0;
            let aqueductCount = 0;
            let damCount = 0;
            let canalCount = 0;
            let improvementCounts = {};
            let mountainCount = 0;
            let rainforestCount = 0;
            let geothermalFissureCount = 0;
            let reefCount = 0;
            let coastalResourceCount = 0;
            
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                // Skip if this is the excluded location (when moving a district)
                if (excludeLocation && neighbor.row === excludeLocation.row && neighbor.col === excludeLocation.col) {
                    return;
                }
                
                const neighborPlaced = placedItems[neighborKey];
                const neighborTile = challengeData.tiles[neighborKey];
                
                // Check neighbor terrain/features for adjacency bonuses
                if (neighborTile) {
                    // Check for mountains
                    if (neighborTile.terrain && neighborTile.terrain.includes('Mountain')) {
                        mountainCount++;
                    }
                    // Check for features
                    if (neighborTile.feature === 'Rainforest') {
                        rainforestCount++;
                    }
                    if (neighborTile.feature === 'Geothermal_Fissure') {
                        geothermalFissureCount++;
                    }
                    // Check for reef
                    if (neighborTile.terrain === 'Reef') {
                        reefCount++;
                    }
                    // Check for coastal resources (resources on coast/ocean/reef tiles)
                    if (neighborTile.resource && (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                        coastalResourceCount++;
                    }
                }
                
                if (neighborPlaced) {
                    if (neighborPlaced.type === 'district') {
                        districtCount++;
                        if (neighborPlaced.name === 'City_Center') cityCenterCount++;
                        if (neighborPlaced.name === 'Harbor') harborCount++;
                        if (neighborPlaced.name === 'Commercial_Hub') commercialHubCount++;
                        if (neighborPlaced.name === 'Government_Plaza') governmentPlazaCount++;
                        if (neighborPlaced.name === 'Entertainment_Complex') entertainmentComplexCount++;
                        if (neighborPlaced.name === 'Water_Park') waterParkCount++;
                        if (neighborPlaced.name === 'Aqueduct') aqueductCount++;
                        if (neighborPlaced.name === 'Dam') damCount++;
                        if (neighborPlaced.name === 'Canal') canalCount++;
                    } else if (neighborPlaced.type === 'wonder') {
                        wonderCount++;
                    } else if (neighborPlaced.type === 'improvement') {
                        improvementCounts[neighborPlaced.name] = (improvementCounts[neighborPlaced.name] || 0) + 1;
                    }
                }
            });
            
            // Apply terrain/feature bonuses from neighbors
            if (bonuses.Mountain && mountainCount > 0) {
                const bonus = bonuses.Mountain;
                const amount = mountainCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
            }
            
            if (bonuses.Rainforest && rainforestCount > 0) {
                const bonus = bonuses.Rainforest;
                const amount = Math.floor(rainforestCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Geothermal_Fissure && geothermalFissureCount > 0) {
                const bonus = bonuses.Geothermal_Fissure;
                const amount = geothermalFissureCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Reef && reefCount > 0) {
                const bonus = bonuses.Reef;
                const amount = reefCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Coastal_Resources && coastalResourceCount > 0) {
                const bonus = bonuses.Coastal_Resources;
                const amount = coastalResourceCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            // Apply bonuses (same logic as calculateAdjacency)
            if (bonuses.all_districts && districtCount > 0) {
                const bonus = bonuses.all_districts;
                const amount = Math.floor(districtCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.City_Center && cityCenterCount > 0) {
                const bonus = bonuses.City_Center;
                const amount = cityCenterCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Harbor && harborCount > 0) {
                const bonus = bonuses.Harbor;
                const amount = harborCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Commercial_Hub && commercialHubCount > 0) {
                const bonus = bonuses.Commercial_Hub;
                const amount = commercialHubCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Government_Plaza && governmentPlazaCount > 0) {
                const bonus = bonuses.Government_Plaza;
                const amount = governmentPlazaCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Wonder && wonderCount > 0) {
                const bonus = bonuses.Wonder;
                const amount = wonderCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Entertainment_Complex && entertainmentComplexCount > 0) {
                const bonus = bonuses.Entertainment_Complex;
                const amount = entertainmentComplexCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Water_Park && waterParkCount > 0) {
                const bonus = bonuses.Water_Park;
                const amount = waterParkCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Mine && improvementCounts.Mine) {
                const bonus = bonuses.Mine;
                const amount = Math.floor(improvementCounts.Mine / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Lumber_Mill && improvementCounts.Lumber_Mill) {
                const bonus = bonuses.Lumber_Mill;
                const amount = Math.floor(improvementCounts.Lumber_Mill / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Quarry && improvementCounts.Quarry) {
                const bonus = bonuses.Quarry;
                const amount = improvementCounts.Quarry * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Aqueduct && aqueductCount > 0) {
                const bonus = bonuses.Aqueduct;
                const amount = aqueductCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Dam && damCount > 0) {
                const bonus = bonuses.Dam;
                const amount = damCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Canal && canalCount > 0) {
                const bonus = bonuses.Canal;
                const amount = canalCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            let strategicResourceCount = 0;
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborTile = challengeData.tiles[neighborKey];
                if (neighborTile && neighborTile.resource) {
                    const resourceInfo = resourcesData.strategic_resources.find(r => r.name === neighborTile.resource);
                    if (resourceInfo) {
                        strategicResourceCount++;
                    }
                }
            });
            
            if (bonuses.Strategic_Resource && strategicResourceCount > 0) {
                const bonus = bonuses.Strategic_Resource;
                const amount = strategicResourceCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            return {
                science,
                faith,
                gold,
                production,
                culture,
                total: science + faith + gold + production + culture
            };
        }

        function getHexDistance(row1, col1, row2, col2) {
            // Convert offset coordinates to cube coordinates for distance calculation
            // Using odd-r offset system
            const q1 = col1 - (row1 - (row1 & 1)) / 2;
            const r1 = row1;
            const s1 = -q1 - r1;
            
            const q2 = col2 - (row2 - (row2 & 1)) / 2;
            const r2 = row2;
            const s2 = -q2 - r2;
            
            // Hex distance formula
            return (Math.abs(q1 - q2) + Math.abs(r1 - r2) + Math.abs(s1 - s2)) / 2;
        }

        function getNeighbors(row, col) {
            const neighbors = [];
            const isOddRow = row % 2 === 1;
            
            // For flat-top hexagons:
            // Even rows: neighbors are at same col, col-1, col+1
            // Odd rows: neighbors are at same col, col+1, col+1
            
            // Right neighbor
            if (col < GRID_WIDTH - 1) {
                neighbors.push({ row, col: col + 1 });
            }
            
            // Left neighbor
            if (col > 0) {
                neighbors.push({ row, col: col - 1 });
            }
            
            // Top and bottom neighbors depend on row parity
            if (isOddRow) {
                // Odd row: top neighbors are at row-1, same col and col+1
                if (row > 0) {
                    neighbors.push({ row: row - 1, col });
                    if (col < GRID_WIDTH - 1) {
                        neighbors.push({ row: row - 1, col: col + 1 });
                    }
                }
                // Odd row: bottom neighbors are at row+1, same col and col+1
                if (row < GRID_HEIGHT - 1) {
                    neighbors.push({ row: row + 1, col });
                    if (col < GRID_WIDTH - 1) {
                        neighbors.push({ row: row + 1, col: col + 1 });
                    }
                }
            } else {
                // Even row: top neighbors are at row-1, same col and col-1
                if (row > 0) {
                    neighbors.push({ row: row - 1, col });
                    if (col > 0) {
                        neighbors.push({ row: row - 1, col: col - 1 });
                    }
                }
                // Even row: bottom neighbors are at row+1, same col and col-1
                if (row < GRID_HEIGHT - 1) {
                    neighbors.push({ row: row + 1, col });
                    if (col > 0) {
                        neighbors.push({ row: row + 1, col: col - 1 });
                    }
                }
            }
            
            return neighbors;
        }

        function calculateAdjacency(row, col) {
            const key = `${row},${col}`;
            const placed = placedItems[key];
            if (!placed || placed.type !== 'district') return null;
            
            const districtName = placed.name;
            const districtBonus = adjacencyData.district_adjacency_bonuses.find(d => d.name === districtName);
            if (!districtBonus) return null;
            
            const tile = challengeData.tiles[key];
            const neighbors = getNeighbors(row, col);
            
            let science = 0;
            let faith = 0;
            let gold = 0;
            let production = 0;
            let culture = 0;
            
            const bonuses = districtBonus.adjacency_bonuses;
            
            // Check for river edges on this tile (River_Edge is about the tile itself having a river)
            if (tile && tile.rivers) {
                let hasRiver = false;
                for (let i = 0; i < 6; i++) {
                    if (tile.rivers[i]) {
                        hasRiver = true;
                        break;
                    }
                }
                if (hasRiver && bonuses.River_Edge) {
                    const bonus = bonuses.River_Edge;
                    if (bonus.type === 'Gold') gold += bonus.bonus;
                }
            }
            
            // Check neighbors for terrain, features, and resources
            let districtCount = 0;
            let cityCenterCount = 0;
            let harborCount = 0;
            let commercialHubCount = 0;
            let wonderCount = 0;
            let entertainmentComplexCount = 0;
            let waterParkCount = 0;
            let governmentPlazaCount = 0;
            let aqueductCount = 0;
            let damCount = 0;
            let canalCount = 0;
            let improvementCounts = {};
            let mountainCount = 0;
            let rainforestCount = 0;
            let geothermalFissureCount = 0;
            let reefCount = 0;
            let coastalResourceCount = 0;
            
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborPlaced = placedItems[neighborKey];
                const neighborTile = challengeData.tiles[neighborKey];
                
                // Check neighbor terrain/features for adjacency bonuses
                if (neighborTile) {
                    // Check for mountains
                    if (neighborTile.terrain && neighborTile.terrain.includes('Mountain')) {
                        mountainCount++;
                    }
                    // Check for features
                    if (neighborTile.feature === 'Rainforest') {
                        rainforestCount++;
                    }
                    if (neighborTile.feature === 'Geothermal_Fissure') {
                        geothermalFissureCount++;
                    }
                    // Check for reef
                    if (neighborTile.terrain === 'Reef') {
                        reefCount++;
                    }
                    // Check for coastal resources (resources on coast/ocean/reef tiles)
                    if (neighborTile.resource && (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                        coastalResourceCount++;
                    }
                }
                
                if (neighborPlaced) {
                    if (neighborPlaced.type === 'district') {
                        districtCount++;
                        if (neighborPlaced.name === 'City_Center') cityCenterCount++;
                        if (neighborPlaced.name === 'Harbor') harborCount++;
                        if (neighborPlaced.name === 'Commercial_Hub') commercialHubCount++;
                        if (neighborPlaced.name === 'Government_Plaza') governmentPlazaCount++;
                        if (neighborPlaced.name === 'Entertainment_Complex') entertainmentComplexCount++;
                        if (neighborPlaced.name === 'Water_Park') waterParkCount++;
                        if (neighborPlaced.name === 'Aqueduct') aqueductCount++;
                        if (neighborPlaced.name === 'Dam') damCount++;
                        if (neighborPlaced.name === 'Canal') canalCount++;
                    } else if (neighborPlaced.type === 'wonder') {
                        wonderCount++;
                    } else if (neighborPlaced.type === 'improvement') {
                        improvementCounts[neighborPlaced.name] = (improvementCounts[neighborPlaced.name] || 0) + 1;
                    }
                }
            });
            
            // Apply terrain/feature bonuses from neighbors
            if (bonuses.Mountain && mountainCount > 0) {
                const bonus = bonuses.Mountain;
                const amount = mountainCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
            }
            
            if (bonuses.Rainforest && rainforestCount > 0) {
                const bonus = bonuses.Rainforest;
                const amount = Math.floor(rainforestCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Geothermal_Fissure && geothermalFissureCount > 0) {
                const bonus = bonuses.Geothermal_Fissure;
                const amount = geothermalFissureCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Reef && reefCount > 0) {
                const bonus = bonuses.Reef;
                const amount = reefCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
            }
            
            if (bonuses.Coastal_Resources && coastalResourceCount > 0) {
                const bonus = bonuses.Coastal_Resources;
                const amount = coastalResourceCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            // Apply bonuses
            if (bonuses.all_districts && districtCount > 0) {
                const bonus = bonuses.all_districts;
                const amount = Math.floor(districtCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.City_Center && cityCenterCount > 0) {
                const bonus = bonuses.City_Center;
                const amount = cityCenterCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Harbor && harborCount > 0) {
                const bonus = bonuses.Harbor;
                const amount = harborCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Commercial_Hub && commercialHubCount > 0) {
                const bonus = bonuses.Commercial_Hub;
                const amount = commercialHubCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Government_Plaza && governmentPlazaCount > 0) {
                const bonus = bonuses.Government_Plaza;
                const amount = governmentPlazaCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Wonder && wonderCount > 0) {
                const bonus = bonuses.Wonder;
                const amount = wonderCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Entertainment_Complex && entertainmentComplexCount > 0) {
                const bonus = bonuses.Entertainment_Complex;
                const amount = entertainmentComplexCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Water_Park && waterParkCount > 0) {
                const bonus = bonuses.Water_Park;
                const amount = waterParkCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            // Check improvements
            if (bonuses.Mine && improvementCounts.Mine) {
                const bonus = bonuses.Mine;
                const amount = Math.floor(improvementCounts.Mine / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Lumber_Mill && improvementCounts.Lumber_Mill) {
                const bonus = bonuses.Lumber_Mill;
                const amount = Math.floor(improvementCounts.Lumber_Mill / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Quarry && improvementCounts.Quarry) {
                const bonus = bonuses.Quarry;
                const amount = improvementCounts.Quarry * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Aqueduct && aqueductCount > 0) {
                const bonus = bonuses.Aqueduct;
                const amount = aqueductCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Dam && damCount > 0) {
                const bonus = bonuses.Dam;
                const amount = damCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Canal && canalCount > 0) {
                const bonus = bonuses.Canal;
                const amount = canalCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            // Check for strategic resources
            let strategicResourceCount = 0;
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborTile = challengeData.tiles[neighborKey];
                if (neighborTile && neighborTile.resource) {
                    const resourceInfo = resourcesData.strategic_resources.find(r => r.name === neighborTile.resource);
                    if (resourceInfo) {
                        strategicResourceCount++;
                    }
                }
            });
            
            if (bonuses.Strategic_Resource && strategicResourceCount > 0) {
                const bonus = bonuses.Strategic_Resource;
                const amount = strategicResourceCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            return {
                science,
                faith,
                gold,
                production,
                culture,
                total: science + faith + gold + production + culture
            };
        }

        function updateAllScores() {
            let totalScience = 0;
            let totalFaith = 0;
            let totalGold = 0;
            let totalProduction = 0;
            let totalCulture = 0;
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const adjacency = calculateAdjacency(row, col);
                    if (adjacency) {
                        totalScience += adjacency.science;
                        totalFaith += adjacency.faith;
                        totalGold += adjacency.gold;
                        totalProduction += adjacency.production;
                        totalCulture += adjacency.culture;
                    }
                }
            }
            
            const scorePanel = document.getElementById('scorePanel');
            if (scorePanel) {
                scorePanel.innerHTML = `
                    <h3>Adjacency Bonuses</h3>
                    <div class="score-item">
                        <span>Science:</span>
                        <span>${totalScience}</span>
                    </div>
                    <div class="score-item">
                        <span>Faith:</span>
                        <span>${totalFaith}</span>
                    </div>
                    <div class="score-item">
                        <span>Gold:</span>
                        <span>${totalGold}</span>
                    </div>
                    <div class="score-item">
                        <span>Production:</span>
                        <span>${totalProduction}</span>
                    </div>
                    <div class="score-item">
                        <span>Culture:</span>
                        <span>${totalCulture}</span>
                    </div>
                    <div class="score-total">
                        <div class="score-item">
                            <span>Total Score:</span>
                            <span>${totalScience + totalFaith + totalGold + totalProduction + totalCulture}</span>
                        </div>
                    </div>
                `;
            }
        }

        function initMapZoomPan() {
            const mapContainer = document.getElementById('mapContainer');
            const mapTransformWrapper = document.getElementById('mapTransformWrapper');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const resetZoomBtn = document.getElementById('resetZoomBtn');

            function updateTransform() {
                mapTransformWrapper.style.transform = `translate(${mapPanX}px, ${mapPanY}px) scale(${mapZoom})`;
            }

            zoomInBtn.onclick = (e) => {
                e.stopPropagation();
                mapZoom = Math.min(mapZoom * 1.2, 3.0);
                updateTransform();
            };

            zoomOutBtn.onclick = (e) => {
                e.stopPropagation();
                mapZoom = Math.max(mapZoom / 1.2, 0.5);
                updateTransform();
            };

            resetZoomBtn.onclick = (e) => {
                e.stopPropagation();
                mapZoom = 1.0;
                mapPanX = 0;
                mapPanY = 0;
                updateTransform();
            };

            mapContainer.addEventListener('wheel', (e) => {
                if (!e.ctrlKey && !e.shiftKey && !e.altKey) {
                    e.preventDefault();
                    const rect = mapContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const containerCenterX = rect.width / 2;
                    const containerCenterY = rect.height / 2;
                    
                    const deltaX = mouseX - containerCenterX;
                    const deltaY = mouseY - containerCenterY;
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.5, Math.min(3.0, mapZoom * zoomFactor));
                    
                    const zoomChange = newZoom / mapZoom;
                    mapPanX = mapPanX * zoomChange + (deltaX * (1 - zoomChange));
                    mapPanY = mapPanY * zoomChange + (deltaY * (1 - zoomChange));
                    mapZoom = newZoom;
                    
                    updateTransform();
                }
            }, { passive: false });

            mapContainer.addEventListener('mousedown', (e) => {
                const isHexClick = e.target.closest('.hex');
                const isButtonClick = e.target.closest('button');
                const isScorePanel = e.target.closest('.score-panel');
                const isDistrict = e.target.closest('.hex-district');
                
                // Don't start map panning if clicking on a district
                if (e.button === 0 && !isHexClick && !isButtonClick && !isScorePanel && !isDistrict) {
                    if (e.target === mapContainer || e.target === mapTransformWrapper || e.target.id === 'hexGrid') {
                        isDragging = true;
                        mapContainer.classList.add('dragging');
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        dragStartPanX = mapPanX;
                        dragStartPanY = mapPanY;
                        e.preventDefault();
                    }
                }
            });

            mapContainer.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    mapPanX = dragStartPanX + deltaX;
                    mapPanY = dragStartPanY + deltaY;
                    updateTransform();
                }
            });

            mapContainer.addEventListener('mouseup', (e) => {
                if (isDragging && e.button === 0) {
                    isDragging = false;
                    mapContainer.classList.remove('dragging');
                }
            });

            mapContainer.addEventListener('mouseleave', () => {
                if (isDragging) {
                    isDragging = false;
                    mapContainer.classList.remove('dragging');
                }
            });

            // Allow dropping districts and improvements in the void to delete them
            mapContainer.addEventListener('dragover', (e) => {
                if (draggedDistrict || draggedImprovement) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                }
            });

            mapContainer.addEventListener('drop', (e) => {
                if (draggedDistrict) {
                    e.preventDefault();
                    // Delete the district by removing it
                    removeItem(draggedDistrict.row, draggedDistrict.col);
                    draggedDistrict = null;
                } else if (draggedImprovement) {
                    e.preventDefault();
                    // Delete the improvement by removing it
                    removeItem(draggedImprovement.row, draggedImprovement.col);
                    draggedImprovement = null;
                }
            });

            updateTransform();
        }

        // Initialize on load
        loadGameData();
    </script>
</body>
</html>


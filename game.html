<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Civle Game</title>
    <style>
        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-Medium.ttf') format('truetype');
            font-weight: 500;
            font-style: normal;
        }

        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-Bold.ttf') format('truetype');
            font-weight: 700;
            font-style: normal;
        }

        @font-face {
            font-family: 'Montserrat';
            src: url('assets/font/Montserrat-ExtraBold.ttf') format('truetype');
            font-weight: 800;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: #2d2d2d;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #444;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-logo {
            width: 48px;
            height: 48px;
            object-fit: contain;
        }

        .header h1 {
            font-size: 24px;
            margin: 0;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            padding: 8px 16px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #357abd;
        }

        button:active {
            background: #2968a3;
        }

        .file-label {
            display: inline-block;
            padding: 8px 16px;
            background: #4a90e2;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .file-label:hover {
            background: #357abd;
        }

        input[type="file"] {
            display: none;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background: #2d2d2d;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #444;
        }

        .sidebar::-webkit-scrollbar {
            width: 10px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #4a4a4a;
            border-radius: 5px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #5a5a5a;
        }

        .sidebar h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #4a90e2;
        }

        .available-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            margin: 5px 0;
            background: #3a3a3a;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: grab;
            user-select: none;
        }

        .available-item:active {
            cursor: grabbing;
        }

        .available-item.dragging {
            opacity: 0.5;
        }

        .available-item img {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .available-item .count {
            margin-left: auto;
            font-weight: bold;
            color: #4a90e2;
        }

        .available-item .count.zero {
            color: #888;
        }

        .map-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
            position: relative;
        }

        .map-transform-wrapper {
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            will-change: transform;
        }

        .map-container.dragging .map-transform-wrapper {
            transition: none;
        }

        .hex-grid {
            display: grid;
            gap: 0;
            line-height: 0;
        }

        .hex-row {
            display: flex;
            gap: 0;
            margin-bottom: -26px;
        }

        .hex-row.offset {
            margin-left: 36px;
        }

        .hex {
            width: 80px;
            height: 92.376px;
            position: relative;
            cursor: pointer;
            margin: 0;
            margin-right: -8px;
        }

        .hex.valid-placement::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background-color: rgba(144, 238, 144, 0.5);
            z-index: 12;
            pointer-events: none;
        }

        .hex.invalid-placement::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background-color: rgba(255, 182, 193, 0.5);
            z-index: 12;
            pointer-events: none;
        }

        .hex-shape {
            width: 100%;
            height: 100%;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background: transparent;
            border: none;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 15;
        }

        .hex-base {
            width: 100%;
            height: 100%;
            object-fit: cover;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .hex-feature {
            width: 70%;
            height: 70%;
            object-fit: contain;
            position: absolute;
            top: 15%;
            left: 15%;
            z-index: 2;
        }

        .hex-resource {
            height: 40px;
            object-fit: contain;
            position: absolute;
            bottom: 8px;
            right: 20px;
            z-index: 3;
            filter: drop-shadow(0 0 3px rgba(0,0,0,0.8));
        }

        .hex-district {
            width: 90%;
            height: 90%;
            object-fit: cover;
            position: absolute;
            top: 5%;
            left: calc(5% - 1px);
            z-index: 25000000;
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.9));
        }

        .hex-improvement {
            width: 50%;
            height: 50%;
            object-fit: contain;
            position: absolute;
            bottom: 15%;
            left: 15%;
            z-index: 5;
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.9));
        }

        .hex-wonder {
            width: 80%;
            height: 80%;
            object-fit: contain;
            position: absolute;
            top: 10%;
            left: 10%;
            z-index: 6;
            filter: drop-shadow(0 0 8px rgba(255,215,0,0.8));
        }

        .hex-rivers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            overflow: visible;
        }

        .river-edge-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
            z-index: 11;
        }

        .adjacency-indicator {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.8);
            color: #4a90e2;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            z-index: 20;
            pointer-events: none;
        }

        .score-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #2d2d2d;
            border: 2px solid #555;
            border-radius: 8px;
            padding: 15px;
            min-width: 200px;
            z-index: 1001;
        }

        .score-panel h3 {
            margin-bottom: 10px;
            color: #4a90e2;
            font-size: 16px;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 14px;
        }

        .score-total {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 2px solid #555;
            font-weight: bold;
            font-size: 16px;
            color: #4a90e2;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1001;
        }

        .zoom-controls button {
            width: 40px;
            height: 40px;
            padding: 0;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #2d2d2d;
            border: 2px solid #555;
        }

        .zoom-controls button:hover {
            background: #3a3a3a;
            border-color: #4a90e2;
        }

        .hex-row:last-child {
            margin-bottom: 0;
        }

        .empty-state {
            text-align: center;
            color: #888;
            padding: 40px;
        }

        .empty-state h2 {
            margin-bottom: 20px;
            color: #4a90e2;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <img src="assets/logo/Logo128x128.png" alt="Civle Logo" class="header-logo">
            <h1>Civle Game</h1>
        </div>
        <div class="controls">
            <label for="loadChallenge" class="file-label">Load Challenge</label>
            <input type="file" id="loadChallenge" accept=".civle,.json" onchange="loadChallenge(event)">
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div class="empty-state">
                <h2>Load a Challenge</h2>
                <p>Upload a .civle challenge file to begin playing</p>
            </div>
        </div>

        <div class="map-container" id="mapContainer">
            <div class="empty-state">
                <h2>No Challenge Loaded</h2>
                <p>Load a challenge file to see the map</p>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let challengeData = null;
        let GRID_WIDTH = 0;
        let GRID_HEIGHT = 0;
        let placedItems = {}; // { "row,col": { type: "district"|"improvement"|"wonder", name: "..." } }
        let availableItems = {}; // { "District_Name": count, "Improvement_Name": count }
        let adjacencyData = null;
        let placementData = null;
        let resourcesData = null;

        // Zoom and pan state
        let mapZoom = 1.0;
        let mapPanX = 0;
        let mapPanY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartPanX = 0;
        let dragStartPanY = 0;
        let draggedItem = null;

        // Load game data (embedded directly, no fetch needed)
        function loadGameData() {
            // Adjacency data is embedded below
            adjacencyData = embeddedAdjacencyData;
            
            // Placement data is embedded below  
            placementData = embeddedPlacementData;
            
            // Resources data is embedded below
            resourcesData = embeddedResourcesData;
        }

        // Base36 encoding/decoding (same as map maker)
        function toBase36(num) {
            if (num === 0) return '0';
            let result = '';
            while (num > 0) {
                result = (num % 36).toString(36) + result;
                num = Math.floor(num / 36);
            }
            return result;
        }

        function fromBase36(str) {
            return parseInt(str, 36);
        }

        // Terrain, features, and resources data (same as map maker)
        const terrainBases = [
            { name: 'Desert', path: 'assets/terrain/base/flat/Desert.webp' },
            { name: 'Grassland', path: 'assets/terrain/base/flat/Grassland.webp' },
            { name: 'Plains', path: 'assets/terrain/base/flat/Plains.webp' },
            { name: 'Snow', path: 'assets/terrain/base/flat/Snow.webp' },
            { name: 'Tundra', path: 'assets/terrain/base/flat/Tundra.webp' },
            { name: 'Desert_Hill', path: 'assets/terrain/base/hills/Desert_Hill.webp' },
            { name: 'Grassland_Hill', path: 'assets/terrain/base/hills/Grassland_Hill.webp' },
            { name: 'Plains_Hill', path: 'assets/terrain/base/hills/Plains_Hill.webp' },
            { name: 'Snow_Hill', path: 'assets/terrain/base/hills/Snow_Hill.webp' },
            { name: 'Tundra_Hills', path: 'assets/terrain/base/hills/Tundra_Hills.webp' },
            { name: 'Desert_Floodplains', path: 'assets/terrain/base/floodplains/Desert_Floodplains.webp' },
            { name: 'Grassland_Floodplains', path: 'assets/terrain/base/floodplains/Grassland_Floodplains.webp' },
            { name: 'Plains_Floodplains', path: 'assets/terrain/base/floodplains/Plains_Floodplains.webp' },
            { name: 'Mountain_Desert', path: 'assets/terrain/base/mountain/Mountain_Desert.webp' },
            { name: 'Mountain_Plains', path: 'assets/terrain/base/mountain/Mountain_Plains.webp' },
            { name: 'Mountain_Snow', path: 'assets/terrain/base/mountain/Mountain_Snow.webp' },
            { name: 'Mountain_Tundra', path: 'assets/terrain/base/mountain/Mountain_Tundra.webp' },
            { name: 'Mountains_Grassland', path: 'assets/terrain/base/mountain/Mountains_Grassland.webp' },
            { name: 'Coast', path: 'assets/terrain/base/water/Coast.webp' },
            { name: 'Ocean', path: 'assets/terrain/base/water/Ocean.webp' },
            { name: 'Reef', path: 'assets/terrain/base/water/Reef.webp' }
        ];

        const features = [
            { name: 'Woods', path: 'assets/terrain/features/Woods.webp' },
            { name: 'Rainforest', path: 'assets/terrain/features/Rainforest.webp' },
            { name: 'Marsh', path: 'assets/terrain/features/Marsh.webp' },
            { name: 'Geothermal_Fissure', path: 'assets/terrain/features/Geothermal_Fissure.webp' }
        ];

        const resources = [
            'Aluminum', 'Amber', 'Bananas', 'Cattle', 'Citrus', 'Coal', 'Cocoa', 'Coffee',
            'Copper', 'Cotton', 'Crabs', 'Deer', 'Diamonds', 'Dyes', 'Fish', 'Furs',
            'Gypsum', 'Honey', 'Horses', 'Incense', 'Ivory', 'Jade', 'Maize', 'Marble',
            'Mercury', 'Niter', 'Oil', 'Olives', 'Pearls', 'Rice', 'Salt', 'Sheep',
            'Silk', 'Silver', 'Spices', 'Stone', 'Sugar', 'Tea', 'Tobacco', 'Truffles',
            'Turtles', 'Uranium', 'Whales', 'Wheat', 'Wine'
        ];

        // Create lookup maps
        const terrainIndexMap = new Map();
        terrainBases.forEach((t, i) => terrainIndexMap.set(t.name, i));
        const terrainNameMap = new Map();
        terrainBases.forEach((t, i) => terrainNameMap.set(i, t));

        const featureIndexMap = new Map();
        features.forEach((f, i) => featureIndexMap.set(f.name, i));
        const featureNameMap = new Map();
        features.forEach((f, i) => featureNameMap.set(i, f));

        const resourceIndexMap = new Map();
        resources.forEach((r, i) => resourceIndexMap.set(r, i));
        const resourceNameMap = new Map();
        resources.forEach((r, i) => resourceNameMap.set(i, r));

        // River edge images
        const riverEdgeImages = {
            0: 'Top_Right',
            1: 'Right',
            2: 'Bottom_Right',
            3: 'Bottom_Left',
            4: 'Left',
            5: 'Top_Left'
        };

        function loadChallenge(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = e.target.result;
                    
                    if (data.startsWith('CIV1')) {
                        // New optimized format
                        const width = data.charCodeAt(4) - 48;
                        const height = data.charCodeAt(5) - 48;
                        
                        GRID_WIDTH = width;
                        GRID_HEIGHT = height;
                        
                        challengeData = {
                            width: width,
                            height: height,
                            tiles: {},
                            allocations: {
                                districts: {},
                                improvements: {},
                                wonders: {}
                            }
                        };
                        
                        const tilesData = data.substring(7);
                        const parts = tilesData.split('||');
                        const tilesStr = parts[0];
                        
                        if (tilesStr) {
                            const tiles = tilesStr.split('|');
                            tiles.forEach(tileStr => {
                                if (!tileStr) return;
                                const [pos, data] = tileStr.split(':');
                                if (!pos || !data) return;
                                
                                const [rowStr, colStr] = pos.split(',');
                                const row = parseInt(rowStr);
                                const col = parseInt(colStr);
                                
                                const dataParts = data.split(';');
                                let mainData = dataParts[0];
                                
                                let tStr = '';
                                let fStr = '';
                                let rStr = '';
                                
                                if (mainData.includes(',') && mainData.split(',').length >= 3) {
                                    const fields = mainData.split(',');
                                    tStr = fields[0] || '.';
                                    fStr = fields[1] || '.';
                                    rStr = fields[2] || '.';
                                } else {
                                    tStr = mainData[0] || '.';
                                    fStr = mainData[1] || '.';
                                    rStr = mainData[2] || '.';
                                }
                                
                                const key = `${row},${col}`;
                                challengeData.tiles[key] = {};
                                
                                if (tStr && tStr !== '.') {
                                    const tIdx = fromBase36(tStr) - 1;
                                    const terrain = terrainNameMap.get(tIdx);
                                    if (terrain) {
                                        challengeData.tiles[key].terrain = terrain.name;
                                        challengeData.tiles[key].terrainPath = terrain.path;
                                    }
                                }
                                
                                if (fStr && fStr !== '.') {
                                    const fIdx = fromBase36(fStr) - 1;
                                    const feature = featureNameMap.get(fIdx);
                                    if (feature) {
                                        challengeData.tiles[key].feature = feature.name;
                                        challengeData.tiles[key].featurePath = feature.path;
                                    }
                                }
                                
                                if (rStr && rStr !== '.') {
                                    const rIdx = fromBase36(rStr) - 1;
                                    const resource = resourceNameMap.get(rIdx);
                                    if (resource) {
                                        challengeData.tiles[key].resource = resource;
                                        challengeData.tiles[key].resourcePath = `assets/recources/${resource}.webp`;
                                    }
                                }
                                
                                if (dataParts.length > 1 && dataParts[1]) {
                                    const riversBin = parseInt(dataParts[1], 36).toString(2).padStart(6, '0');
                                    challengeData.tiles[key].rivers = [];
                                    for (let i = 0; i < 6; i++) {
                                        challengeData.tiles[key].rivers[i] = riversBin[i] === '1';
                                    }
                                }
                            });
                        }
                        
                        // Load allocations
                        const allocationsStr = parts.length > 1 ? parts[1] : null;
                        if (allocationsStr) {
                            const allocations = allocationsStr.split(',');
                            allocations.forEach(allocStr => {
                                if (!allocStr) return;
                                const parts = allocStr.split(':');
                                const type = parts[0];
                                const name = parts[1];
                                
                                if (type === 'd') {
                                    if (parts[2] === 'c') {
                                        challengeData.allocations.districts[name] = true;
                                    } else {
                                        challengeData.allocations.districts[name] = parseInt(parts[2]) || 0;
                                    }
                                } else if (type === 'i') {
                                    challengeData.allocations.improvements[name] = parseInt(parts[2]) || 0;
                                } else if (type === 'w') {
                                    challengeData.allocations.wonders[name] = true;
                                }
                            });
                        }
                    } else {
                        // Old JSON format
                        const loadedData = JSON.parse(data);
                        challengeData = loadedData;
                        GRID_WIDTH = loadedData.width;
                        GRID_HEIGHT = loadedData.height;
                    }
                    
                    // Initialize game
                    placedItems = {};
                    availableItems = {};
                    
                    // Copy allocations to available items
                    Object.keys(challengeData.allocations.districts).forEach(name => {
                        const count = challengeData.allocations.districts[name];
                        if (count === true) {
                            availableItems[name] = 1;
                        } else if (count > 0) {
                            availableItems[name] = count;
                        }
                    });
                    
                    Object.keys(challengeData.allocations.improvements).forEach(name => {
                        const count = challengeData.allocations.improvements[name];
                        if (count > 0) {
                            availableItems[name] = count;
                        }
                    });
                    
                    Object.keys(challengeData.allocations.wonders).forEach(name => {
                        if (challengeData.allocations.wonders[name]) {
                            availableItems[name] = 1;
                        }
                    });
                    
                    initializeGame();
                } catch (error) {
                    console.error('Error loading challenge:', error);
                    alert('Failed to load challenge file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function initializeGame() {
            createHexGrid();
            populateSidebar();
            initMapZoomPan();
            updateAllScores();
        }

        function createHexGrid() {
            const mapContainer = document.getElementById('mapContainer');
            mapContainer.innerHTML = '';
            
            const mapTransformWrapper = document.createElement('div');
            mapTransformWrapper.className = 'map-transform-wrapper';
            mapTransformWrapper.id = 'mapTransformWrapper';
            
            const grid = document.createElement('div');
            grid.className = 'hex-grid';
            grid.id = 'hexGrid';
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                const hexRow = document.createElement('div');
                hexRow.className = 'hex-row';
                if (row % 2 === 1) {
                    hexRow.classList.add('offset');
                }

                for (let col = 0; col < GRID_WIDTH; col++) {
                    const hex = createHex(row, col);
                    hexRow.appendChild(hex);
                }

                grid.appendChild(hexRow);
            }
            
            mapTransformWrapper.appendChild(grid);
            
            // Create a separate districts layer on top of everything
            const districtsLayer = document.createElement('div');
            districtsLayer.className = 'hex-grid';
            districtsLayer.id = 'districtsLayer';
            districtsLayer.style.position = 'absolute';
            districtsLayer.style.top = '0';
            districtsLayer.style.left = '0';
            districtsLayer.style.pointerEvents = 'none';
            districtsLayer.style.zIndex = '1000';
            
            // Create districts grid structure
            for (let row = 0; row < GRID_HEIGHT; row++) {
                const hexRow = document.createElement('div');
                hexRow.className = 'hex-row';
                if (row % 2 === 1) {
                    hexRow.classList.add('offset');
                }

                for (let col = 0; col < GRID_WIDTH; col++) {
                    const districtHex = document.createElement('div');
                    districtHex.className = 'hex';
                    districtHex.dataset.row = row;
                    districtHex.dataset.col = col;
                    districtHex.style.pointerEvents = 'none';
                    
                    const districtShape = document.createElement('div');
                    districtShape.className = 'hex-shape';
                    districtShape.id = `district-shape-${row}-${col}`;
                    
                    districtHex.appendChild(districtShape);
                    hexRow.appendChild(districtHex);
                }
                
                districtsLayer.appendChild(hexRow);
            }
            
            mapTransformWrapper.appendChild(districtsLayer);
            mapTransformWrapper.style.position = 'relative';
            mapContainer.appendChild(mapTransformWrapper);
            
            // Update visuals for all hexes after they're in the DOM
            // First pass: render everything EXCEPT districts
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    updateHexVisualBase(row, col);
                }
            }
            // Second pass: render districts in separate layer
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    updateHexVisualDistricts(row, col);
                }
            }
            
            // Add score panel
            const scorePanel = document.createElement('div');
            scorePanel.className = 'score-panel';
            scorePanel.id = 'scorePanel';
            mapContainer.appendChild(scorePanel);
            
            // Add zoom controls
            const zoomControls = document.createElement('div');
            zoomControls.className = 'zoom-controls';
            zoomControls.innerHTML = `
                <button id="zoomInBtn" title="Zoom In">+</button>
                <button id="zoomOutBtn" title="Zoom Out">−</button>
                <button id="resetZoomBtn" title="Reset Zoom">⌂</button>
            `;
            mapContainer.appendChild(zoomControls);
        }

        function createHex(row, col) {
            const hex = document.createElement('div');
            hex.className = 'hex';
            hex.dataset.row = row;
            hex.dataset.col = col;

            const hexShape = document.createElement('div');
            hexShape.className = 'hex-shape';

            const riversContainer = document.createElement('div');
            riversContainer.className = 'hex-rivers';

            hex.appendChild(hexShape);
            hex.appendChild(riversContainer);

            // Drag and drop handlers
            hex.addEventListener('dragover', (e) => {
                e.preventDefault();
                
                // Update validity highlight
                if (draggedItem) {
                    const key = `${row},${col}`;
                    const tile = challengeData.tiles[key];
                    const isValid = isValidPlacement(row, col, draggedItem.type, draggedItem.name, tile) && 
                                   (availableItems[draggedItem.name] > 0 || placedItems[key]?.name === draggedItem.name);
                    
                    hex.classList.remove('valid-placement', 'invalid-placement');
                    if (isValid) {
                        hex.classList.add('valid-placement');
                    } else {
                        hex.classList.add('invalid-placement');
                    }
                }
            });

            hex.addEventListener('dragleave', () => {
                hex.classList.remove('valid-placement', 'invalid-placement');
            });

            hex.addEventListener('drop', (e) => {
                e.preventDefault();
                hex.classList.remove('valid-placement', 'invalid-placement');
                
                if (draggedItem) {
                    placeItem(row, col, draggedItem.type, draggedItem.name);
                    draggedItem = null;
                }
            });

            // Right-click to remove item
            hex.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                removeItem(row, col);
            });

            return hex;
        }

        function updateHexVisualBase(row, col) {
            const hexGrid = document.getElementById('hexGrid');
            if (!hexGrid) return;
            const hex = hexGrid.querySelector(`.hex[data-row="${row}"][data-col="${col}"]`);
            if (!hex) return;

            const hexShape = hex.querySelector('.hex-shape');
            if (!hexShape) return;

            // Remove existing images
            hexShape.querySelectorAll('img').forEach(el => el.remove());
            hexShape.querySelectorAll('.adjacency-indicator').forEach(el => el.remove());

            const key = `${row},${col}`;
            const tile = challengeData.tiles[key];
            const placed = placedItems[key];

            // Always add Blank.webp as base
            const blankImg = document.createElement('img');
            blankImg.className = 'hex-base';
            blankImg.src = 'assets/terrain/base/other/Blank.webp';
            blankImg.alt = 'Blank';
            hexShape.appendChild(blankImg);

            if (tile) {
                if (tile.terrainPath) {
                    blankImg.src = tile.terrainPath;
                    blankImg.alt = tile.terrain;
                }
                if (tile.featurePath) {
                    const img = document.createElement('img');
                    img.className = 'hex-feature';
                    img.src = tile.featurePath;
                    img.alt = tile.feature;
                    hexShape.appendChild(img);
                }
                if (tile.resourcePath) {
                    const img = document.createElement('img');
                    img.className = 'hex-resource';
                    img.src = tile.resourcePath;
                    img.alt = tile.resource;
                    hexShape.appendChild(img);
                }
                
                // Draw river edges
                if (tile.rivers) {
                    const riversContainer = hex.querySelector('.hex-rivers');
                    if (riversContainer) {
                        riversContainer.innerHTML = '';
                        for (let edge = 0; edge < 6; edge++) {
                            if (tile.rivers[edge] === true) {
                                const imageName = riverEdgeImages[edge];
                                if (imageName) {
                                    const img = document.createElement('img');
                                    img.className = 'river-edge-image';
                                    img.src = `assets/terrain/river_edges/${imageName}.png`;
                                    img.alt = `River edge ${edge}`;
                                    img.style.zIndex = (11 + edge);
                                    riversContainer.appendChild(img);
                                }
                            }
                        }
                    }
                }
            }

            // Add placed items (but NOT districts yet - they go last)
            if (placed) {
                if (placed.type === 'improvement') {
                    const img = document.createElement('img');
                    img.className = 'hex-improvement';
                    img.src = `assets/improvements/${placed.name}.webp`;
                    img.alt = placed.name;
                    hexShape.appendChild(img);
                } else if (placed.type === 'wonder') {
                    const img = document.createElement('img');
                    img.className = 'hex-wonder';
                    img.src = `assets/wonders/${placed.name}.webp`;
                    img.alt = placed.name;
                    hexShape.appendChild(img);
                }
            }
        }

        function updateHexVisualDistricts(row, col) {
            // Render districts in the separate districts layer
            const districtShape = document.getElementById(`district-shape-${row}-${col}`);
            if (!districtShape) return;

            // Clear existing content
            districtShape.innerHTML = '';

            const key = `${row},${col}`;
            const placed = placedItems[key];

            // Add districts LAST so they appear on top of everything
            if (placed && placed.type === 'district') {
                const img = document.createElement('img');
                img.className = 'hex-district';
                img.src = `assets/districts/${placed.name}.webp`;
                img.alt = placed.name;
                districtShape.appendChild(img);
                
                // Add adjacency indicator for districts
                const adjacency = calculateAdjacency(row, col);
                if (adjacency && adjacency.total > 0) {
                    const indicator = document.createElement('div');
                    indicator.className = 'adjacency-indicator';
                    indicator.textContent = `+${adjacency.total}`;
                    districtShape.appendChild(indicator);
                }
            }
        }

        function updateHexVisual(row, col) {
            updateHexVisualBase(row, col);
            updateHexVisualDistricts(row, col);
        }

        function populateSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.innerHTML = '';
            
            sidebar.innerHTML = '<h2>Available Items</h2>';
            
            // Districts
            const districtsSection = document.createElement('div');
            districtsSection.innerHTML = '<h3 style="margin-top: 15px; margin-bottom: 10px; color: #4a90e2; font-size: 16px;">Districts</h3>';
            
            Object.keys(availableItems).forEach(name => {
                const itemData = placementData.districts.find(d => d.name === name);
                if (itemData) {
                    const item = createAvailableItem(name, 'district', availableItems[name]);
                    districtsSection.appendChild(item);
                }
            });
            
            sidebar.appendChild(districtsSection);
            
            // Improvements
            const improvementsSection = document.createElement('div');
            improvementsSection.innerHTML = '<h3 style="margin-top: 15px; margin-bottom: 10px; color: #4a90e2; font-size: 16px;">Improvements</h3>';
            
            Object.keys(availableItems).forEach(name => {
                const itemData = placementData.improvements.find(i => i.name === name);
                if (itemData) {
                    const item = createAvailableItem(name, 'improvement', availableItems[name]);
                    improvementsSection.appendChild(item);
                }
            });
            
            sidebar.appendChild(improvementsSection);
            
            // Wonders
            const wondersSection = document.createElement('div');
            wondersSection.innerHTML = '<h3 style="margin-top: 15px; margin-bottom: 10px; color: #4a90e2; font-size: 16px;">Wonders</h3>';
            
            Object.keys(availableItems).forEach(name => {
                const itemData = placementData.wonders.find(w => w.name === name);
                if (itemData) {
                    const item = createAvailableItem(name, 'wonder', availableItems[name]);
                    wondersSection.appendChild(item);
                }
            });
            
            sidebar.appendChild(wondersSection);
        }

        function createAvailableItem(name, type, count) {
            const item = document.createElement('div');
            item.className = 'available-item';
            item.draggable = count > 0;
            item.dataset.name = name;
            item.dataset.type = type;
            
            if (count === 0) {
                item.style.opacity = '0.5';
                item.style.cursor = 'not-allowed';
            }
            
            let imgPath = '';
            if (type === 'district') {
                imgPath = `assets/districts/${name}.webp`;
            } else if (type === 'improvement') {
                imgPath = `assets/improvements/${name}.webp`;
            } else if (type === 'wonder') {
                imgPath = `assets/wonders/${name}.webp`;
            }
            
            const img = document.createElement('img');
            img.src = imgPath;
            img.alt = name;
            img.onerror = () => { img.style.display = 'none'; };
            
            const span = document.createElement('span');
            span.textContent = name.replace(/_/g, ' ');
            
            const countSpan = document.createElement('span');
            countSpan.className = 'count' + (count === 0 ? ' zero' : '');
            countSpan.textContent = `x${count}`;
            
            item.appendChild(img);
            item.appendChild(span);
            item.appendChild(countSpan);
            
            item.addEventListener('dragstart', (e) => {
                if (count > 0) {
                    draggedItem = { type, name };
                    item.classList.add('dragging');
                    updatePlacementHighlights();
                } else {
                    e.preventDefault();
                }
            });
            
            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                clearPlacementHighlights();
                draggedItem = null;
            });
            
            return item;
        }

        function placeItem(row, col, type, name) {
            const key = `${row},${col}`;
            const tile = challengeData.tiles[key];
            
            // Check if placement is valid
            if (!isValidPlacement(row, col, type, name, tile)) {
                return;
            }
            
            // Check if item is available
            if (availableItems[name] <= 0) {
                return;
            }
            
            // Remove any existing item at this location
            if (placedItems[key]) {
                const oldItem = placedItems[key];
                availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
            }
            
            // Place new item
            placedItems[key] = { type, name };
            availableItems[name] = (availableItems[name] || 0) - 1;
            
            // Update visuals for this hex and all neighbors (for adjacency indicators)
            updateHexVisual(row, col);
            const neighbors = getNeighbors(row, col);
            neighbors.forEach(neighbor => {
                updateHexVisual(neighbor.row, neighbor.col);
            });
            updateAllScores();
            populateSidebar();
        }

        function updatePlacementHighlights() {
            if (!draggedItem) return;
            
            const hexGrid = document.getElementById('hexGrid');
            if (!hexGrid) return;
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const hex = hexGrid.querySelector(`.hex[data-row="${row}"][data-col="${col}"]`);
                    if (!hex) continue;
                    
                    const key = `${row},${col}`;
                    const tile = challengeData.tiles[key];
                    const isValid = isValidPlacement(row, col, draggedItem.type, draggedItem.name, tile) && 
                                   (availableItems[draggedItem.name] > 0 || placedItems[key]?.name === draggedItem.name);
                    
                    hex.classList.remove('valid-placement', 'invalid-placement');
                    if (isValid) {
                        hex.classList.add('valid-placement');
                    } else {
                        hex.classList.add('invalid-placement');
                    }
                }
            }
        }

        function clearPlacementHighlights() {
            const hexGrid = document.getElementById('hexGrid');
            if (!hexGrid) return;
            
            const allHexes = hexGrid.querySelectorAll('.hex');
            allHexes.forEach(hex => {
                hex.classList.remove('valid-placement', 'invalid-placement');
            });
        }

        function removeItem(row, col) {
            const key = `${row},${col}`;
            if (!placedItems[key]) return;
            
            const oldItem = placedItems[key];
            delete placedItems[key];
            availableItems[oldItem.name] = (availableItems[oldItem.name] || 0) + 1;
            
            // Update visuals for this hex and all neighbors
            updateHexVisual(row, col);
            const neighbors = getNeighbors(row, col);
            neighbors.forEach(neighbor => {
                updateHexVisual(neighbor.row, neighbor.col);
            });
            updateAllScores();
            populateSidebar();
        }

        function isValidPlacement(row, col, type, name, tile) {
            if (!tile || !tile.terrain) return false;
            
            let itemData = null;
            if (type === 'district') {
                itemData = placementData.districts.find(d => d.name === name);
            } else if (type === 'improvement') {
                itemData = placementData.improvements.find(i => i.name === name);
            } else if (type === 'wonder') {
                itemData = placementData.wonders.find(w => w.name === name);
            }
            
            if (!itemData) return false;
            
            // Check terrain
            if (itemData.allowed_terrain && !itemData.allowed_terrain.includes(tile.terrain)) {
                return false;
            }
            
            // Check city center adjacency rules for districts
            if (type === 'district') {
                if (itemData.must_be_adjacent_to_city_center && !hasCityCenterAdjacent(row, col)) {
                    return false;
                }
                if (itemData.cant_be_adjacent_to_city_center && hasCityCenterAdjacent(row, col)) {
                    return false;
                }
            }
            
            // Check improvement requirements
            if (type === 'improvement') {
                // Check if must be on woods
                if (itemData.must_be_on_woods && tile.feature !== 'Woods') {
                    return false;
                }
                
                // Check if must be coastal
                if (itemData.must_be_coastal) {
                    const neighbors = getNeighbors(row, col);
                    let hasCoast = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        if (neighborTile && (neighborTile.terrain === 'Coast' || neighborTile.terrain === 'Ocean' || neighborTile.terrain === 'Reef')) {
                            hasCoast = true;
                            break;
                        }
                    }
                    if (!hasCoast) return false;
                }
                
                // Check resource requirements
                if (itemData.only_buildable_on_resources) {
                    if (!tile.resource || !itemData.resources_its_built_on.includes(tile.resource)) {
                        return false;
                    }
                } else if (itemData.resources_its_built_on && itemData.resources_its_built_on.length > 0) {
                    // Can be built on resource or without
                    if (tile.resource && !itemData.resources_its_built_on.includes(tile.resource)) {
                        return false;
                    }
                }
            }
            
            // Check wonder requirements
            if (type === 'wonder') {
                // Check allowed features
                if (itemData.allowed_features && itemData.allowed_features.length > 0) {
                    if (!tile.feature || !itemData.allowed_features.includes(tile.feature)) {
                        return false;
                    }
                }
                
                // Check required feature adjacency
                if (itemData.required_feature_adjacency && itemData.required_feature_adjacency.length > 0) {
                    const neighbors = getNeighbors(row, col);
                    let hasRequiredFeature = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        if (neighborTile && itemData.required_feature_adjacency.includes(neighborTile.feature)) {
                            hasRequiredFeature = true;
                            break;
                        }
                    }
                    if (!hasRequiredFeature) return false;
                }
                
                // Check required resource adjacency
                if (itemData.required_resource_adjacency && itemData.required_resource_adjacency.length > 0) {
                    const neighbors = getNeighbors(row, col);
                    let hasRequiredResource = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const neighborTile = challengeData.tiles[neighborKey];
                        if (neighborTile && neighborTile.resource && itemData.required_resource_adjacency.includes(neighborTile.resource)) {
                            hasRequiredResource = true;
                            break;
                        }
                    }
                    if (!hasRequiredResource) return false;
                }
                
                // Check required district adjacency
                if (itemData.required_district_adjacency && itemData.required_district_adjacency.length > 0) {
                    const neighbors = getNeighbors(row, col);
                    let hasRequiredDistrict = false;
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.row},${neighbor.col}`;
                        const placed = placedItems[neighborKey];
                        if (placed && placed.type === 'district' && itemData.required_district_adjacency.includes(placed.name)) {
                            hasRequiredDistrict = true;
                            break;
                        }
                    }
                    if (!hasRequiredDistrict) return false;
                }
            }
            
            return true;
        }

        function hasCityCenterAdjacent(row, col) {
            const neighbors = getNeighbors(row, col);
            for (const neighbor of neighbors) {
                const key = `${neighbor.row},${neighbor.col}`;
                const placed = placedItems[key];
                if (placed && placed.type === 'district' && placed.name === 'City_Center') {
                    return true;
                }
            }
            return false;
        }

        function getNeighbors(row, col) {
            const neighbors = [];
            const isOddRow = row % 2 === 1;
            
            // For flat-top hexagons:
            // Even rows: neighbors are at same col, col-1, col+1
            // Odd rows: neighbors are at same col, col+1, col+1
            
            // Right neighbor
            if (col < GRID_WIDTH - 1) {
                neighbors.push({ row, col: col + 1 });
            }
            
            // Left neighbor
            if (col > 0) {
                neighbors.push({ row, col: col - 1 });
            }
            
            // Top and bottom neighbors depend on row parity
            if (isOddRow) {
                // Odd row: top neighbors are at row-1, same col and col+1
                if (row > 0) {
                    neighbors.push({ row: row - 1, col });
                    if (col < GRID_WIDTH - 1) {
                        neighbors.push({ row: row - 1, col: col + 1 });
                    }
                }
                // Odd row: bottom neighbors are at row+1, same col and col+1
                if (row < GRID_HEIGHT - 1) {
                    neighbors.push({ row: row + 1, col });
                    if (col < GRID_WIDTH - 1) {
                        neighbors.push({ row: row + 1, col: col + 1 });
                    }
                }
            } else {
                // Even row: top neighbors are at row-1, same col and col-1
                if (row > 0) {
                    neighbors.push({ row: row - 1, col });
                    if (col > 0) {
                        neighbors.push({ row: row - 1, col: col - 1 });
                    }
                }
                // Even row: bottom neighbors are at row+1, same col and col-1
                if (row < GRID_HEIGHT - 1) {
                    neighbors.push({ row: row + 1, col });
                    if (col > 0) {
                        neighbors.push({ row: row + 1, col: col - 1 });
                    }
                }
            }
            
            return neighbors;
        }

        function calculateAdjacency(row, col) {
            const key = `${row},${col}`;
            const placed = placedItems[key];
            if (!placed || placed.type !== 'district') return null;
            
            const districtName = placed.name;
            const districtBonus = adjacencyData.district_adjacency_bonuses.find(d => d.name === districtName);
            if (!districtBonus) return null;
            
            const tile = challengeData.tiles[key];
            const neighbors = getNeighbors(row, col);
            
            let science = 0;
            let faith = 0;
            let gold = 0;
            let production = 0;
            let culture = 0;
            
            const bonuses = districtBonus.adjacency_bonuses;
            
            // Check terrain/features on this tile
            if (tile) {
                if (tile.terrain) {
                    if (tile.terrain.includes('Mountain')) {
                        if (bonuses.Mountain) {
                            const bonus = bonuses.Mountain;
                            if (bonus.type === 'Science') science += bonus.bonus;
                            else if (bonus.type === 'Faith') faith += bonus.bonus;
                        }
                    }
                }
                if (tile.feature) {
                    if (bonuses[tile.feature]) {
                        const bonus = bonuses[tile.feature];
                        if (bonus.type === 'Science') science += bonus.bonus;
                        else if (bonus.type === 'Faith') faith += bonus.bonus;
                    }
                }
                if (tile.resource) {
                    // Check for coastal resources
                    if (tile.terrain === 'Coast' || tile.terrain === 'Ocean' || tile.terrain === 'Reef') {
                        if (bonuses.Coastal_Resources) {
                            const bonus = bonuses.Coastal_Resources;
                            if (bonus.type === 'Gold') gold += bonus.bonus;
                        }
                    }
                }
                
                // Check for river edges
                if (tile.rivers) {
                    let hasRiver = false;
                    for (let i = 0; i < 6; i++) {
                        if (tile.rivers[i]) {
                            hasRiver = true;
                            break;
                        }
                    }
                    if (hasRiver && bonuses.River_Edge) {
                        const bonus = bonuses.River_Edge;
                        if (bonus.type === 'Gold') gold += bonus.bonus;
                    }
                }
            }
            
            // Check neighbors
            let districtCount = 0;
            let cityCenterCount = 0;
            let harborCount = 0;
            let commercialHubCount = 0;
            let wonderCount = 0;
            let entertainmentComplexCount = 0;
            let waterParkCount = 0;
            let governmentPlazaCount = 0;
            let improvementCounts = {};
            
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborPlaced = placedItems[neighborKey];
                const neighborTile = challengeData.tiles[neighborKey];
                
                if (neighborPlaced) {
                    if (neighborPlaced.type === 'district') {
                        districtCount++;
                        if (neighborPlaced.name === 'City_Center') cityCenterCount++;
                        if (neighborPlaced.name === 'Harbor') harborCount++;
                        if (neighborPlaced.name === 'Commercial_Hub') commercialHubCount++;
                        if (neighborPlaced.name === 'Government_Plaza') governmentPlazaCount++;
                        if (neighborPlaced.name === 'Entertainment_Complex') entertainmentComplexCount++;
                        if (neighborPlaced.name === 'Water_Park') waterParkCount++;
                    } else if (neighborPlaced.type === 'wonder') {
                        wonderCount++;
                    } else if (neighborPlaced.type === 'improvement') {
                        improvementCounts[neighborPlaced.name] = (improvementCounts[neighborPlaced.name] || 0) + 1;
                    }
                }
            });
            
            // Apply bonuses
            if (bonuses.all_districts && districtCount > 0) {
                const bonus = bonuses.all_districts;
                const amount = Math.floor(districtCount / bonus.per) * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.City_Center && cityCenterCount > 0) {
                const bonus = bonuses.City_Center;
                const amount = cityCenterCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Harbor && harborCount > 0) {
                const bonus = bonuses.Harbor;
                const amount = harborCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Commercial_Hub && commercialHubCount > 0) {
                const bonus = bonuses.Commercial_Hub;
                const amount = commercialHubCount * bonus.bonus;
                if (bonus.type === 'Gold') gold += amount;
            }
            
            if (bonuses.Government_Plaza && governmentPlazaCount > 0) {
                const bonus = bonuses.Government_Plaza;
                const amount = governmentPlazaCount * bonus.bonus;
                if (bonus.type === 'Science') science += amount;
                else if (bonus.type === 'Faith') faith += amount;
                else if (bonus.type === 'Gold') gold += amount;
                else if (bonus.type === 'Production') production += amount;
                else if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Wonder && wonderCount > 0) {
                const bonus = bonuses.Wonder;
                const amount = wonderCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Entertainment_Complex && entertainmentComplexCount > 0) {
                const bonus = bonuses.Entertainment_Complex;
                const amount = entertainmentComplexCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            if (bonuses.Water_Park && waterParkCount > 0) {
                const bonus = bonuses.Water_Park;
                const amount = waterParkCount * bonus.bonus;
                if (bonus.type === 'Culture') culture += amount;
            }
            
            // Check improvements
            if (bonuses.Mine && improvementCounts.Mine) {
                const bonus = bonuses.Mine;
                const amount = Math.floor(improvementCounts.Mine / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Lumber_Mill && improvementCounts.Lumber_Mill) {
                const bonus = bonuses.Lumber_Mill;
                const amount = Math.floor(improvementCounts.Lumber_Mill / bonus.per) * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Quarry && improvementCounts.Quarry) {
                const bonus = bonuses.Quarry;
                const amount = improvementCounts.Quarry * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Aqueduct && improvementCounts.Aqueduct) {
                const bonus = bonuses.Aqueduct;
                const amount = improvementCounts.Aqueduct * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Dam && improvementCounts.Dam) {
                const bonus = bonuses.Dam;
                const amount = improvementCounts.Dam * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            if (bonuses.Canal && improvementCounts.Canal) {
                const bonus = bonuses.Canal;
                const amount = improvementCounts.Canal * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            // Check for strategic resources
            let strategicResourceCount = 0;
            neighbors.forEach(neighbor => {
                const neighborKey = `${neighbor.row},${neighbor.col}`;
                const neighborTile = challengeData.tiles[neighborKey];
                if (neighborTile && neighborTile.resource) {
                    const resourceInfo = resourcesData.strategic_resources.find(r => r.name === neighborTile.resource);
                    if (resourceInfo) {
                        strategicResourceCount++;
                    }
                }
            });
            
            if (bonuses.Strategic_Resource && strategicResourceCount > 0) {
                const bonus = bonuses.Strategic_Resource;
                const amount = strategicResourceCount * bonus.bonus;
                if (bonus.type === 'Production') production += amount;
            }
            
            return {
                science,
                faith,
                gold,
                production,
                culture,
                total: science + faith + gold + production + culture
            };
        }

        function updateAllScores() {
            let totalScience = 0;
            let totalFaith = 0;
            let totalGold = 0;
            let totalProduction = 0;
            let totalCulture = 0;
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const adjacency = calculateAdjacency(row, col);
                    if (adjacency) {
                        totalScience += adjacency.science;
                        totalFaith += adjacency.faith;
                        totalGold += adjacency.gold;
                        totalProduction += adjacency.production;
                        totalCulture += adjacency.culture;
                    }
                }
            }
            
            const scorePanel = document.getElementById('scorePanel');
            if (scorePanel) {
                scorePanel.innerHTML = `
                    <h3>Adjacency Bonuses</h3>
                    <div class="score-item">
                        <span>Science:</span>
                        <span>${totalScience}</span>
                    </div>
                    <div class="score-item">
                        <span>Faith:</span>
                        <span>${totalFaith}</span>
                    </div>
                    <div class="score-item">
                        <span>Gold:</span>
                        <span>${totalGold}</span>
                    </div>
                    <div class="score-item">
                        <span>Production:</span>
                        <span>${totalProduction}</span>
                    </div>
                    <div class="score-item">
                        <span>Culture:</span>
                        <span>${totalCulture}</span>
                    </div>
                    <div class="score-total">
                        <div class="score-item">
                            <span>Total Score:</span>
                            <span>${totalScience + totalFaith + totalGold + totalProduction + totalCulture}</span>
                        </div>
                    </div>
                `;
            }
        }

        function initMapZoomPan() {
            const mapContainer = document.getElementById('mapContainer');
            const mapTransformWrapper = document.getElementById('mapTransformWrapper');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const resetZoomBtn = document.getElementById('resetZoomBtn');

            function updateTransform() {
                mapTransformWrapper.style.transform = `translate(${mapPanX}px, ${mapPanY}px) scale(${mapZoom})`;
            }

            zoomInBtn.onclick = (e) => {
                e.stopPropagation();
                mapZoom = Math.min(mapZoom * 1.2, 3.0);
                updateTransform();
            };

            zoomOutBtn.onclick = (e) => {
                e.stopPropagation();
                mapZoom = Math.max(mapZoom / 1.2, 0.5);
                updateTransform();
            };

            resetZoomBtn.onclick = (e) => {
                e.stopPropagation();
                mapZoom = 1.0;
                mapPanX = 0;
                mapPanY = 0;
                updateTransform();
            };

            mapContainer.addEventListener('wheel', (e) => {
                if (!e.ctrlKey && !e.shiftKey && !e.altKey) {
                    e.preventDefault();
                    const rect = mapContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const containerCenterX = rect.width / 2;
                    const containerCenterY = rect.height / 2;
                    
                    const deltaX = mouseX - containerCenterX;
                    const deltaY = mouseY - containerCenterY;
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.5, Math.min(3.0, mapZoom * zoomFactor));
                    
                    const zoomChange = newZoom / mapZoom;
                    mapPanX = mapPanX * zoomChange + (deltaX * (1 - zoomChange));
                    mapPanY = mapPanY * zoomChange + (deltaY * (1 - zoomChange));
                    mapZoom = newZoom;
                    
                    updateTransform();
                }
            }, { passive: false });

            mapContainer.addEventListener('mousedown', (e) => {
                const isHexClick = e.target.closest('.hex');
                const isButtonClick = e.target.closest('button');
                const isScorePanel = e.target.closest('.score-panel');
                
                if (e.button === 0 && !isHexClick && !isButtonClick && !isScorePanel) {
                    if (e.target === mapContainer || e.target === mapTransformWrapper || e.target.id === 'hexGrid') {
                        isDragging = true;
                        mapContainer.classList.add('dragging');
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        dragStartPanX = mapPanX;
                        dragStartPanY = mapPanY;
                        e.preventDefault();
                    }
                }
            });

            mapContainer.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    mapPanX = dragStartPanX + deltaX;
                    mapPanY = dragStartPanY + deltaY;
                    updateTransform();
                }
            });

            mapContainer.addEventListener('mouseup', (e) => {
                if (isDragging && e.button === 0) {
                    isDragging = false;
                    mapContainer.classList.remove('dragging');
                }
            });

            mapContainer.addEventListener('mouseleave', () => {
                if (isDragging) {
                    isDragging = false;
                    mapContainer.classList.remove('dragging');
                }
            });

            updateTransform();
        }

        // Embedded game data (embedded directly to avoid CORS issues)
        const embeddedAdjacencyData = {
            "district_adjacency_bonuses": [
                {
                    "name": "Campus",
                    "adjacency_bonuses": {
                        "Mountain": {"bonus": 1, "type": "Science", "per": 1},
                        "Rainforest": {"bonus": 1, "type": "Science", "per": 2},
                        "Geothermal_Fissure": {"bonus": 2, "type": "Science", "per": 1},
                        "Reef": {"bonus": 2, "type": "Science", "per": 1},
                        "all_districts": {"bonus": 1, "type": "Science", "per": 2},
                        "Government_Plaza": {"bonus": 1, "type": "Science", "per": 1}
                    }
                },
                {
                    "name": "Holy_Site",
                    "adjacency_bonuses": {
                        "Mountain": {"bonus": 1, "type": "Faith", "per": 1},
                        "Woods": {"bonus": 1, "type": "Faith", "per": 2},
                        "Natural_Wonder": {"bonus": 2, "type": "Faith", "per": 1},
                        "all_districts": {"bonus": 1, "type": "Faith", "per": 2},
                        "Government_Plaza": {"bonus": 1, "type": "Faith", "per": 1}
                    }
                },
                {
                    "name": "Commercial_Hub",
                    "adjacency_bonuses": {
                        "City_Center": {"bonus": 2, "type": "Gold", "per": 1},
                        "River_Edge": {"bonus": 1, "type": "Gold", "per": 1},
                        "Harbor": {"bonus": 2, "type": "Gold", "per": 1},
                        "all_districts": {"bonus": 1, "type": "Gold", "per": 2},
                        "Government_Plaza": {"bonus": 1, "type": "Gold", "per": 1}
                    }
                },
                {
                    "name": "Harbor",
                    "adjacency_bonuses": {
                        "Coastal_Resources": {"bonus": 1, "type": "Gold", "per": 1},
                        "Commercial_Hub": {"bonus": 2, "type": "Gold", "per": 1},
                        "City_Center": {"bonus": 2, "type": "Gold", "per": 1},
                        "all_districts": {"bonus": 1, "type": "Gold", "per": 2},
                        "Government_Plaza": {"bonus": 1, "type": "Gold", "per": 1}
                    }
                },
                {
                    "name": "Industrial_Zone",
                    "adjacency_bonuses": {
                        "Mine": {"bonus": 1, "type": "Production", "per": 2},
                        "Lumber_Mill": {"bonus": 1, "type": "Production", "per": 2},
                        "Quarry": {"bonus": 1, "type": "Production", "per": 1},
                        "Strategic_Resource": {"bonus": 1, "type": "Production", "per": 1},
                        "Aqueduct": {"bonus": 2, "type": "Production", "per": 1},
                        "Dam": {"bonus": 2, "type": "Production", "per": 1},
                        "Canal": {"bonus": 2, "type": "Production", "per": 1},
                        "all_districts": {"bonus": 1, "type": "Production", "per": 2},
                        "Government_Plaza": {"bonus": 1, "type": "Production", "per": 1}
                    }
                },
                {
                    "name": "Theater_Square",
                    "adjacency_bonuses": {
                        "Wonder": {"bonus": 2, "type": "Culture", "per": 1},
                        "Entertainment_Complex": {"bonus": 2, "type": "Culture", "per": 1},
                        "Water_Park": {"bonus": 2, "type": "Culture", "per": 1},
                        "all_districts": {"bonus": 1, "type": "Culture", "per": 2},
                        "Government_Plaza": {"bonus": 1, "type": "Culture", "per": 1}
                    }
                }
            ],
            "districts_with_adjacency": ["Campus", "Holy_Site", "Commercial_Hub", "Harbor", "Industrial_Zone", "Theater_Square"],
            "districts_without_adjacency": ["Aerodrome", "Aqueduct", "Canal", "City_Center", "Dam", "Encampment", "Neighborhood", "Preserve", "Spaceport", "Entertainment_Complex", "Water_Park", "Government_Plaza", "Diplomatic_Quarter"]
        };

        const embeddedPlacementData = JSON.parse('{"districts":[{"name":"Aerodrome","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Aqueduct","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":true},{"name":"Campus","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Canal","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"City_Center","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Commercial_Hub","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Dam","allowed_terrain":["Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Diplomatic_Quarter","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Encampment","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":true,"must_be_adjacent_to_city_center":false},{"name":"Entertainment_Complex","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Government_Plaza","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Harbor","allowed_terrain":["Coast"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Holy_Site","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Industrial_Zone","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Neighborhood","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Preserve","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":true,"must_be_adjacent_to_city_center":false},{"name":"Spaceport","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Theater_Square","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false},{"name":"Water_Park","allowed_terrain":["Coast"],"cant_be_adjacent_to_city_center":false,"must_be_adjacent_to_city_center":false}],"improvements":[{"name":"Camp","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":true,"resources_its_built_on":["Deer","Furs","Ivory","Truffles"]},{"name":"Farm","allowed_terrain":["Grassland","Plains","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":false,"resources_its_built_on":["Rice","Wheat","Maize"]},{"name":"Fishing_Boats","allowed_terrain":["Coast"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":true,"resources_its_built_on":["Fish","Amber","Pearls","Turtles","Whales"]},{"name":"Lumber_Mill","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills"],"must_be_on_woods":true,"must_be_coastal":false,"only_buildable_on_resources":false,"resources_its_built_on":[]},{"name":"Mine","allowed_terrain":["Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":false,"resources_its_built_on":["Iron","Coal","Niter","Uranium","Salt","Diamonds","Jade","Mercury","Silver"]},{"name":"Offshore_Oil_Rig","allowed_terrain":["Coast","Ocean"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":true,"resources_its_built_on":["Oil"]},{"name":"Offshore_Wind_Farm","allowed_terrain":["Coast","Ocean"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":false,"resources_its_built_on":[]},{"name":"Oil_Well","allowed_terrain":["Grassland","Plains","Desert","Tundra","Desert_Floodplains"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":true,"resources_its_built_on":["Oil"]},{"name":"Pasture","allowed_terrain":["Grassland","Plains","Desert","Tundra","Desert_Hill","Grassland_Hill","Plains_Hill","Tundra_Hills"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":true,"resources_its_built_on":["Horses","Cattle","Sheep"]},{"name":"Plantation","allowed_terrain":["Grassland","Plains","Desert","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":true,"resources_its_built_on":["Bananas","Citrus","Cotton","Dyes","Incense","Silk","Spices","Sugar","Tea","Tobacco","Wine","Coffee","Cocoa","Olives"]},{"name":"Quarry","allowed_terrain":["Grassland","Plains","Desert","Tundra","Desert_Hill","Grassland_Hill","Plains_Hill","Tundra_Hills"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":true,"resources_its_built_on":["Stone","Marble","Gypsum"]},{"name":"Seaside_Resort","allowed_terrain":["Desert","Plains","Grassland"],"must_be_on_woods":false,"must_be_coastal":true,"only_buildable_on_resources":false,"resources_its_built_on":[]},{"name":"Ski_Resort","allowed_terrain":["Mountain_Desert","Mountain_Grassland","Mountain_Plains","Mountain_Snow","Mountain_Tundra"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":false,"resources_its_built_on":[]},{"name":"Solar_Farm","allowed_terrain":["Desert","Plains","Grassland","Tundra"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":false,"resources_its_built_on":[]},{"name":"Wind_Farm","allowed_terrain":["Snow_Hill","Desert_Hill","Grassland_Hill","Plains_Hill","Tundra_Hills"],"must_be_on_woods":false,"must_be_coastal":false,"only_buildable_on_resources":false,"resources_its_built_on":[]}],"wonders":[{"name":"Angkor_Wat","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"allowed_features":[],"required_feature_adjacency":[],"required_resource_adjacency":[],"required_district_adjacency":["Aqueduct"]},{"name":"Bolshoi_Theatre","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"allowed_features":[],"required_feature_adjacency":[],"required_resource_adjacency":[],"required_district_adjacency":["Theater_Square"]},{"name":"Casa_de_Contratacion","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"allowed_features":[],"required_feature_adjacency":[],"required_resource_adjacency":[],"required_district_adjacency":["Government_Plaza"]},{"name":"Colosseum","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"allowed_features":[],"required_feature_adjacency":[],"required_resource_adjacency":[],"required_district_adjacency":["Entertainment_Complex"]},{"name":"Colossus","allowed_terrain":["Coast"],"allowed_features":[],"required_feature_adjacency":[],"required_resource_adjacency":[],"required_district_adjacency":["Harbor"]},{"name":"Etemenanki","allowed_terrain":["Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"allowed_features":["Marsh"],"required_feature_adjacency":[],"required_resource_adjacency":[],"required_district_adjacency":[]},{"name":"Great_Zimbabwe","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"allowed_features":[],"required_feature_adjacency":[],"required_resource_adjacency":["Cattle"],"required_district_adjacency":["Commercial_Hub"]},{"name":"Oracle","allowed_terrain":["Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills"],"allowed_features":[],"required_feature_adjacency":[],"required_resource_adjacency":[],"required_district_adjacency":["Campus"]},{"name":"Pyramids","allowed_terrain":["Desert","Desert_Floodplains"],"allowed_features":[],"required_feature_adjacency":[],"required_resource_adjacency":[],"required_district_adjacency":[]},{"name":"Stonehenge","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow"],"allowed_features":[],"required_feature_adjacency":[],"required_resource_adjacency":["Stone"],"required_district_adjacency":[]},{"name":"Temple_of_Artemis","allowed_terrain":["Grassland","Plains","Desert","Tundra","Snow","Desert_Hill","Grassland_Hill","Plains_Hill","Snow_Hill","Tundra_Hills","Desert_Floodplains","Grassland_Floodplains","Plains_Floodplains"],"allowed_features":[],"required_feature_adjacency":["Camp"],"required_resource_adjacency":[],"required_district_adjacency":[]},{"name":"University_of_Sankore","allowed_terrain":["Desert","Desert_Floodplains"],"allowed_features":[],"required_feature_adjacency":[],"required_resource_adjacency":[],"required_district_adjacency":["Campus"]}]}');

        const embeddedResourcesData = JSON.parse('{"bonus_resources":[{"name":"Bananas","improvement":"Plantation","is_coastal":false},{"name":"Cattle","improvement":"Pasture","is_coastal":false},{"name":"Fish","improvement":"Fishing_Boats","is_coastal":true},{"name":"Rice","improvement":"Farm","is_coastal":false},{"name":"Sheep","improvement":"Pasture","is_coastal":false},{"name":"Stone","improvement":"Quarry","is_coastal":false},{"name":"Wheat","improvement":"Farm","is_coastal":false},{"name":"Deer","improvement":"Camp","is_coastal":false},{"name":"Maize","improvement":"Farm","is_coastal":false}],"luxury_resources":[{"name":"Amber","improvement":"Fishing_Boats","is_coastal":true},{"name":"Citrus","improvement":"Plantation","is_coastal":false},{"name":"Cocoa","improvement":"Plantation","is_coastal":false},{"name":"Coffee","improvement":"Plantation","is_coastal":false},{"name":"Cotton","improvement":"Plantation","is_coastal":false},{"name":"Diamonds","improvement":"Mine","is_coastal":false},{"name":"Dyes","improvement":"Plantation","is_coastal":false},{"name":"Furs","improvement":"Camp","is_coastal":false},{"name":"Gypsum","improvement":"Quarry","is_coastal":false},{"name":"Incense","improvement":"Plantation","is_coastal":false},{"name":"Ivory","improvement":"Camp","is_coastal":false},{"name":"Jade","improvement":"Mine","is_coastal":false},{"name":"Marble","improvement":"Quarry","is_coastal":false},{"name":"Mercury","improvement":"Mine","is_coastal":false},{"name":"Olives","improvement":"Plantation","is_coastal":false},{"name":"Pearls","improvement":"Fishing_Boats","is_coastal":true},{"name":"Salt","improvement":"Mine","is_coastal":false},{"name":"Silk","improvement":"Plantation","is_coastal":false},{"name":"Silver","improvement":"Mine","is_coastal":false},{"name":"Spices","improvement":"Plantation","is_coastal":false},{"name":"Sugar","improvement":"Plantation","is_coastal":false},{"name":"Tea","improvement":"Plantation","is_coastal":false},{"name":"Tobacco","improvement":"Plantation","is_coastal":false},{"name":"Truffles","improvement":"Camp","is_coastal":false},{"name":"Turtles","improvement":"Fishing_Boats","is_coastal":true},{"name":"Wine","improvement":"Plantation","is_coastal":false},{"name":"Whales","improvement":"Fishing_Boats","is_coastal":true}],"strategic_resources":[{"name":"Horses","improvement":"Pasture","is_coastal":false},{"name":"Iron","improvement":"Mine","is_coastal":false},{"name":"Niter","improvement":"Mine","is_coastal":false},{"name":"Coal","improvement":"Mine","is_coastal":false},{"name":"Oil","improvement":"Oil_Well","water_improvement":"Offshore_Oil_Rig","is_coastal":false},{"name":"Uranium","improvement":"Mine","is_coastal":false}]}');

        // Load game data (embedded directly, no fetch needed)
        function loadGameData() {
            adjacencyData = embeddedAdjacencyData;
            placementData = embeddedPlacementData;
            resourcesData = embeddedResourcesData;
        }
        
        // Initialize on load
        loadGameData();
    </script>
</body>
</html>

